{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the NetBox Labs Documentation Site The home of documentation for NetBox Cloud , Enterprise , Integrations , SDKs and Extensions .","title":"Home"},{"location":"#welcome-to-the-netbox-labs-documentation-site","text":"The home of documentation for NetBox Cloud , Enterprise , Integrations , SDKs and Extensions .","title":"Welcome to the NetBox Labs Documentation Site"},{"location":"discovery-assurance/","text":"NetBox Cloud NetBox Enterprise NetBox Community NetBox Discovery Public Preview NetBox Discovery is currently in Public Preview. Please refer to NetBox Labs Product and Feature Lifecycle to get more details. NetBox Discovery enables operators to gather and ingest network and infrastructure information into NetBox to rapidly document the IT footprint within NetBox\u2019s model. The product seamlessly facilitates fast onboarding of infrastructure into NetBox, and accelerates the journey to intent-based automation with NetBox as the source of truth. NetBox Discovery is powered by Orb\u2019s rock solid distributed agent framework, enabling discovery agents to be deployed quickly and easily in your network. NetBox Discovery agents can be deployed strategically in segmented network environments with strict reachability boundaries, enabling discovery even in environments where central deployment limits reach and visibility. Agents can be fanned out to parallelize discovery workloads, improving performance in large environments. NetBox Assurance Coming early 2025 Be among the first to experience NetBox Assurance . Sign up to be notified when we launch. NetBox Assurance enables operators to identify, understand, and mitigate operational drift - deviations in the infrastructure from the intended state and configuration. With NetBox Assurance, teams can leverage NetBox\u2019s source of truth alongside NetBox Discovery and other data sources to constantly identify, analyze, and report on drift across their infrastructure. The product provides the insights needed to establish remediation plans and quickly make decisions and take action on every deviation. NetBox Assurance speeds up troubleshooting, reduces outages, and unlocks the path to automation. NetBox Assurance builds atop Diode, the scalable data ingestion service for NetBox. Any source that can send data to Diode\u2019s open APIs, such as NetBox Discovery, other discovery tools, data exchange integrations, or custom scripts using the Diode SDK, can feed input to NetBox Assurance. The product provides analytics and exploration tools for characterizing and planning remediation of operational drift, along with power tools for inspecting and taking mitigation actions on deviations as they arise including triggering automated remediations. With NetBox Assurance, operators can improve overall operations, reduce change risk, mitigate failures and security threats quickly, and accelerate automation.","title":"Solution Overview"},{"location":"discovery-assurance/#netbox-discovery","text":"Public Preview NetBox Discovery is currently in Public Preview. Please refer to NetBox Labs Product and Feature Lifecycle to get more details. NetBox Discovery enables operators to gather and ingest network and infrastructure information into NetBox to rapidly document the IT footprint within NetBox\u2019s model. The product seamlessly facilitates fast onboarding of infrastructure into NetBox, and accelerates the journey to intent-based automation with NetBox as the source of truth. NetBox Discovery is powered by Orb\u2019s rock solid distributed agent framework, enabling discovery agents to be deployed quickly and easily in your network. NetBox Discovery agents can be deployed strategically in segmented network environments with strict reachability boundaries, enabling discovery even in environments where central deployment limits reach and visibility. Agents can be fanned out to parallelize discovery workloads, improving performance in large environments.","title":"NetBox Discovery"},{"location":"discovery-assurance/#netbox-assurance","text":"Coming early 2025 Be among the first to experience NetBox Assurance . Sign up to be notified when we launch. NetBox Assurance enables operators to identify, understand, and mitigate operational drift - deviations in the infrastructure from the intended state and configuration. With NetBox Assurance, teams can leverage NetBox\u2019s source of truth alongside NetBox Discovery and other data sources to constantly identify, analyze, and report on drift across their infrastructure. The product provides the insights needed to establish remediation plans and quickly make decisions and take action on every deviation. NetBox Assurance speeds up troubleshooting, reduces outages, and unlocks the path to automation. NetBox Assurance builds atop Diode, the scalable data ingestion service for NetBox. Any source that can send data to Diode\u2019s open APIs, such as NetBox Discovery, other discovery tools, data exchange integrations, or custom scripts using the Diode SDK, can feed input to NetBox Assurance. The product provides analytics and exploration tools for characterizing and planning remediation of operational drift, along with power tools for inspecting and taking mitigation actions on deviations as they arise including triggering automated remediations. With NetBox Assurance, operators can improve overall operations, reduce change risk, mitigate failures and security threats quickly, and accelerate automation.","title":"NetBox Assurance"},{"location":"maintenance/","text":"Weekly NetBox Labs Platform Maintenance Window Notice There are weekly maintenance windows for the NetBox Cloud Platform on Tuesdays and Thursdays between the hours of 3:00 - 5:00am EDT / 12:00 - 2:00am PDT / 07:00 - 09:00 UTC. These windows are used for routine maintenance on the infrastructure supporting the NetBox Labs Console, NetBox Cloud instances, and other cloud products and services offered by NetBox Labs. This includes applying necessary security patches and required upgrades to cloud infrastructure, and/or making other underlying infrastructure changes to increase reliability, security and performance. Not every maintenance window will be used, and when it is used we will always try to complete the maintenance with no disruption to your service. In the case that downtime is unavoidable, you can expect the downtime to be limited to no more than a few minutes. If it is ever necessary to perform maintenance that could result in more extended downtime, we will provide ample notice and create a separate one-time maintenance window on status.netboxlabs.com . Note that the routine Tuesday/Thursday maintenance windows will not be reflected on the status page. If you have any automation jobs running during these maintenance windows, we recommend that you ensure that they include business logic to properly handle failed requests, and/or shift them to run outside the maintenance windows. Please don\u2019t hesitate to reach out to the NetBox Labs Support Team if you have any questions about this or anything else regarding NetBox Cloud. We are always happy to jump on a call or chat over email to answer any of your questions.","title":"Scheduled Maintenance"},{"location":"maintenance/#weekly-netbox-labs-platform-maintenance-window-notice","text":"There are weekly maintenance windows for the NetBox Cloud Platform on Tuesdays and Thursdays between the hours of 3:00 - 5:00am EDT / 12:00 - 2:00am PDT / 07:00 - 09:00 UTC. These windows are used for routine maintenance on the infrastructure supporting the NetBox Labs Console, NetBox Cloud instances, and other cloud products and services offered by NetBox Labs. This includes applying necessary security patches and required upgrades to cloud infrastructure, and/or making other underlying infrastructure changes to increase reliability, security and performance. Not every maintenance window will be used, and when it is used we will always try to complete the maintenance with no disruption to your service. In the case that downtime is unavoidable, you can expect the downtime to be limited to no more than a few minutes. If it is ever necessary to perform maintenance that could result in more extended downtime, we will provide ample notice and create a separate one-time maintenance window on status.netboxlabs.com . Note that the routine Tuesday/Thursday maintenance windows will not be reflected on the status page. If you have any automation jobs running during these maintenance windows, we recommend that you ensure that they include business logic to properly handle failed requests, and/or shift them to run outside the maintenance windows. Please don\u2019t hesitate to reach out to the NetBox Labs Support Team if you have any questions about this or anything else regarding NetBox Cloud. We are always happy to jump on a call or chat over email to answer any of your questions.","title":"Weekly NetBox Labs Platform Maintenance Window Notice"},{"location":"product_feature_lifecycle/","text":"NetBox Labs Product and Feature Lifecycle NetBox Labs products and features can go through multiple release stages before becoming generally available. These stages in the release life cycle can present varying degrees of stability and support. The following are the NetBox Labs release stages: Experimental Private Preview Public Preview General Availability (GA) Quick Reference Experimental Private Preview Public Preview General Availability (GA) Audience Internal Invited customers Early adopters and users who request access Available to all customers at the appropriate tier Risk High (unknown) risk Medium-high risk Low-medium risk Low (known) risk Support Not supported Limited support through product and engineering Support limited to enablement and configuration Fully supported Documentation Code comments Unofficial; communicated with participants Limited; publicly available Publicly available Full Definitions Experimental This stage is for internal testing within the company. Products or features under this category are in their initial development phases, with high risks associated due to unknown variables. They are not supported and documentation is typically limited to code comments, aiming to gather preliminary insights and feedback internally. Private Preview At this stage, products or features are shared with a select group of invited customers. This allows for more focused feedback and testing under real-world conditions, albeit with a medium-high risk. Support is limited and direct through product and engineering teams, with documentation being unofficial and primarily communicated directly with the participants. Public Preview During the Public Preview, products or features are made available to early adopters and users who specifically request access. This phase aims to broaden the feedback loop and iron out any remaining issues, presenting a low to medium risk. Support is available but generally limited to enablement and configuration advice, with documentation becoming more accessible but still considered limited. General Availability Once a product or feature reaches General Availability, it is available to all customers at the appropriate tier, marking its full release. The risk associated with using these products or features is low, as they are considered stable and reliable. Full support is provided at this stage, and documentation is comprehensive and publicly available. Please don\u2019t hesitate to contact us if you have any questions about this or you would like to discuss getting access to Private Preview or Public Preview products or features.","title":"Product and Feature Lifecycle"},{"location":"product_feature_lifecycle/#netbox-labs-product-and-feature-lifecycle","text":"NetBox Labs products and features can go through multiple release stages before becoming generally available. These stages in the release life cycle can present varying degrees of stability and support. The following are the NetBox Labs release stages: Experimental Private Preview Public Preview General Availability (GA)","title":"NetBox Labs Product and Feature Lifecycle"},{"location":"product_feature_lifecycle/#quick-reference","text":"Experimental Private Preview Public Preview General Availability (GA) Audience Internal Invited customers Early adopters and users who request access Available to all customers at the appropriate tier Risk High (unknown) risk Medium-high risk Low-medium risk Low (known) risk Support Not supported Limited support through product and engineering Support limited to enablement and configuration Fully supported Documentation Code comments Unofficial; communicated with participants Limited; publicly available Publicly available","title":"Quick Reference"},{"location":"product_feature_lifecycle/#full-definitions","text":"","title":"Full Definitions"},{"location":"product_feature_lifecycle/#experimental","text":"This stage is for internal testing within the company. Products or features under this category are in their initial development phases, with high risks associated due to unknown variables. They are not supported and documentation is typically limited to code comments, aiming to gather preliminary insights and feedback internally.","title":"Experimental"},{"location":"product_feature_lifecycle/#private-preview","text":"At this stage, products or features are shared with a select group of invited customers. This allows for more focused feedback and testing under real-world conditions, albeit with a medium-high risk. Support is limited and direct through product and engineering teams, with documentation being unofficial and primarily communicated directly with the participants.","title":"Private Preview"},{"location":"product_feature_lifecycle/#public-preview","text":"During the Public Preview, products or features are made available to early adopters and users who specifically request access. This phase aims to broaden the feedback loop and iron out any remaining issues, presenting a low to medium risk. Support is available but generally limited to enablement and configuration advice, with documentation becoming more accessible but still considered limited.","title":"Public Preview"},{"location":"product_feature_lifecycle/#general-availability","text":"Once a product or feature reaches General Availability, it is available to all customers at the appropriate tier, marking its full release. The risk associated with using these products or features is low, as they are considered stable and reliable. Full support is provided at this stage, and documentation is comprehensive and publicly available. Please don\u2019t hesitate to contact us if you have any questions about this or you would like to discuss getting access to Private Preview or Public Preview products or features.","title":"General Availability"},{"location":"Administration%20Console/azure-ad-sso-setup/","text":"Microsoft Azure AD Setup This guide explains how to configure single sign-on (SSO) support for NetBox Cloud using Microsoft Azure Active Directory (AD) as an authentication backend. Azure AD Configuration Create a test user (optional) Create a new user in AD to be used for testing. You can skip this step if you already have a suitable account created. Create an app registration Under the Azure Active Directory dashboard, navigate to Add > App registration . Enter a name for the registration (e.g. \"NetBox Cloud\") and ensure that the \"single tenant\" option is selected. Under \"Redirect URI\", select \"Web\" for the platform and enter the path to your NetBox Cloud installation, ending with /oauth/complete/azuread-oauth2/. Eg. https://{your-domain}.cloud.netboxapp.com/oauth/complete/azuread-oauth2/ Once finished, make note of the application (client) ID; this will be used when configuring NetBox Cloud. Multitenant authentication NetBox also supports multitenant authentication via Azure AD, however it requires a different backend and an additional configuration parameter. Please see the python-social-auth documentation for details concerning multitenant authentication. Create a secret When viewing the newly-created app registration, click the \"Add a certificate or secret\" link under \"Client credentials\". Under the \"Client secrets\" tab, click the \"New client secret\" button. You can optionally specify a description and select a lifetime for the secret. Once finished, make note of the secret value (not the secret ID); this will be used when configuring NetBox Cloud. NetBox Cloud Configuration Securely share the following configuration parameters with NetBox Labs Support , substituting your own values: REMOTE_AUTH_BACKEND = 'social_core.backends.azuread.AzureADOAuth2' SOCIAL_AUTH_AZUREAD_OAUTH2_KEY = '{APPLICATION_ID}' SOCIAL_AUTH_AZUREAD_OAUTH2_SECRET = '{SECRET_VALUE}' The support team will add these parameters to your NetBox Cloud instance and confirm when this is ready for testing. Testing Log out of NetBox Cloud if already authenticated, and click the \"Log In\" button at top right. You should see the normal login form as well as an option to authenticate using Azure AD. Click that link. You should be redirected to Microsoft's authentication portal. Enter the username/email and password of your account to continue. You may also be prompted to grant this application access to your account. If successful, you will be redirected back to the NetBox Cloud UI, and will be logged in as the AD user. You can verify this by navigating to your profile (using the button at top right). This user account has been replicated locally to NetBox Cloud, and can now be assigned groups and permissions within the NetBox Cloud admin UI. Troubleshooting Redirect URI does not Match Azure requires that the authenticating client request a redirect URI that matches what you've configured for the app in step two. This URI must begin with https:// Not Logged in After Authenticating If you are redirected to the NetBox Cloud UI after authenticating successfully, but are not logged in, double-check the configured backend and app registration. The instructions in this guide pertain only to the azuread.AzureADOAuth2 backend using a single-tenant app registration.","title":"Set up Azure AD SSO"},{"location":"Administration%20Console/azure-ad-sso-setup/#microsoft-azure-ad-setup","text":"This guide explains how to configure single sign-on (SSO) support for NetBox Cloud using Microsoft Azure Active Directory (AD) as an authentication backend.","title":"Microsoft Azure AD Setup"},{"location":"Administration%20Console/azure-ad-sso-setup/#azure-ad-configuration","text":"Create a test user (optional) Create a new user in AD to be used for testing. You can skip this step if you already have a suitable account created. Create an app registration Under the Azure Active Directory dashboard, navigate to Add > App registration . Enter a name for the registration (e.g. \"NetBox Cloud\") and ensure that the \"single tenant\" option is selected. Under \"Redirect URI\", select \"Web\" for the platform and enter the path to your NetBox Cloud installation, ending with /oauth/complete/azuread-oauth2/. Eg. https://{your-domain}.cloud.netboxapp.com/oauth/complete/azuread-oauth2/ Once finished, make note of the application (client) ID; this will be used when configuring NetBox Cloud. Multitenant authentication NetBox also supports multitenant authentication via Azure AD, however it requires a different backend and an additional configuration parameter. Please see the python-social-auth documentation for details concerning multitenant authentication. Create a secret When viewing the newly-created app registration, click the \"Add a certificate or secret\" link under \"Client credentials\". Under the \"Client secrets\" tab, click the \"New client secret\" button. You can optionally specify a description and select a lifetime for the secret. Once finished, make note of the secret value (not the secret ID); this will be used when configuring NetBox Cloud.","title":"Azure AD Configuration"},{"location":"Administration%20Console/azure-ad-sso-setup/#netbox-cloud-configuration","text":"Securely share the following configuration parameters with NetBox Labs Support , substituting your own values: REMOTE_AUTH_BACKEND = 'social_core.backends.azuread.AzureADOAuth2' SOCIAL_AUTH_AZUREAD_OAUTH2_KEY = '{APPLICATION_ID}' SOCIAL_AUTH_AZUREAD_OAUTH2_SECRET = '{SECRET_VALUE}' The support team will add these parameters to your NetBox Cloud instance and confirm when this is ready for testing.","title":"NetBox Cloud Configuration"},{"location":"Administration%20Console/azure-ad-sso-setup/#testing","text":"Log out of NetBox Cloud if already authenticated, and click the \"Log In\" button at top right. You should see the normal login form as well as an option to authenticate using Azure AD. Click that link. You should be redirected to Microsoft's authentication portal. Enter the username/email and password of your account to continue. You may also be prompted to grant this application access to your account. If successful, you will be redirected back to the NetBox Cloud UI, and will be logged in as the AD user. You can verify this by navigating to your profile (using the button at top right). This user account has been replicated locally to NetBox Cloud, and can now be assigned groups and permissions within the NetBox Cloud admin UI.","title":"Testing"},{"location":"Administration%20Console/azure-ad-sso-setup/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"Administration%20Console/azure-ad-sso-setup/#redirect-uri-does-not-match","text":"Azure requires that the authenticating client request a redirect URI that matches what you've configured for the app in step two. This URI must begin with https://","title":"Redirect URI does not Match"},{"location":"Administration%20Console/azure-ad-sso-setup/#not-logged-in-after-authenticating","text":"If you are redirected to the NetBox Cloud UI after authenticating successfully, but are not logged in, double-check the configured backend and app registration. The instructions in this guide pertain only to the azuread.AzureADOAuth2 backend using a single-tenant app registration.","title":"Not Logged in After Authenticating"},{"location":"Administration%20Console/azure-group-mapping/","text":"Group Mapping For Azure AD Single Sign-On (SSO) Upgrade your Single Sign-On experience with Group Mapping for Azure SSO \u2013 a smarter, more secure way to manage user access. The Group Mapping feature for Azure Single Sign-On, streamlines the synchronization of group memberships from Azure Active Directory to groups in NetBox Cloud, allowing you to align your user access efficiently and accurately. Info This feature is only available in Pro/Enterprise tiers. Changes in Azure Active Directory groups are reflected in NetBox Cloud, ensuring up-to-date access management and enhanced security. You can tailor the group mapping to your organizational needs while maintaining strict security and compliance standards. If you are already securing access to NetBox Cloud using Azure AD for SSO, and would like use the Group Mapping feature it's easy to get set up. Simply create your groups and permissions in NetBox Cloud, then set up your groups in Azure AD and reach out to the support team at NetBox Labs and we will take care of the group mappings for you to suit your requirements. Note We\u2019ve made some important updates to the Azure AD user group sync feature that may affect group memberships and permissions of Azure AD SSO users accessing NetBox Cloud. To support enterprise Azure AD environments, we\u2019ve added pagination to retrieve large lists (100+) of membership groups for users. To support NetBox group assignments from Azure nested groups, we\u2019ve changed the Azure API endpoint used for group retrieval from memberOf to transitiveMemberOf . This means that users will now be made members of NetBox user groups based on the configured group mappings for both direct membership Azure groups and transitive Azure groups (parent groups of direct membership groups). Under specific conditions, users may gain additional group memberships and permissions. We strongly advise you review your NetBox Cloud and Azure AD user, group and permission configurations to ensure they align to your security requirements. Watch the video below for a step-by-step example of how the Group Mapping feature works, or read on for an explanation. How it Works Group mappings are based on the Object ID of the group in Azure AD. For example: The Object ID is mapped to a group in NetBox Cloud, and that group could have permissions assigned to it. For example, this group called CircuitManager in NetBox Cloud has permissions assigned to it that allows members of the group to manage all of the Circuit and Provider object types: Optionally, members of the Azure AD groups can also be members of the NetBox built-in groups Staff which allows access to the NetBox admin interface, and Superuser which has all permissions without explicitly assigning them. The NetBox Labs support team will map your Azure AD Group Object ID's to your NetBox Cloud groups, for example: Azure AD Group Object ID NetBox Cloud Group Staff Super User 1a36bed9-3bdc-4970-ab66-faf9704e0af4 Circuit Manager Yes No How Do I Get it Set Up? Simply provide us with your requirements in terms of object IDs and NetBox groups and we will take care of the rest. If you have any questions about Group Mapping for Azure AD Single Sign-On (SSO), please raise a support ticket by emailing the NetBox Labs Support Team .","title":"Azure AD Group Mapping"},{"location":"Administration%20Console/azure-group-mapping/#group-mapping-for-azure-ad-single-sign-on-sso","text":"Upgrade your Single Sign-On experience with Group Mapping for Azure SSO \u2013 a smarter, more secure way to manage user access. The Group Mapping feature for Azure Single Sign-On, streamlines the synchronization of group memberships from Azure Active Directory to groups in NetBox Cloud, allowing you to align your user access efficiently and accurately. Info This feature is only available in Pro/Enterprise tiers. Changes in Azure Active Directory groups are reflected in NetBox Cloud, ensuring up-to-date access management and enhanced security. You can tailor the group mapping to your organizational needs while maintaining strict security and compliance standards. If you are already securing access to NetBox Cloud using Azure AD for SSO, and would like use the Group Mapping feature it's easy to get set up. Simply create your groups and permissions in NetBox Cloud, then set up your groups in Azure AD and reach out to the support team at NetBox Labs and we will take care of the group mappings for you to suit your requirements. Note We\u2019ve made some important updates to the Azure AD user group sync feature that may affect group memberships and permissions of Azure AD SSO users accessing NetBox Cloud. To support enterprise Azure AD environments, we\u2019ve added pagination to retrieve large lists (100+) of membership groups for users. To support NetBox group assignments from Azure nested groups, we\u2019ve changed the Azure API endpoint used for group retrieval from memberOf to transitiveMemberOf . This means that users will now be made members of NetBox user groups based on the configured group mappings for both direct membership Azure groups and transitive Azure groups (parent groups of direct membership groups). Under specific conditions, users may gain additional group memberships and permissions. We strongly advise you review your NetBox Cloud and Azure AD user, group and permission configurations to ensure they align to your security requirements. Watch the video below for a step-by-step example of how the Group Mapping feature works, or read on for an explanation.","title":"Group Mapping For Azure AD Single Sign-On (SSO)"},{"location":"Administration%20Console/azure-group-mapping/#how-it-works","text":"Group mappings are based on the Object ID of the group in Azure AD. For example: The Object ID is mapped to a group in NetBox Cloud, and that group could have permissions assigned to it. For example, this group called CircuitManager in NetBox Cloud has permissions assigned to it that allows members of the group to manage all of the Circuit and Provider object types: Optionally, members of the Azure AD groups can also be members of the NetBox built-in groups Staff which allows access to the NetBox admin interface, and Superuser which has all permissions without explicitly assigning them. The NetBox Labs support team will map your Azure AD Group Object ID's to your NetBox Cloud groups, for example: Azure AD Group Object ID NetBox Cloud Group Staff Super User 1a36bed9-3bdc-4970-ab66-faf9704e0af4 Circuit Manager Yes No","title":"How it Works"},{"location":"Administration%20Console/azure-group-mapping/#how-do-i-get-it-set-up","text":"Simply provide us with your requirements in terms of object IDs and NetBox groups and we will take care of the rest. If you have any questions about Group Mapping for Azure AD Single Sign-On (SSO), please raise a support ticket by emailing the NetBox Labs Support Team .","title":"How Do I Get it Set Up?"},{"location":"Administration%20Console/console-access-from-ui/","text":"Accessing the Console from NetBox Cloud From within the NetBox Cloud Web Interface, you can easily switch to the NetBox Labs Console. Simply follow the steps outlined below: In the left hand main menu, click to expand the NetBox Labs plugin menu, and then click on Open Console : You will now be taken to the NetBox Labs Console login page: Note If you don't already have access to the console, you can request this by clicking on Request Console Access in the NetBox Labs plugin menu from the main NetBox Cloud web interface, and then clicking the link to email the NetBox Labs Support Team to request access. If you encounter any issues when accessing the NetBox Labs Console, raise a support ticket by emailing the NetBox Labs Support Team","title":"Accessing the Console From the NetBox Cloud UI"},{"location":"Administration%20Console/console-access-from-ui/#accessing-the-console-from-netbox-cloud","text":"From within the NetBox Cloud Web Interface, you can easily switch to the NetBox Labs Console. Simply follow the steps outlined below: In the left hand main menu, click to expand the NetBox Labs plugin menu, and then click on Open Console : You will now be taken to the NetBox Labs Console login page: Note If you don't already have access to the console, you can request this by clicking on Request Console Access in the NetBox Labs plugin menu from the main NetBox Cloud web interface, and then clicking the link to email the NetBox Labs Support Team to request access. If you encounter any issues when accessing the NetBox Labs Console, raise a support ticket by emailing the NetBox Labs Support Team","title":"Accessing the Console from NetBox Cloud"},{"location":"Administration%20Console/console-access/","text":"NetBox Cloud Setting up Console Access Request access to the NetBox Labs Console by emailing the NetBox Labs Support Team . The NetBox Cloud team will set up your account with your email address as the username, and you will use this to access the NetBox Labs Console . To complete the set up of your account, follow these steps: You will receive an email advising you of your username, along with a temporary password and a link to the console URL. Click the link to login Enter the username (your email address) and the temporary password as per the email, and click \u2018Sign in\u2019: You will then be prompted to change your password: The set up is now complete and you are logged into the NetBox Labs Console. You will see (and be able to administer) all the NetBox Cloud instances running under your Organization. To retrieve the credentials for the admin user of a NetBox Cloud instance, either click to reveal or copy them from the Credentials section: Then click the on either of the two links to open the URL of the instance in a new browser window: Lastly, login to the NetBox Cloud UI with the username and password you have copied from step 5:","title":"Setting up Console Access"},{"location":"Administration%20Console/console-access/#netbox-cloud","text":"","title":"NetBox Cloud"},{"location":"Administration%20Console/console-access/#setting-up-console-access","text":"Request access to the NetBox Labs Console by emailing the NetBox Labs Support Team . The NetBox Cloud team will set up your account with your email address as the username, and you will use this to access the NetBox Labs Console . To complete the set up of your account, follow these steps: You will receive an email advising you of your username, along with a temporary password and a link to the console URL. Click the link to login Enter the username (your email address) and the temporary password as per the email, and click \u2018Sign in\u2019: You will then be prompted to change your password: The set up is now complete and you are logged into the NetBox Labs Console. You will see (and be able to administer) all the NetBox Cloud instances running under your Organization. To retrieve the credentials for the admin user of a NetBox Cloud instance, either click to reveal or copy them from the Credentials section: Then click the on either of the two links to open the URL of the instance in a new browser window: Lastly, login to the NetBox Cloud UI with the username and password you have copied from step 5:","title":"Setting up Console Access"},{"location":"Administration%20Console/console-overview/","text":"NetBox Cloud: Administrative Console Overview Console Access To access your NetBox Cloud Administrative Console, follow these steps: Login to the console Click on the arrow next your Organization Name and then click on the Namespace ID Next scroll down and click on the NetBox panel, and then click on the NetBox ID link to launch the Administrative console Summary View This compressed full page screenshot breaks the full Administrative Console down into similar sections. Each section is designed to give you greater insight to your NetBox instance. Section Breakdown 1. Information Panel The Information Panel provides a view of basic information relating to your NetBox Cloud instance. Here you will find the name of your NetBox Cloud instance within your Organization's Namespace, along with the AWS Region and the NetBox version. You also have a link to the instance raw URL, plus a refresh button for the instance data. 2. NetBox Deployment The NetBox Deployment panel lists various service and configuration status points. Included will be the current version, and version upgrade controls, the number of instance replicas, and resource allocations. The instance image and namespace are also listed here. The left circle icon (stop button) will stop the running NetBox Cloud instance. The center circle icon (play button) will start the NetBox Cloud instance. The right refresh icon will refresh the data in the panel. The Version number with the smaller font displays the current NetBox version The Version drop down lists versions of NetBox that can be changed to. The cloud icon will illuminate if you select a different version of NetBox. The cloud icon will change NetBox to the selected version. The Secrets section provides access to the current secret credentials for the instance API Token, local \u201cadmin\u201d user account and Secret Key. When the Administrative Console initially loads these values will be hidden. Clicking the open eye will reveal the secret details Clicking the closed eye will conceal the secret details Clicking the copy icon will copy the secret to your clipboard 3. Ingress The Ingress pannel gives the Name, Domain and DNS Name information for the NetBox Cloud instance, as well as the number of Ingress Pods and the Load Balancer status. 4. Storage The Storage Panel contains information on the storage bucket, user, and access key ID. Clicking the open eye will reveal the Access Key secret details. 5. Postgres The Postgres Database panel (left) gives the current status of the database, along with details of the host, username and database name for the instance. Clicking the open eye will reveal the Postrges Database secret details. The Postgres panel (right) gives the number of database instances, their status, instance names, version, Aurora capacity unit consumption, current configured backup retention period, and security group IDs. Clicking the open eye will reveal the Postrges secret details. 6. Redis The Redis Database panel (left) gives the name, status, host, user, and ID of the Main and Cache Redis databases. The Redis panel (right) gives the name, status, resource, image and version information for the Redis instance. Clicking the open eye will reveal the Redis secret details. 7. Advanced Configuration 7b. Ingress Allow List If the Ingress Allow List is configured, then inbound Web/API traffic will only be permitted to either IPv4 or IPv6 CIDR ranges listed on the Ingress Allow List. 7c. NetBox Configmap ENV This NetBox Configmap ENV allows you to view or manage the underlying variables for the instance 7d. NetBox Startup Configmaps The NetBox Startup Configmaps (redacted screenshot) allows you to view or manage the underlying configmaps for the instance. 8. Pod Info/Logs The Pods screen allows you to view the underlying composition of the instance. This includes versions, operational status, vCPU and Memory information. The refresh button will give you the up-to-date information for all pods. The multi line icon will load the current log for the selected object in each pod.","title":"NetBox Cloud: Administrative Console Overview"},{"location":"Administration%20Console/console-overview/#netbox-cloud-administrative-console-overview","text":"","title":"NetBox Cloud: Administrative Console Overview"},{"location":"Administration%20Console/console-overview/#console-access","text":"To access your NetBox Cloud Administrative Console, follow these steps: Login to the console Click on the arrow next your Organization Name and then click on the Namespace ID Next scroll down and click on the NetBox panel, and then click on the NetBox ID link to launch the Administrative console","title":"Console Access"},{"location":"Administration%20Console/console-overview/#summary-view","text":"This compressed full page screenshot breaks the full Administrative Console down into similar sections. Each section is designed to give you greater insight to your NetBox instance.","title":"Summary View"},{"location":"Administration%20Console/console-overview/#section-breakdown","text":"","title":"Section Breakdown"},{"location":"Administration%20Console/console-overview/#1-information-panel","text":"The Information Panel provides a view of basic information relating to your NetBox Cloud instance. Here you will find the name of your NetBox Cloud instance within your Organization's Namespace, along with the AWS Region and the NetBox version. You also have a link to the instance raw URL, plus a refresh button for the instance data.","title":"1. Information Panel"},{"location":"Administration%20Console/console-overview/#2-netbox-deployment","text":"The NetBox Deployment panel lists various service and configuration status points. Included will be the current version, and version upgrade controls, the number of instance replicas, and resource allocations. The instance image and namespace are also listed here. The left circle icon (stop button) will stop the running NetBox Cloud instance. The center circle icon (play button) will start the NetBox Cloud instance. The right refresh icon will refresh the data in the panel. The Version number with the smaller font displays the current NetBox version The Version drop down lists versions of NetBox that can be changed to. The cloud icon will illuminate if you select a different version of NetBox. The cloud icon will change NetBox to the selected version. The Secrets section provides access to the current secret credentials for the instance API Token, local \u201cadmin\u201d user account and Secret Key. When the Administrative Console initially loads these values will be hidden. Clicking the open eye will reveal the secret details Clicking the closed eye will conceal the secret details Clicking the copy icon will copy the secret to your clipboard","title":"2. NetBox Deployment"},{"location":"Administration%20Console/console-overview/#3-ingress","text":"The Ingress pannel gives the Name, Domain and DNS Name information for the NetBox Cloud instance, as well as the number of Ingress Pods and the Load Balancer status.","title":"3. Ingress"},{"location":"Administration%20Console/console-overview/#4-storage","text":"The Storage Panel contains information on the storage bucket, user, and access key ID. Clicking the open eye will reveal the Access Key secret details.","title":"4. Storage"},{"location":"Administration%20Console/console-overview/#5-postgres","text":"The Postgres Database panel (left) gives the current status of the database, along with details of the host, username and database name for the instance. Clicking the open eye will reveal the Postrges Database secret details. The Postgres panel (right) gives the number of database instances, their status, instance names, version, Aurora capacity unit consumption, current configured backup retention period, and security group IDs. Clicking the open eye will reveal the Postrges secret details.","title":"5. Postgres"},{"location":"Administration%20Console/console-overview/#6-redis","text":"The Redis Database panel (left) gives the name, status, host, user, and ID of the Main and Cache Redis databases. The Redis panel (right) gives the name, status, resource, image and version information for the Redis instance. Clicking the open eye will reveal the Redis secret details.","title":"6. Redis"},{"location":"Administration%20Console/console-overview/#7-advanced-configuration","text":"","title":"7. Advanced Configuration"},{"location":"Administration%20Console/console-overview/#8-pod-infologs","text":"The Pods screen allows you to view the underlying composition of the instance. This includes versions, operational status, vCPU and Memory information. The refresh button will give you the up-to-date information for all pods. The multi line icon will load the current log for the selected object in each pod.","title":"8. Pod Info/Logs"},{"location":"Administration%20Console/free-plan-features/","text":"NetBox Cloud Free Plan Features The NetBox Cloud Free Plan is perfect for small networks, lab environments, and targeted use cases. It includes up to 100 devices, 500 IP addresses, 10k API requests/month, and 2 operational branches. Free Plan Features in Detail The following features are enabled in the NetBox Cloud Free Plan: Devices : 100 IP Addresses : 500 API Requests : 10,000 per month File Upload Size : Maximum 5MB Backup Frequency : Once per day Branching Enabled : Maximum of 2 operational branches Prefix List Entries : Maximum of 10 entries Upgrades : Automatic If you need more, or you need features like advanced SSO, Plugins, Webhooks, Custom Scripts, Custom Hostnames, the ability to work with backups, commercial support, and more, check out our paid plans .","title":"Free Plan Features"},{"location":"Administration%20Console/free-plan-features/#netbox-cloud-free-plan-features","text":"The NetBox Cloud Free Plan is perfect for small networks, lab environments, and targeted use cases. It includes up to 100 devices, 500 IP addresses, 10k API requests/month, and 2 operational branches.","title":"NetBox Cloud Free Plan Features"},{"location":"Administration%20Console/free-plan-features/#free-plan-features-in-detail","text":"The following features are enabled in the NetBox Cloud Free Plan: Devices : 100 IP Addresses : 500 API Requests : 10,000 per month File Upload Size : Maximum 5MB Backup Frequency : Once per day Branching Enabled : Maximum of 2 operational branches Prefix List Entries : Maximum of 10 entries Upgrades : Automatic If you need more, or you need features like advanced SSO, Plugins, Webhooks, Custom Scripts, Custom Hostnames, the ability to work with backups, commercial support, and more, check out our paid plans .","title":"Free Plan Features in Detail"},{"location":"Administration%20Console/managing-hostnames/","text":"Managing NetBox Cloud Hostnames Info Current functionality of the Hostnames Manager is limited to viewing Hostnames along with their associated NetBox Cloud instances and categories. Enhanced functionality to manage Hostnames is coming soon in a future release. From within the NetBox Labs Console click on Settings in the left-hand main menu to manage the settings for your Organization: Click to expand Hostnames Manager From here you can view the Hostnames configured for your organization. Under NetBox you can see which NetBox instance is associated with a given hostname, and what Category the hostname is: Hostname Categories: Hostname categories are defined as follows: Category Definition platform random A randomly generated hostname created when a new NetBox Cloud instance is created, usually as a trial. platform custom A custom hostname on the NetBox cloud platform eg. abcwidgets.cloud.netboxapp.com org custom A custom hostname defined by your organization eg. netbox-prod.abcwidgets.com Organization Custom Hostnames Organization Custom Hostnames are available in NetBox Cloud Professional and Enterprise plans, and if you would like to set one up please raise a support ticket by emailing the NetBox Labs Support Team . Note Organization Custom Hostnames are not available for Starter plans. For more information about pricing plans click here","title":"Managing Hostnames"},{"location":"Administration%20Console/managing-hostnames/#managing-netbox-cloud-hostnames","text":"Info Current functionality of the Hostnames Manager is limited to viewing Hostnames along with their associated NetBox Cloud instances and categories. Enhanced functionality to manage Hostnames is coming soon in a future release. From within the NetBox Labs Console click on Settings in the left-hand main menu to manage the settings for your Organization: Click to expand Hostnames Manager From here you can view the Hostnames configured for your organization. Under NetBox you can see which NetBox instance is associated with a given hostname, and what Category the hostname is:","title":"Managing NetBox Cloud Hostnames"},{"location":"Administration%20Console/managing-hostnames/#hostname-categories","text":"Hostname categories are defined as follows: Category Definition platform random A randomly generated hostname created when a new NetBox Cloud instance is created, usually as a trial. platform custom A custom hostname on the NetBox cloud platform eg. abcwidgets.cloud.netboxapp.com org custom A custom hostname defined by your organization eg. netbox-prod.abcwidgets.com","title":"Hostname Categories:"},{"location":"Administration%20Console/managing-hostnames/#organization-custom-hostnames","text":"Organization Custom Hostnames are available in NetBox Cloud Professional and Enterprise plans, and if you would like to set one up please raise a support ticket by emailing the NetBox Labs Support Team . Note Organization Custom Hostnames are not available for Starter plans. For more information about pricing plans click here","title":"Organization Custom Hostnames"},{"location":"Administration%20Console/netbox-cloud-plugins/","text":"NetBox Cloud Plugins From within the NetBox Labs Console, you can easily view installed NetBox Cloud Plugins , along with their Scope and Version number . Simply follow these steps: From within the NetBox Labs Console click on the three dots in the top right corner of the NetBox Instance panel, and click manage Click on Plugins to view the installed Plugins : View the list of installed Plugins , their scopes and version numbers: Info There are two types of plugin scope - public for any plugins that are publicly available and organization for custom plugins.","title":"NetBox Cloud Plugins"},{"location":"Administration%20Console/netbox-cloud-plugins/#netbox-cloud-plugins","text":"From within the NetBox Labs Console, you can easily view installed NetBox Cloud Plugins , along with their Scope and Version number . Simply follow these steps: From within the NetBox Labs Console click on the three dots in the top right corner of the NetBox Instance panel, and click manage Click on Plugins to view the installed Plugins : View the list of installed Plugins , their scopes and version numbers: Info There are two types of plugin scope - public for any plugins that are publicly available and organization for custom plugins.","title":"NetBox Cloud Plugins"},{"location":"Administration%20Console/okta-group-mapping/","text":"Group Mapping For Okta Single Sign-On (SSO) Upgrade your Single Sign-On experience with Group Mapping for Okta SSO \u2013 a smarter, more secure way to manage user access. The Group Mapping feature for Okta Single Sign-On, streamlines the synchronization of group memberships from Okta to groups in NetBox Cloud, allowing you to align your user access efficiently and accurately. Changes in Okta groups are reflected in NetBox Cloud, ensuring up-to-date access management and enhanced security. You can tailor the group mapping to your organizational needs while maintaining strict security and compliance standards. If you are already securing access to NetBox Cloud using Okta for SSO, and would like use the Group Mapping feature it's easy to get set up. Simply create your groups and permissions in NetBox Cloud, then set up your groups in Okta and reach out to the support team at NetBox Labs and we will take care of the group mappings for you to suit your requirements. \u2139\ufe0f Note This feature is only available in Pro/Enterprise tiers. How it Works Group mappings are based on the name of the group in Okta, which is mapped to a group in NetBox Cloud, and that group could have permissions assigned to it. For example, this group called CircuitManager in NetBox Cloud has permissions assigned to it that allows members of the group to manage all of the Circuit and Provider object types: Optionally, members of the Okta groups can also be members of the NetBox built-in groups Staff which allows access to the NetBox admin interface, and Superuser which has all permissions without explicitly assigning them. The NetBox Labs support team will map your Okta group names to your NetBox Cloud groups, for example: Okta Group Name NetBox Cloud Group Staff Super User NetBox-Circuit-Mgrs Circuit Manager Yes No How Do I Get it Set Up? Simply provide us with your requirements in terms of Okta group names and NetBox groups and we will take care of the rest. If you have any questions about Group Mapping for Okta Sign-On (SSO), please raise a support ticket by emailing the NetBox Labs Support Team .","title":"Okta Group Mapping"},{"location":"Administration%20Console/okta-group-mapping/#group-mapping-for-okta-single-sign-on-sso","text":"Upgrade your Single Sign-On experience with Group Mapping for Okta SSO \u2013 a smarter, more secure way to manage user access. The Group Mapping feature for Okta Single Sign-On, streamlines the synchronization of group memberships from Okta to groups in NetBox Cloud, allowing you to align your user access efficiently and accurately. Changes in Okta groups are reflected in NetBox Cloud, ensuring up-to-date access management and enhanced security. You can tailor the group mapping to your organizational needs while maintaining strict security and compliance standards. If you are already securing access to NetBox Cloud using Okta for SSO, and would like use the Group Mapping feature it's easy to get set up. Simply create your groups and permissions in NetBox Cloud, then set up your groups in Okta and reach out to the support team at NetBox Labs and we will take care of the group mappings for you to suit your requirements. \u2139\ufe0f Note This feature is only available in Pro/Enterprise tiers.","title":"Group Mapping For Okta Single Sign-On (SSO)"},{"location":"Administration%20Console/okta-group-mapping/#how-it-works","text":"Group mappings are based on the name of the group in Okta, which is mapped to a group in NetBox Cloud, and that group could have permissions assigned to it. For example, this group called CircuitManager in NetBox Cloud has permissions assigned to it that allows members of the group to manage all of the Circuit and Provider object types: Optionally, members of the Okta groups can also be members of the NetBox built-in groups Staff which allows access to the NetBox admin interface, and Superuser which has all permissions without explicitly assigning them. The NetBox Labs support team will map your Okta group names to your NetBox Cloud groups, for example: Okta Group Name NetBox Cloud Group Staff Super User NetBox-Circuit-Mgrs Circuit Manager Yes No","title":"How it Works"},{"location":"Administration%20Console/okta-group-mapping/#how-do-i-get-it-set-up","text":"Simply provide us with your requirements in terms of Okta group names and NetBox groups and we will take care of the rest. If you have any questions about Group Mapping for Okta Sign-On (SSO), please raise a support ticket by emailing the NetBox Labs Support Team .","title":"How Do I Get it Set Up?"},{"location":"Administration%20Console/okta-sso-setup/","text":"Okta SSO Setup This guide explains how to configure single sign-on (SSO) support for NetBox Cloud using Okta as an authentication backend. Okta Configuration Note that Okta offers free developer accounts Create a test user (optional) Create a new user in the Okta admin portal to be used for testing. You can skip this step if you already have a suitable account created. Create an app registration Within the Okta administration dashboard, navigate to Applications > Applications, and click the \"Create App Integration\" button. Select \"OIDC\" as the sign-in method, and \"Web application\" for the application type. On the next page, give the app integration a name (e.g. \"NetBox Cloud\") and specify the sign-in and sign-out URIs. These URIs should follow the formats below: Sign-in URI: https://{your-domain}.cloud.netboxapp.com/oauth/complete/okta-openidconnect/ Sign-out URI: https://{your-domain}.cloud.netboxapp.com/oauth/disconnect/okta-openidconnect/ Under \"Assignments,\" select the controlled access setting most appropriate for your organization. Click \"Save\" to complete the creation. Once finished, note the following parameters. These will be used to configured NetBox Cloud. Client ID Client secret Okta domain NetBox Cloud Configuration Securely share the following configuration parameters with NetBox Labs Support , substituting your own values: REMOTE_AUTH_BACKEND = 'social_core.backends.okta_openidconnect.OktaOpenIdConnect' SOCIAL_AUTH_OKTA_OPENIDCONNECT_KEY = '{Client ID}' SOCIAL_AUTH_OKTA_OPENIDCONNECT_SECRET = '{Client secret}' SOCIAL_AUTH_OKTA_OPENIDCONNECT_API_URL = 'https://{Okta domain}/oauth2/' The support team will add these parameters to your NetBox Cloud instance and confirm when this is ready for testing. Testing Log out of NetBox Cloud if already authenticated, and click the \"Log In\" button at top right. You should see the normal login form as well as an option to authenticate using Okta. Click that link. You should be redirected to Okta's authentication portal. Enter the username/email and password of your test account to continue. You may also be prompted to grant this application access to your account. If successful, you will be redirected back to the NetBox Cloud UI, and will be logged in as the Okta user. You can verify this by navigating to your profile (using the button at top right). This user account has been replicated locally to NetBox Cloud, and can now be assigned groups and permissions within the NetBox Cloud admin UI.","title":"Set up Okta SSO"},{"location":"Administration%20Console/okta-sso-setup/#okta-sso-setup","text":"This guide explains how to configure single sign-on (SSO) support for NetBox Cloud using Okta as an authentication backend.","title":"Okta SSO Setup"},{"location":"Administration%20Console/okta-sso-setup/#okta-configuration","text":"Note that Okta offers free developer accounts Create a test user (optional) Create a new user in the Okta admin portal to be used for testing. You can skip this step if you already have a suitable account created. Create an app registration Within the Okta administration dashboard, navigate to Applications > Applications, and click the \"Create App Integration\" button. Select \"OIDC\" as the sign-in method, and \"Web application\" for the application type. On the next page, give the app integration a name (e.g. \"NetBox Cloud\") and specify the sign-in and sign-out URIs. These URIs should follow the formats below: Sign-in URI: https://{your-domain}.cloud.netboxapp.com/oauth/complete/okta-openidconnect/ Sign-out URI: https://{your-domain}.cloud.netboxapp.com/oauth/disconnect/okta-openidconnect/ Under \"Assignments,\" select the controlled access setting most appropriate for your organization. Click \"Save\" to complete the creation. Once finished, note the following parameters. These will be used to configured NetBox Cloud. Client ID Client secret Okta domain","title":"Okta Configuration"},{"location":"Administration%20Console/okta-sso-setup/#netbox-cloud-configuration","text":"Securely share the following configuration parameters with NetBox Labs Support , substituting your own values: REMOTE_AUTH_BACKEND = 'social_core.backends.okta_openidconnect.OktaOpenIdConnect' SOCIAL_AUTH_OKTA_OPENIDCONNECT_KEY = '{Client ID}' SOCIAL_AUTH_OKTA_OPENIDCONNECT_SECRET = '{Client secret}' SOCIAL_AUTH_OKTA_OPENIDCONNECT_API_URL = 'https://{Okta domain}/oauth2/' The support team will add these parameters to your NetBox Cloud instance and confirm when this is ready for testing.","title":"NetBox Cloud Configuration"},{"location":"Administration%20Console/okta-sso-setup/#testing","text":"Log out of NetBox Cloud if already authenticated, and click the \"Log In\" button at top right. You should see the normal login form as well as an option to authenticate using Okta. Click that link. You should be redirected to Okta's authentication portal. Enter the username/email and password of your test account to continue. You may also be prompted to grant this application access to your account. If successful, you will be redirected back to the NetBox Cloud UI, and will be logged in as the Okta user. You can verify this by navigating to your profile (using the button at top right). This user account has been replicated locally to NetBox Cloud, and can now be assigned groups and permissions within the NetBox Cloud admin UI.","title":"Testing"},{"location":"Administration%20Console/prefix-lists/","text":"Prefix Lists You can secure access to your NetBox Cloud instance by adding IPv4 and IPv6 addresses and ranges to Prefix Lists , which can then be applied to NetBox instances to control which source IPs your instances will accept connections from. The following features are available in the NetBox Labs Admin Console when working with prefix lists: Create, Edit and Delete prefix lists Synchronize prefix lists from a NetBox instance using tags There is also large list support (~15K prefixes) and separate prefixes can be applied to the NetBox Cloud UI, API and GraphQL interfaces. Note When you have built your prefix lists in the Admin Console, raise a support ticket by emailing the NetBox Labs Support Team and we will apply them to your NetBox Cloud instances. Watch this quick video or follow the steps outlined below to start managing your prefix lists: Create a Prefix List (not synchronized with a NetBox) From within the Admin Console, navigate to Settings in the left-hand menu Scroll down and click to expand the Prefix List section, and then click on Create Prefix List on the right hand side to start the wizard: Give the prefix list a name and then click CREATE PREFIX LIST : Enter the first prefix and give it a description. If you wish to add additional prefixes then you can also do that here by clicking + ADD ADDITIONAL PREFIX , then when you are happy click CREATE PREFIXES . Note - if you wish to add the IP address that you are currently using then click Use Current IP Address and this will add it to the prefix list: You can then view the prefix list from within Settings > Prefix List : Create a Prefix List (synchronized with a NetBox) From within the Admin Console, navigate to Settings in the left-hand menu Scroll down and click to expand the Prefix List section, and then click on Create Prefix List on the right hand side to start the wizard: Give the prefix list a name and then select the Yes radio button to sync the prefix list from a NetBox. Then select the NetBox instance you wish to sync from, specify the NetBox Tag that you wish to use, and then click CREATE PREFIX LIST : Switch to your NetBox instance, and go to Customization > Tags and create the required tag(s) to be applied to any prefixes that are to be synchronized to the Prefix List: Under IPAM > Prefixes add the prefixes, give them a description and tag them with the appropriate tag: You can then view the prefixes in NetBox under IPAM > Prefixes ( Tip - filter on the tag): Switch back to the Admin Console to view the prefix list from within Settings > Prefix List . Note - it can take a few minutes for the prefix list to be fully synchronized from NetBox. Edit a Prefix List Note - this only works for prefix lists that are not synchronized with a NetBox. To edit NetBox synchronized prefix lists you should make the edits within NetBox. From within the Admin Console, navigate to Settings in the left-hand menu, and then scroll down and click to expand the Prefix List section. Then click on the name of the prefix list you wish to edit: To add more prefixes to the list, click on Create Prefix and then follow the wizard again to add more prefixes. To edit a prefix, click EDIT and then make your required changes and then click EDIT PREFIX to save your changes: To delete a prefix, click DELETE and then if you are sure you wish to delete the prefix, click DELETE PREFIX when prompted: Delete a Prefix List Note - in order for a prefix list to be deleted it must first be detached from any NetBox instances that it is securing. You will need to contact support and request this before you can delete it. From within the Admin Console, navigate to Settings in the left-hand menu, and then scroll down and click to expand the Prefix List section. Then click on the name of the prefix list you wish to delete, and click DELETE PREFIX LIST : If you are sure you wish to delete the prefix list then click DELETE PREFIX LIST when you are prompted to confirm the deletion: If you encounter any issues while working with the IP Allow List raise a support ticket by emailing the NetBox Labs Support Team","title":"Prefix Lists"},{"location":"Administration%20Console/prefix-lists/#prefix-lists","text":"You can secure access to your NetBox Cloud instance by adding IPv4 and IPv6 addresses and ranges to Prefix Lists , which can then be applied to NetBox instances to control which source IPs your instances will accept connections from. The following features are available in the NetBox Labs Admin Console when working with prefix lists: Create, Edit and Delete prefix lists Synchronize prefix lists from a NetBox instance using tags There is also large list support (~15K prefixes) and separate prefixes can be applied to the NetBox Cloud UI, API and GraphQL interfaces. Note When you have built your prefix lists in the Admin Console, raise a support ticket by emailing the NetBox Labs Support Team and we will apply them to your NetBox Cloud instances. Watch this quick video or follow the steps outlined below to start managing your prefix lists:","title":"Prefix Lists"},{"location":"Administration%20Console/prefix-lists/#create-a-prefix-list-not-synchronized-with-a-netbox","text":"From within the Admin Console, navigate to Settings in the left-hand menu Scroll down and click to expand the Prefix List section, and then click on Create Prefix List on the right hand side to start the wizard: Give the prefix list a name and then click CREATE PREFIX LIST : Enter the first prefix and give it a description. If you wish to add additional prefixes then you can also do that here by clicking + ADD ADDITIONAL PREFIX , then when you are happy click CREATE PREFIXES . Note - if you wish to add the IP address that you are currently using then click Use Current IP Address and this will add it to the prefix list: You can then view the prefix list from within Settings > Prefix List :","title":"Create a Prefix List (not synchronized with a NetBox)"},{"location":"Administration%20Console/prefix-lists/#create-a-prefix-list-synchronized-with-a-netbox","text":"From within the Admin Console, navigate to Settings in the left-hand menu Scroll down and click to expand the Prefix List section, and then click on Create Prefix List on the right hand side to start the wizard: Give the prefix list a name and then select the Yes radio button to sync the prefix list from a NetBox. Then select the NetBox instance you wish to sync from, specify the NetBox Tag that you wish to use, and then click CREATE PREFIX LIST : Switch to your NetBox instance, and go to Customization > Tags and create the required tag(s) to be applied to any prefixes that are to be synchronized to the Prefix List: Under IPAM > Prefixes add the prefixes, give them a description and tag them with the appropriate tag: You can then view the prefixes in NetBox under IPAM > Prefixes ( Tip - filter on the tag): Switch back to the Admin Console to view the prefix list from within Settings > Prefix List . Note - it can take a few minutes for the prefix list to be fully synchronized from NetBox.","title":"Create a Prefix List (synchronized with a NetBox)"},{"location":"Administration%20Console/prefix-lists/#edit-a-prefix-list","text":"Note - this only works for prefix lists that are not synchronized with a NetBox. To edit NetBox synchronized prefix lists you should make the edits within NetBox. From within the Admin Console, navigate to Settings in the left-hand menu, and then scroll down and click to expand the Prefix List section. Then click on the name of the prefix list you wish to edit: To add more prefixes to the list, click on Create Prefix and then follow the wizard again to add more prefixes. To edit a prefix, click EDIT and then make your required changes and then click EDIT PREFIX to save your changes: To delete a prefix, click DELETE and then if you are sure you wish to delete the prefix, click DELETE PREFIX when prompted:","title":"Edit a Prefix List"},{"location":"Administration%20Console/prefix-lists/#delete-a-prefix-list","text":"Note - in order for a prefix list to be deleted it must first be detached from any NetBox instances that it is securing. You will need to contact support and request this before you can delete it. From within the Admin Console, navigate to Settings in the left-hand menu, and then scroll down and click to expand the Prefix List section. Then click on the name of the prefix list you wish to delete, and click DELETE PREFIX LIST : If you are sure you wish to delete the prefix list then click DELETE PREFIX LIST when you are prompted to confirm the deletion: If you encounter any issues while working with the IP Allow List raise a support ticket by emailing the NetBox Labs Support Team","title":"Delete a Prefix List"},{"location":"Administration%20Console/public-ip-addressing/","text":"NetBox Cloud Public IP Addresses Traffic Originating From NetBox Cloud The Public IP addresses that outbound traffic from your NetBox Cloud instance (eg. webhooks) will be seen to be originating from are listed below. This will vary depending on the region that your instance is located in. You can whitelist these IP ranges so that inbound access from your NetBox Cloud instance(s) is restricted to just these addresses: US-EAST-1 IPv4 3.225.69.195 3.233.255.24 34.231.51.53 IPv6 2600:1f18:462e:4c00::/56 EU-WEST-1 IPv4 108.128.2.233 3.252.161.89 46.51.185.39 IPv6 2a05:d018:1128:7a00::/56 EU-WEST-2 IPv4 13.42.148.73 18.132.136.73 18.132.221.240 IPv6 2a05:d01c:11e:a800::/56","title":"Public IP Addressing"},{"location":"Administration%20Console/public-ip-addressing/#netbox-cloud-public-ip-addresses","text":"","title":"NetBox Cloud Public IP Addresses"},{"location":"Administration%20Console/public-ip-addressing/#traffic-originating-from-netbox-cloud","text":"The Public IP addresses that outbound traffic from your NetBox Cloud instance (eg. webhooks) will be seen to be originating from are listed below. This will vary depending on the region that your instance is located in. You can whitelist these IP ranges so that inbound access from your NetBox Cloud instance(s) is restricted to just these addresses:","title":"Traffic Originating From NetBox Cloud"},{"location":"Administration%20Console/public-ip-addressing/#us-east-1","text":"IPv4 3.225.69.195 3.233.255.24 34.231.51.53 IPv6 2600:1f18:462e:4c00::/56","title":"US-EAST-1"},{"location":"Administration%20Console/public-ip-addressing/#eu-west-1","text":"IPv4 108.128.2.233 3.252.161.89 46.51.185.39 IPv6 2a05:d018:1128:7a00::/56","title":"EU-WEST-1"},{"location":"Administration%20Console/public-ip-addressing/#eu-west-2","text":"IPv4 13.42.148.73 18.132.136.73 18.132.221.240 IPv6 2a05:d01c:11e:a800::/56","title":"EU-WEST-2"},{"location":"Administration%20Console/retrieving-nbc-credentials/","text":"Retrieving the NetBox Cloud Admin Credentials To log into a NetBox Cloud instance with the admin username and password, you first need to login to the NetBox Labs Console and then retrieve the credentials. Follow these steps: Login to NetBox Labs Console and you will see (and be able to administer) all the NetBox Cloud instances running under your Organization. To retrieve the credentials for the admin user of a NetBox Cloud instance, either click to reveal or copy them from the Credentials section: Then click the on either of the two links to open the URL of the instance in a new browser window: Lastly, login to the NetBox Cloud UI with the username and password you have copied from step 2:","title":"Retrieving NetBox Cloud Admin Credentials"},{"location":"Administration%20Console/retrieving-nbc-credentials/#retrieving-the-netbox-cloud-admin-credentials","text":"To log into a NetBox Cloud instance with the admin username and password, you first need to login to the NetBox Labs Console and then retrieve the credentials. Follow these steps: Login to NetBox Labs Console and you will see (and be able to administer) all the NetBox Cloud instances running under your Organization. To retrieve the credentials for the admin user of a NetBox Cloud instance, either click to reveal or copy them from the Credentials section: Then click the on either of the two links to open the URL of the instance in a new browser window: Lastly, login to the NetBox Cloud UI with the username and password you have copied from step 2:","title":"Retrieving the NetBox Cloud Admin Credentials"},{"location":"Administration%20Console/set_up_2fa/","text":"Setting up Two-Factor Authentication for the Admin Console From within the NetBox Labs Console you can easily enable and disable two-factor authentication (2FA) on a per-user basis. Watch this quick video or follow the steps outlined below: Enable Two-Factor Authentication Login to the NetBox Labs Console and then click on the down arrow (top-right) and select Setup Two-Factor . Follow the on-screen instructions and scan the QR code with your Authenticator App of choice (eg. Google Authenticator): Enter the code from your authenticator app and click confirm : Click on the X in the top-right corner to close the dialog box: Click on the down arrow (top-right) and select Sign Out : Log back into the console with your username and password and then when prompted, enter the TOTP code generated by your authenticator app, and click Confirm Disable Two-Factor Authentication Login to the NetBox Labs Console and then click on the down arrow (top-right) and select Setup Two-Factor . Enter the TOTP Code from your authenticator app and click Disable . In the dialog box, note that Two-factor authentication is now disabled and close the dialog box. If you encounter any issues while working with two-factor authentication, please raise a support ticket by emailing the NetBox Labs Support Team","title":"Set up Two-Factor Authentication"},{"location":"Administration%20Console/set_up_2fa/#setting-up-two-factor-authentication-for-the-admin-console","text":"From within the NetBox Labs Console you can easily enable and disable two-factor authentication (2FA) on a per-user basis. Watch this quick video or follow the steps outlined below:","title":"Setting up Two-Factor Authentication for the Admin Console"},{"location":"Administration%20Console/set_up_2fa/#enable-two-factor-authentication","text":"Login to the NetBox Labs Console and then click on the down arrow (top-right) and select Setup Two-Factor . Follow the on-screen instructions and scan the QR code with your Authenticator App of choice (eg. Google Authenticator): Enter the code from your authenticator app and click confirm : Click on the X in the top-right corner to close the dialog box: Click on the down arrow (top-right) and select Sign Out : Log back into the console with your username and password and then when prompted, enter the TOTP code generated by your authenticator app, and click Confirm","title":"Enable Two-Factor Authentication"},{"location":"Administration%20Console/set_up_2fa/#disable-two-factor-authentication","text":"Login to the NetBox Labs Console and then click on the down arrow (top-right) and select Setup Two-Factor . Enter the TOTP Code from your authenticator app and click Disable . In the dialog box, note that Two-factor authentication is now disabled and close the dialog box. If you encounter any issues while working with two-factor authentication, please raise a support ticket by emailing the NetBox Labs Support Team","title":"Disable Two-Factor Authentication"},{"location":"Administration%20Console/upgrading-nbc/","text":"Upgrading NetBox Cloud To safely and easily upgrade your NetBox Cloud instance without worrying about any Plugin compatibility issues, follow the steps outlined below or watch the video instructions: In the NetBox Labs Console , click on the three dots in the top right corner of the instance you wish to upgrade and click Manage . Note the current NetBox version in this example is 3.5.1. Then click on the down arrow next to Plugins and note any installed plugins and their versions: Next, click on the down arrow next to Version Upgrade : The Safe Upgrade tool will present you with the potential and recommended versions you can upgrade to. You will see the version number, the status, and the whether or not installed plugins are compatible with the target NetBox version, plus a link to the release notes for that version. Note that in this case the NetBox BGP and NetBox Topology Views plugins are at a version that is compatible with NetBox version 3.5.9. All versions higher than this (up to 3.6.6) will require an upgrade to the plugins also, but don't worry the safe upgrade tool will handle all of that for you. Also note that we could upgrade to any of the other potential options, but that the Safe Upgrade tool is recommending an upgrade to version 3.6.6, and if we select this option, both the plugins will be automatically upgraded to compatible versions as part of the upgrade process. Note too that if a plugin is not compatible with a certain NetBox version then you will see a warning like this: In this case you would not be able to upgrade to this version, and the tool will not let you select it. In these cases it can mean that the plugin developer has not yet released an updated version of the plugin that is compatible with that particular version of NetBox. Next, select the version you wish to upgrade to, and in this example we will select the recommended version 3.6.6, and then click on UPGRADE VERSION : Click on Continue if you are sure you want to go ahead with the upgrade: You will then see a dialog box confirming the upgrade is in progress: A few seconds later you will see that your NetBox Cloud upgrade is now complete and you will see the new version number: Finally, if you check Plugins again, you will now see the updated versions of the plugins: If you encounter any issues while performing the upgrades or have any questions, please raise a support ticket by emailing the NetBox Labs Support Team","title":"Upgrade NetBox Cloud"},{"location":"Administration%20Console/upgrading-nbc/#upgrading-netbox-cloud","text":"To safely and easily upgrade your NetBox Cloud instance without worrying about any Plugin compatibility issues, follow the steps outlined below or watch the video instructions: In the NetBox Labs Console , click on the three dots in the top right corner of the instance you wish to upgrade and click Manage . Note the current NetBox version in this example is 3.5.1. Then click on the down arrow next to Plugins and note any installed plugins and their versions: Next, click on the down arrow next to Version Upgrade : The Safe Upgrade tool will present you with the potential and recommended versions you can upgrade to. You will see the version number, the status, and the whether or not installed plugins are compatible with the target NetBox version, plus a link to the release notes for that version. Note that in this case the NetBox BGP and NetBox Topology Views plugins are at a version that is compatible with NetBox version 3.5.9. All versions higher than this (up to 3.6.6) will require an upgrade to the plugins also, but don't worry the safe upgrade tool will handle all of that for you. Also note that we could upgrade to any of the other potential options, but that the Safe Upgrade tool is recommending an upgrade to version 3.6.6, and if we select this option, both the plugins will be automatically upgraded to compatible versions as part of the upgrade process. Note too that if a plugin is not compatible with a certain NetBox version then you will see a warning like this: In this case you would not be able to upgrade to this version, and the tool will not let you select it. In these cases it can mean that the plugin developer has not yet released an updated version of the plugin that is compatible with that particular version of NetBox. Next, select the version you wish to upgrade to, and in this example we will select the recommended version 3.6.6, and then click on UPGRADE VERSION : Click on Continue if you are sure you want to go ahead with the upgrade: You will then see a dialog box confirming the upgrade is in progress: A few seconds later you will see that your NetBox Cloud upgrade is now complete and you will see the new version number: Finally, if you check Plugins again, you will now see the updated versions of the plugins: If you encounter any issues while performing the upgrades or have any questions, please raise a support ticket by emailing the NetBox Labs Support Team","title":"Upgrading NetBox Cloud"},{"location":"Administration%20Console/working_with_database_backups/","text":"Working with NetBox Cloud Database Backups Within the NetBox Labs Console you can access the backups of your NetBox Cloud database, and are able to perform the following actions: View a list of all available database backups Take an 'On Demand' backup at any time Download a local copy of a specific backup file Restore your NetBox Cloud instance from a database backup Watch this quick video or follow the steps outlined below to get started: View a List of Available Database Backups Login to the NetBox Labs Console and then click on the three dots in the top-right corner of the instance you wish to manage and click Manage : Scroll down to the Backup and Restore panel expand it to view the list of available backups: Take an 'On Demand' Database Backup From within the Backup and Restore panel click on Back Up Now , on the right-hand side: Click CONTINUE to confirm that you want to backup of the current version of NetBox Cloud After a short while you will see the On Demand backup you just created appear in the list of available backups: Download a Local Copy of a Backup File Locate the backup file you wish to retrieve, and click on the Download icon: The download will then be prepared: Once the backup file has been prepared it will automatically be downloaded into the Downloads directory on your local computer's file system. Note the file is a gzip compressed archive of the SQL database file so it will end in .sql.gz . Restore From a Database Backup File Identify the database backup you wish to restore from, and click Restore : Click CONTINUE if you are sure you wish to restore the selected backup: The restore process will take place in the background, and depending on the size of the database should take no longer than a few minutes to complete. Once the restore has completed, you can click on See Restore History to view the list of database restores, and you will see your completed restore listed: Your database restore is now complete. Info Once the database restore is complete your NetBox Cloud instance will restart, and you may briefly see a 503 - Service Unavailable message when you browse to the Web interface. This is normal and will clear after a short while, after which you can log in again. Also, please be aware that the NetBox changelog will be empty when you first log in after a database restore. If you encounter any issues while working with database backups raise a support ticket by emailing the NetBox Labs Support Team","title":"Working with Database Backups"},{"location":"Administration%20Console/working_with_database_backups/#working-with-netbox-cloud-database-backups","text":"Within the NetBox Labs Console you can access the backups of your NetBox Cloud database, and are able to perform the following actions: View a list of all available database backups Take an 'On Demand' backup at any time Download a local copy of a specific backup file Restore your NetBox Cloud instance from a database backup Watch this quick video or follow the steps outlined below to get started:","title":"Working with NetBox Cloud Database Backups"},{"location":"Administration%20Console/working_with_database_backups/#view-a-list-of-available-database-backups","text":"Login to the NetBox Labs Console and then click on the three dots in the top-right corner of the instance you wish to manage and click Manage : Scroll down to the Backup and Restore panel expand it to view the list of available backups:","title":"View a List of Available Database Backups"},{"location":"Administration%20Console/working_with_database_backups/#take-an-on-demand-database-backup","text":"From within the Backup and Restore panel click on Back Up Now , on the right-hand side: Click CONTINUE to confirm that you want to backup of the current version of NetBox Cloud After a short while you will see the On Demand backup you just created appear in the list of available backups:","title":"Take an 'On Demand' Database Backup"},{"location":"Administration%20Console/working_with_database_backups/#download-a-local-copy-of-a-backup-file","text":"Locate the backup file you wish to retrieve, and click on the Download icon: The download will then be prepared: Once the backup file has been prepared it will automatically be downloaded into the Downloads directory on your local computer's file system. Note the file is a gzip compressed archive of the SQL database file so it will end in .sql.gz .","title":"Download a Local Copy of a Backup File"},{"location":"Administration%20Console/working_with_database_backups/#restore-from-a-database-backup-file","text":"Identify the database backup you wish to restore from, and click Restore : Click CONTINUE if you are sure you wish to restore the selected backup: The restore process will take place in the background, and depending on the size of the database should take no longer than a few minutes to complete. Once the restore has completed, you can click on See Restore History to view the list of database restores, and you will see your completed restore listed: Your database restore is now complete. Info Once the database restore is complete your NetBox Cloud instance will restart, and you may briefly see a 503 - Service Unavailable message when you browse to the Web interface. This is normal and will clear after a short while, after which you can log in again. Also, please be aware that the NetBox changelog will be empty when you first log in after a database restore. If you encounter any issues while working with database backups raise a support ticket by emailing the NetBox Labs Support Team","title":"Restore From a Database Backup File"},{"location":"NetBox%20Cloud/getting-started-with-nbc/","text":"Getting Started With NetBox Cloud This document will help you get up and running with NetBox Cloud quickly. It highlights all the unique features provided by NetBox Cloud. About NetBox Cloud NetBox Cloud is a managed deployment of the open source NetBox application, extended to improve user experience and maintained by NetBox Labs. NetBox Cloud provides all the power of NetBox without the burden of installation and long-term maintenance. NetBox Cloud Features All the NetBox Cloud features within the user interface (UI) are found under the \"Cloud\" heading of the navigation menu: NetBox Configuration NetBox supports many configuration parameters that affect how it functions. There are two areas of the UI in which these parameters can be adjusted. Administrative Configuration The first area is under the administrative interface. To access this interface, you must be logged into NetBox as a user with administrator privileges. Navigate to the admin UI by expanding the user menu at top right and clicking the \"Admin\" link. Then, navigate to Extras > Config revisions > Add . This form will allow you to set various configuration parameters. Once the desired configurations have been made, you may optionally provide a comment as to why the changes were made, and click the \"Save\" button. This will create a new revision of NetBox's configuration. Configuration changes made via the admin UI take effect immediately. If you would like to revert your changes at any point, you can do so within the admin UI by locating the desired previous revision and clicking the \"Restore\" button to its right. NetBox Cloud Configuration You may notice that some configuration parameters are not present from the configuration form in the admin UI. This is because these are not supported by NetBox as dynamic configuration parameters: They can be modified only by altering NetBox's configuration file. Such settings include: - User authentication (including SSO) - Enabling & configuring plugins - Time & date formatting NetBox Cloud exposes these configuration parameters through its own interface, which can be reached by navigating to Cloud > Administration > Configuration . Once the desired configuration parameters have been set, click the \"Save & Restart\" button. Note that the application of these changes does require a restart of some NetBox Cloud services, and access to the NetBox Cloud UI and API may be interrupted briefly. Single Sign-On (SSO) NetBox Cloud currently supports single sign-on (SSO) authentication for the following providers: Microsoft Azure AD Okta (via OpenID Connect) We are implementing support for additional backends as customers request them. If you have a need for a specific authentication backend, please let us know. To enable SSO, select the desired backend and provide the required configuration parameters under the appropriate tab. For information on configuring your specific backend service, you can consult the SSO configuration guides in the NetBox documentation, or contact NetBox Labs for assistance.","title":"Getting Started With NetBox Cloud"},{"location":"NetBox%20Cloud/getting-started-with-nbc/#getting-started-with-netbox-cloud","text":"This document will help you get up and running with NetBox Cloud quickly. It highlights all the unique features provided by NetBox Cloud.","title":"Getting Started With NetBox Cloud"},{"location":"NetBox%20Cloud/getting-started-with-nbc/#about-netbox-cloud","text":"NetBox Cloud is a managed deployment of the open source NetBox application, extended to improve user experience and maintained by NetBox Labs. NetBox Cloud provides all the power of NetBox without the burden of installation and long-term maintenance.","title":"About NetBox Cloud"},{"location":"NetBox%20Cloud/getting-started-with-nbc/#netbox-cloud-features","text":"All the NetBox Cloud features within the user interface (UI) are found under the \"Cloud\" heading of the navigation menu:","title":"NetBox Cloud Features"},{"location":"NetBox%20Cloud/getting-started-with-nbc/#netbox-configuration","text":"NetBox supports many configuration parameters that affect how it functions. There are two areas of the UI in which these parameters can be adjusted.","title":"NetBox Configuration"},{"location":"NetBox%20Cloud/getting-started-with-nbc/#administrative-configuration","text":"The first area is under the administrative interface. To access this interface, you must be logged into NetBox as a user with administrator privileges. Navigate to the admin UI by expanding the user menu at top right and clicking the \"Admin\" link. Then, navigate to Extras > Config revisions > Add . This form will allow you to set various configuration parameters. Once the desired configurations have been made, you may optionally provide a comment as to why the changes were made, and click the \"Save\" button. This will create a new revision of NetBox's configuration. Configuration changes made via the admin UI take effect immediately. If you would like to revert your changes at any point, you can do so within the admin UI by locating the desired previous revision and clicking the \"Restore\" button to its right.","title":"Administrative Configuration"},{"location":"NetBox%20Cloud/getting-started-with-nbc/#netbox-cloud-configuration","text":"You may notice that some configuration parameters are not present from the configuration form in the admin UI. This is because these are not supported by NetBox as dynamic configuration parameters: They can be modified only by altering NetBox's configuration file. Such settings include: - User authentication (including SSO) - Enabling & configuring plugins - Time & date formatting NetBox Cloud exposes these configuration parameters through its own interface, which can be reached by navigating to Cloud > Administration > Configuration . Once the desired configuration parameters have been set, click the \"Save & Restart\" button. Note that the application of these changes does require a restart of some NetBox Cloud services, and access to the NetBox Cloud UI and API may be interrupted briefly.","title":"NetBox Cloud Configuration"},{"location":"NetBox%20Cloud/getting-started-with-nbc/#single-sign-on-sso","text":"NetBox Cloud currently supports single sign-on (SSO) authentication for the following providers: Microsoft Azure AD Okta (via OpenID Connect) We are implementing support for additional backends as customers request them. If you have a need for a specific authentication backend, please let us know. To enable SSO, select the desired backend and provide the required configuration parameters under the appropriate tab. For information on configuring your specific backend service, you can consult the SSO configuration guides in the NetBox documentation, or contact NetBox Labs for assistance.","title":"Single Sign-On (SSO)"},{"location":"NetBox%20Cloud/migrating-to-netbox-cloud/","text":"Migrating to NetBox Cloud Migrating from an on-premises NetBox open source instance to a NetBox Labs NetBox Cloud environment is a straightforward process. Since NetBox Cloud is built using the same open source software you\u2019re already using, most imports can be completed quickly for a timely cutover. This checklist will walk you through the steps, highlighting mandatory and optional points in the process. 1 - Record your current NetBox version Navigate to your NetBox portal login page to view the version of NetBox you are running. You can also find this information within the application. This helps the NetBox team understand which upgrade path is required for your data. 2 - Export your existing NetBox database Use the following command to export your existing NetBox database: pg_dump --no-owner --no-privileges --username [ netbox ] --password --host [ localhost ] [ netbox ] > [ netbox.sql ] Warning Inform the NetBox Labs team if you used any additional flags for the pg_dump command, or if you exported the data to a different format. 3 - (Optional) Archive your /media directory Optionally, if you are storing images inside NetBox, use the command below to archive your media directory. Note that the example below shows the default file path. Update the path if you have changed the location of these files. tar -czf netbox_media.tar.gz /opt/netbox/netbox/media/ 4 - (Optional) Archive your /scripts directory Optionally, if you have uploaded custom scripts to NetBox, use the command below to archive your scripts directory. Note that the example below shows the default file path. Update the path if you have changed the location of these files. tar -czf netbox_scripts.tar.gz /opt/netbox/netbox/scripts/ 5 - (Optional) Archive your /reports directory Optionally, if you have uploaded custom reports to NetBox, use the command below to archive your reports directory. Note that the example below shows the default file path. Update the path if you have changed the location of these files. tar -czf netbox_scripts.tar.gz /opt/netbox/netbox/reports/ 6 - Upload the files to a shared location Upload the files created in the steps above to a shareable location such as FTP, Dropbox, Box, or Google Drive. If necessary, the NetBox Labs team can create a secure, dedicated location for you to use.","title":"Migrate to NetBox Cloud"},{"location":"NetBox%20Cloud/migrating-to-netbox-cloud/#migrating-to-netbox-cloud","text":"Migrating from an on-premises NetBox open source instance to a NetBox Labs NetBox Cloud environment is a straightforward process. Since NetBox Cloud is built using the same open source software you\u2019re already using, most imports can be completed quickly for a timely cutover. This checklist will walk you through the steps, highlighting mandatory and optional points in the process.","title":"Migrating to NetBox Cloud"},{"location":"NetBox%20Cloud/migrating-to-netbox-cloud/#1-record-your-current-netbox-version","text":"Navigate to your NetBox portal login page to view the version of NetBox you are running. You can also find this information within the application. This helps the NetBox team understand which upgrade path is required for your data.","title":"1 - Record your current NetBox version"},{"location":"NetBox%20Cloud/migrating-to-netbox-cloud/#2-export-your-existing-netbox-database","text":"Use the following command to export your existing NetBox database: pg_dump --no-owner --no-privileges --username [ netbox ] --password --host [ localhost ] [ netbox ] > [ netbox.sql ] Warning Inform the NetBox Labs team if you used any additional flags for the pg_dump command, or if you exported the data to a different format.","title":"2 - Export your existing NetBox database"},{"location":"NetBox%20Cloud/migrating-to-netbox-cloud/#3-optional-archive-your-media-directory","text":"Optionally, if you are storing images inside NetBox, use the command below to archive your media directory. Note that the example below shows the default file path. Update the path if you have changed the location of these files. tar -czf netbox_media.tar.gz /opt/netbox/netbox/media/","title":"3 - (Optional) Archive your /media directory"},{"location":"NetBox%20Cloud/migrating-to-netbox-cloud/#4-optional-archive-your-scripts-directory","text":"Optionally, if you have uploaded custom scripts to NetBox, use the command below to archive your scripts directory. Note that the example below shows the default file path. Update the path if you have changed the location of these files. tar -czf netbox_scripts.tar.gz /opt/netbox/netbox/scripts/","title":"4 - (Optional) Archive your /scripts directory"},{"location":"NetBox%20Cloud/migrating-to-netbox-cloud/#5-optional-archive-your-reports-directory","text":"Optionally, if you have uploaded custom reports to NetBox, use the command below to archive your reports directory. Note that the example below shows the default file path. Update the path if you have changed the location of these files. tar -czf netbox_scripts.tar.gz /opt/netbox/netbox/reports/","title":"5 - (Optional) Archive your /reports directory"},{"location":"NetBox%20Cloud/migrating-to-netbox-cloud/#6-upload-the-files-to-a-shared-location","text":"Upload the files created in the steps above to a shareable location such as FTP, Dropbox, Box, or Google Drive. If necessary, the NetBox Labs team can create a secure, dedicated location for you to use.","title":"6 - Upload the files to a shared location"},{"location":"cloud-connectivity/aws-direct-connect-multi-region-setup/","text":"Coming Soon","title":"Aws direct connect multi region setup"},{"location":"cloud-connectivity/aws-direct-connect-multi-region-setup/#coming-soon","text":"","title":"Coming Soon"},{"location":"cloud-connectivity/aws-direct-connect-multi-region/","text":"Delivery via AWS Direct Connect in two regions, with replicated NetBoxes, Single (or Dual) Direct Connect in each region. Customer IP space (2 x /25's) is assigned for the VPCs. This is to host load balancers and proxies within the dedicated customer Account/VPC. Internally we will allocate a /27 per availability zone for each of the 3 availability zones. The connections do not have to be dedicated, a VLAN can be added to an existing layer 2 fabric provider, such as Equinix Fabric. In terms of bandwidth requirements, 50Mbps is fine.","title":"AWS Direct Connect (Multi-Region)"},{"location":"cloud-connectivity/aws-direct-connect-setup/","text":"Coming Soon","title":"Aws direct connect setup"},{"location":"cloud-connectivity/aws-direct-connect-setup/#coming-soon","text":"","title":"Coming Soon"},{"location":"cloud-connectivity/aws-direct-connect/","text":"AWS Direct Connect is available via hosted connections from BT, Equinix Fabric, MegaPort, Optus, PCCW, Zayo etc. VLAN hand-off is with BGP and Single or Dual Direct Connect services are available. Customer IP space (/24 or /25) is assigned for the VPC, as this is required to host load balancers and proxies within the dedicated customer Account/VPC. Internally we will allocate a /27 per availability zone for each of the 3 availability zones. The connection does not have to be dedicated, a VLAN can be added to an existing layer 2 fabric provider, such as Equinix Fabric. In terms of bandwidth requirements, 50Mbps is fine.","title":"AWS Direct Connect (Single Region)"},{"location":"cloud-connectivity/aws-private-link-setup/","text":"Coming Soon","title":"Aws private link setup"},{"location":"cloud-connectivity/aws-private-link-setup/#coming-soon","text":"","title":"Coming Soon"},{"location":"cloud-connectivity/aws-private-link/","text":"Delivery via Private Link between a customer\u2019s existing AWS account and the NetBox Labs AWS account, with VPC endpoints using private IPs. This option has fast turn-up times and standard Internet delivery can optionally be disabled.","title":"AWS Private Link (Single Region)"},{"location":"cloud-connectivity/cloud-connectivity-faq/","text":"IPSEC VPN Tunnels Q. Why 2 tunnels? A. The AWS VPN Gateway product provides 2 tunnels by default for resilience. Each terminates in a different availability zone. IPSEC VPN Tunnels + Direct Connect Q. Why /24 or /25? A. This is to host load balancers and proxies within the dedicated customer Account/VPC. Internally we will allocate a /27 per availability zone for each of the 3 availability zones. Direct Connect Q. Does the connection have to be dedicated? A. No, a VLAN can be added to an existing layer 2 fabric provider, such as Equinix Fabric. Q. How much bandwidth for hosted connections? A. 50Mbps is fine.","title":"Frequently Asked Questions"},{"location":"cloud-connectivity/cloud-connectivity-faq/#ipsec-vpn-tunnels","text":"Q. Why 2 tunnels? A. The AWS VPN Gateway product provides 2 tunnels by default for resilience. Each terminates in a different availability zone.","title":"IPSEC VPN Tunnels"},{"location":"cloud-connectivity/cloud-connectivity-faq/#ipsec-vpn-tunnels-direct-connect","text":"Q. Why /24 or /25? A. This is to host load balancers and proxies within the dedicated customer Account/VPC. Internally we will allocate a /27 per availability zone for each of the 3 availability zones.","title":"IPSEC VPN Tunnels + Direct Connect"},{"location":"cloud-connectivity/cloud-connectivity-faq/#direct-connect","text":"Q. Does the connection have to be dedicated? A. No, a VLAN can be added to an existing layer 2 fabric provider, such as Equinix Fabric. Q. How much bandwidth for hosted connections? A. 50Mbps is fine.","title":"Direct Connect"},{"location":"cloud-connectivity/do-i-need-cloud-connectivity/","text":"Internet Delivery (Single Region) is the standard product offering for NetBox Cloud. It comes with extensive security features (see below) and is suitable for the majority of use cases and environments. If you have special connectivity needs, there are several options available. However, in many cases where cloud connectivity options seem necessary, NetBox Cloud offers features that can address your needs without additional setup cost. This guide explores some of those features. NetBox Cloud Security Features Security and convenience are always in focus in the NetBox Cloud Platform and we understand that with any application, getting the balance right between security and convenience is crucial. At NetBox Labs, we believe that you shouldn\u2019t have to compromise in either area. Just a few of the Security features the NetBox Cloud platform offers are: Securing Access with Prefix Lists mTLS and Dedicated IP Addresses Database Backup and Restore Safe Upgrade Tool Two-Factor Authentication for the NetBox Labs Admin Console SSO Options for NetBox Cloud Read more about all of these features in this blog or watch an on-demand webinar to learn how these NetBox Cloud features are designed to make the lives of the network team easier, whilst at the same time enhancing the security of NetBox Cloud. CRUD (Create/Update/Delete) Access to the NetBox Data Model via REST and GraphQL API Out of the box NetBox Cloud allows you to programmatically interact with the NetBox Database to perform CRUD operations. This can be via the REST API or GraphQL interface. REST API REST stands for Representational State Transfer . It's a particular type of API which employs HTTP requests and JavaScript Object Notation (JSON) to facilitate create, retrieve, update, and delete (CRUD) operations on objects within an application. Info To read more about how to get started with the REST API, check out the NetBox docs or this video from the NetBox Zero to Hero training course. GraphQL API NetBox provides a read-only GraphQL API to complement its REST API. This API is powered by Strawberry Django . GraphQL enables the client to specify an arbitrary nested list of fields to include in the response. All queries are made to the root /graphql API endpoint. Info To read more about how to get started with the GraphQL API, check out the NetBox docs . Streaming Change Events with Webhooks and Event Streams Events in NetBox can trigger calls to other systems with Webhooks, or other systems can subscribe to Event Streams, and in either case this can trigger other systems to take action based on the event. NetBox Webhooks NetBox can be configured via Event Rules to transmit outgoing webhooks to remote systems in response to internal object changes. The receiver can act on the data in these webhook messages to perform related tasks. For example, suppose you want to automatically configure a monitoring system to start monitoring a device when its operational status is changed to active, and remove it from monitoring for any other status. You can create a webhook in NetBox for the device model and craft its content and destination URL to effect the desired change on the receiving system. Webhooks will be sent automatically by NetBox whenever the configured constraints are met. Info To read more about how to get started with the Webhooks, check out the NetBox docs . NetBox Event Streams NetBox Event Streams unlock event-driven architectures by enabling teams to easily subscribe to network state and management events from the NetBox Cloud Platform, feeding events to other systems or triggering automations. This capability spans various types of events, from operational updates like the addition of new devices, to security-oriented alerts such as unauthorized access attempts. Info To learn more about NetBox Event Streams you can sign up for an on-demand webinar or read our blog about how NetBox Event Streams integrated with SIEM tools like Splunk Enterprise and ElasticSearch, is setting a new standard for how networks are managed and secured.","title":"Do I Need Cloud Connectivity Options?"},{"location":"cloud-connectivity/do-i-need-cloud-connectivity/#netbox-cloud-security-features","text":"Security and convenience are always in focus in the NetBox Cloud Platform and we understand that with any application, getting the balance right between security and convenience is crucial. At NetBox Labs, we believe that you shouldn\u2019t have to compromise in either area. Just a few of the Security features the NetBox Cloud platform offers are: Securing Access with Prefix Lists mTLS and Dedicated IP Addresses Database Backup and Restore Safe Upgrade Tool Two-Factor Authentication for the NetBox Labs Admin Console SSO Options for NetBox Cloud Read more about all of these features in this blog or watch an on-demand webinar to learn how these NetBox Cloud features are designed to make the lives of the network team easier, whilst at the same time enhancing the security of NetBox Cloud.","title":"NetBox Cloud Security Features"},{"location":"cloud-connectivity/do-i-need-cloud-connectivity/#crud-createupdatedelete-access-to-the-netbox-data-model-via-rest-and-graphql-api","text":"Out of the box NetBox Cloud allows you to programmatically interact with the NetBox Database to perform CRUD operations. This can be via the REST API or GraphQL interface.","title":"CRUD (Create/Update/Delete) Access to the NetBox Data Model via REST and GraphQL API"},{"location":"cloud-connectivity/do-i-need-cloud-connectivity/#rest-api","text":"REST stands for Representational State Transfer . It's a particular type of API which employs HTTP requests and JavaScript Object Notation (JSON) to facilitate create, retrieve, update, and delete (CRUD) operations on objects within an application. Info To read more about how to get started with the REST API, check out the NetBox docs or this video from the NetBox Zero to Hero training course.","title":"REST API"},{"location":"cloud-connectivity/do-i-need-cloud-connectivity/#graphql-api","text":"NetBox provides a read-only GraphQL API to complement its REST API. This API is powered by Strawberry Django . GraphQL enables the client to specify an arbitrary nested list of fields to include in the response. All queries are made to the root /graphql API endpoint. Info To read more about how to get started with the GraphQL API, check out the NetBox docs .","title":"GraphQL API"},{"location":"cloud-connectivity/do-i-need-cloud-connectivity/#streaming-change-events-with-webhooks-and-event-streams","text":"Events in NetBox can trigger calls to other systems with Webhooks, or other systems can subscribe to Event Streams, and in either case this can trigger other systems to take action based on the event.","title":"Streaming Change Events with Webhooks and Event Streams"},{"location":"cloud-connectivity/do-i-need-cloud-connectivity/#netbox-webhooks","text":"NetBox can be configured via Event Rules to transmit outgoing webhooks to remote systems in response to internal object changes. The receiver can act on the data in these webhook messages to perform related tasks. For example, suppose you want to automatically configure a monitoring system to start monitoring a device when its operational status is changed to active, and remove it from monitoring for any other status. You can create a webhook in NetBox for the device model and craft its content and destination URL to effect the desired change on the receiving system. Webhooks will be sent automatically by NetBox whenever the configured constraints are met. Info To read more about how to get started with the Webhooks, check out the NetBox docs .","title":"NetBox Webhooks"},{"location":"cloud-connectivity/do-i-need-cloud-connectivity/#netbox-event-streams","text":"NetBox Event Streams unlock event-driven architectures by enabling teams to easily subscribe to network state and management events from the NetBox Cloud Platform, feeding events to other systems or triggering automations. This capability spans various types of events, from operational updates like the addition of new devices, to security-oriented alerts such as unauthorized access attempts. Info To learn more about NetBox Event Streams you can sign up for an on-demand webinar or read our blog about how NetBox Event Streams integrated with SIEM tools like Splunk Enterprise and ElasticSearch, is setting a new standard for how networks are managed and secured.","title":"NetBox Event Streams"},{"location":"cloud-connectivity/internet-delivery/","text":"Internet Delivery (Single Region) is the standard product offering for NetBox Cloud. It comes with extensive security features (see below) and is suitable for the majority of use cases and environments: NetBox Cloud Security Features Below are just a few of the Security features available on the NetBox Cloud platform. All of these can be enabled over our standard Internet Delivery option: Securing Access with Prefix Lists mTLS and Dedicated IP Addresses Database Backup and Restore Safe Upgrade Tool Two-Factor Authentication for the NetBox Labs Admin Console SSO Options for NetBox Cloud Info Read more about all of these features in this blog or watch an on-demand webinar to learn how these NetBox Cloud features are designed to make the lives of the network team easier, whilst at the same time enhancing the security of NetBox Cloud.","title":"Internet Delivery (Single Region)"},{"location":"cloud-connectivity/internet-delivery/#netbox-cloud-security-features","text":"Below are just a few of the Security features available on the NetBox Cloud platform. All of these can be enabled over our standard Internet Delivery option: Securing Access with Prefix Lists mTLS and Dedicated IP Addresses Database Backup and Restore Safe Upgrade Tool Two-Factor Authentication for the NetBox Labs Admin Console SSO Options for NetBox Cloud Info Read more about all of these features in this blog or watch an on-demand webinar to learn how these NetBox Cloud features are designed to make the lives of the network team easier, whilst at the same time enhancing the security of NetBox Cloud.","title":"NetBox Cloud Security Features"},{"location":"cloud-connectivity/ipsec-vpn-tunnels-setup/","text":"Coming Soon","title":"Ipsec vpn tunnels setup"},{"location":"cloud-connectivity/ipsec-vpn-tunnels-setup/#coming-soon","text":"","title":"Coming Soon"},{"location":"cloud-connectivity/ipsec-vpn-tunnels/","text":"In this solution NetBox Cloud is securely delivered over an IPSEC VPN. You have single or dual tunnel options, and use a static route or the preferred option of BGP routing. Customer IP space (/24 or /25) is assigned for the VPC as this is required to host load balancers and proxies within the dedicated customer Account/VPC. Internally we will allocate a /27 per availability zone for each of the 3 availability zones. The AWS VPN Gateway product provides 2 tunnels by default for resilience, and each terminates in a different availability zone. Redundancy options With the IPSEC VPN solution there are options for Single, Active/Passive and Active/Active Firewalls:","title":"IPSEC VPN Tunnels (Single Region)"},{"location":"cloud-connectivity/ipsec-vpn-tunnels/#redundancy-options","text":"With the IPSEC VPN solution there are options for Single, Active/Passive and Active/Active Firewalls:","title":"Redundancy options"},{"location":"cloud-connectivity/which-connectivity-option/","text":"In many cases where cloud connectivity options seem necessary, NetBox Cloud offers features that can address your needs without additional setup. In the majority of cases Internet Delivery (Single Region) is the most appropriate connectivity option, but there are some general recommendations depending on your use case: Recommendations By Use Case Use Case Recommendation Reason General Use Internet Delivery (Single Region) Standard product, easy setup, and sufficient security for most use cases. AWS-Centric Environments AWS Private Link (Single Region) Fast setup, private IPs, and good integration with AWS infrastructure. Secure, Site-to-Site Connections IPSEC VPN Tunnels (Single Region) High flexibility and security with VPN tunnels and routing options. High-Performance Needs (Single Region) AWS Direct Connect (Single Region) Low latency, high performance, suitable for demanding applications. High-Performance, Multi-Region Needs AWS Direct Connect (Multi-Region) Highest performance, redundancy, and scalability across multiple regions. Detailed Breakdown This matrix should help you identify the most suitable NetBox Cloud connectivity option based on your specific requirements and priorities: Criteria Internet Delivery (Single Region) AWS Private Link (Single Region) IPSEC VPN Tunnels (Single Region) AWS Direct Connect (Single Region) AWS Direct Connect (Multi-Region) Ease of Setup Standard product, easy setup Fast turn-up times Requires VPN configuration Requires Direct Connect setup Requires Direct Connect setup Redundancy Single region. Multiple AZs Single region. Multiple AZs Single region. Multiple AZs. Single or dual tunnels Single region. Multiple AZs. Single or dual Direct Connect options Multi Region. Multiple AZs. Replicated NetBoxes Cost Included Low, due to Private Link Medium, dependent on VPN set up Medium, due to Direct Connect Highest, due to multi-region setup Performance Standard internet performance Low latency due to Private Link Variable, dependent on VPN quality High performance, low latency Highest performance, low latency Management Complexity Low Medium High Medium High Recommended For General use AWS-centric environments Secure, site-to-site connections High-performance needs, single region High-performance, multi-region needs","title":"Which Cloud Connectivity Option is Right for Me?"},{"location":"cloud-connectivity/which-connectivity-option/#recommendations-by-use-case","text":"Use Case Recommendation Reason General Use Internet Delivery (Single Region) Standard product, easy setup, and sufficient security for most use cases. AWS-Centric Environments AWS Private Link (Single Region) Fast setup, private IPs, and good integration with AWS infrastructure. Secure, Site-to-Site Connections IPSEC VPN Tunnels (Single Region) High flexibility and security with VPN tunnels and routing options. High-Performance Needs (Single Region) AWS Direct Connect (Single Region) Low latency, high performance, suitable for demanding applications. High-Performance, Multi-Region Needs AWS Direct Connect (Multi-Region) Highest performance, redundancy, and scalability across multiple regions.","title":"Recommendations By Use Case"},{"location":"cloud-connectivity/which-connectivity-option/#detailed-breakdown","text":"This matrix should help you identify the most suitable NetBox Cloud connectivity option based on your specific requirements and priorities: Criteria Internet Delivery (Single Region) AWS Private Link (Single Region) IPSEC VPN Tunnels (Single Region) AWS Direct Connect (Single Region) AWS Direct Connect (Multi-Region) Ease of Setup Standard product, easy setup Fast turn-up times Requires VPN configuration Requires Direct Connect setup Requires Direct Connect setup Redundancy Single region. Multiple AZs Single region. Multiple AZs Single region. Multiple AZs. Single or dual tunnels Single region. Multiple AZs. Single or dual Direct Connect options Multi Region. Multiple AZs. Replicated NetBoxes Cost Included Low, due to Private Link Medium, dependent on VPN set up Medium, due to Direct Connect Highest, due to multi-region setup Performance Standard internet performance Low latency due to Private Link Variable, dependent on VPN quality High performance, low latency Highest performance, low latency Management Complexity Low Medium High Medium High Recommended For General use AWS-centric environments Secure, site-to-site connections High-performance needs, single region High-performance, multi-region needs","title":"Detailed Breakdown"},{"location":"netbox-assurance/","text":"NetBox Cloud NetBox Enterprise Coming early 2025 Be among the first to experience NetBox Assurance . Sign up to be notified when we launch. NetBox Assurance empowers organizations to continuously detect and address network drift by identifying deviations between the intended state in NetBox and the actual state of the network. It extends NetBox with automated deviation detection and corrective actions, helping teams maintain a consistent and reliable network infrastructure. Key Features Deviation Detection : Identify configuration drift between NetBox and the network. Efficient Remediation : Correct detected deviations through guided workflows. Seamless Integration : Enhance NetBox with continuous network validation and state synchronization. Detailed Reports : Generate actionable reports highlighting network consistency and detected deviations. How It Works NetBox Assurance continuously compares the documented or intended network state stored in NetBox with the observed network state being provided by NetBox Discovery and other network data sources. When deviations are detected, workflows allow effecient remediation of deviations by updating NetBox or by taking corrective actions on the network. Use Cases Network Drift Detection : Ensure network configurations remain consistent with the source of truth. Compliance Audits : Support compliance efforts by detecting unauthorized changes. Incident Prevention : Identify and address deviations before they cause major disruptions. Support and Resources Documentation : Until NetBox Assurance is officially released, please refer to the Diode project documentation. Community Support : Connect with the community on Slack in the #netbox channel. With NetBox Assurance , teams can detect, report, and resolve network deviations in real time, ensuring a consistent and reliable network environment through continuous validation and corrective actions.","title":"NetBox Assurance"},{"location":"netbox-assurance/#key-features","text":"Deviation Detection : Identify configuration drift between NetBox and the network. Efficient Remediation : Correct detected deviations through guided workflows. Seamless Integration : Enhance NetBox with continuous network validation and state synchronization. Detailed Reports : Generate actionable reports highlighting network consistency and detected deviations.","title":"Key Features"},{"location":"netbox-assurance/#how-it-works","text":"NetBox Assurance continuously compares the documented or intended network state stored in NetBox with the observed network state being provided by NetBox Discovery and other network data sources. When deviations are detected, workflows allow effecient remediation of deviations by updating NetBox or by taking corrective actions on the network.","title":"How It Works"},{"location":"netbox-assurance/#use-cases","text":"Network Drift Detection : Ensure network configurations remain consistent with the source of truth. Compliance Audits : Support compliance efforts by detecting unauthorized changes. Incident Prevention : Identify and address deviations before they cause major disruptions.","title":"Use Cases"},{"location":"netbox-assurance/#support-and-resources","text":"Documentation : Until NetBox Assurance is officially released, please refer to the Diode project documentation. Community Support : Connect with the community on Slack in the #netbox channel. With NetBox Assurance , teams can detect, report, and resolve network deviations in real time, ensuring a consistent and reliable network environment through continuous validation and corrective actions.","title":"Support and Resources"},{"location":"netbox-discovery/","text":"NetBox Cloud NetBox Enterprise NetBox Community Public Preview NetBox Discovery is currently in Public Preview. Please refer to NetBox Labs Product and Feature Lifecycle to get more details. We actively welcome feedback to help identify and prioritize bugs, new features and areas of improvement. NetBox Discovery is an advanced network discovery tool designed to simplify documenting your network and help detect network drift. It extends NetBox by providing automated network and device discovery capabilities. Key Features Automated Network Discovery : Schedule scans and identify devices and assets across your network. Seamless Integration : Fully integrated with NetBox through Diode (and soon NetBox Assurance), helping you detect network drift. Customizable Policies : Define custom discovery policies tailored to specific network environments. Extensible and Scalable : Open source, lightweight discovery agent is built to scale with enterprise environments and support various network protocols. How It Works NetBox Discovery leverages network protocols (such as SSH, ICMP, UDP, TCP) to discover devices and other network assets. Discovered data is sent to Diode (and soon NetBox Assurance) to be matched and reconciled with NetBox to identify drift and deviations. The NetBox database can be updated where relevant, ensuring data accuracy and reducing manual entry. Use Cases Data Center Infrastructure Management : Keep track of routers, switches, and other network devices. Network Asset Management : Maintain an up-to-date inventory of network assets. Network Audits : Perform network audits for compliance and troubleshooting. Support and Resources Documentation : Get started with the NetBox Discovery agent documentation . GitHub Repository : Find the NetBox Discovery agent here . Community Support : Connect with the community on Slack in the #netbox channel. By leveraging NetBox Discovery , organizations can enhance their network visibility, streamline IT operations, and maintain an accurate source of truth for their network infrastructure.","title":"NetBox Discovery"},{"location":"netbox-discovery/#key-features","text":"Automated Network Discovery : Schedule scans and identify devices and assets across your network. Seamless Integration : Fully integrated with NetBox through Diode (and soon NetBox Assurance), helping you detect network drift. Customizable Policies : Define custom discovery policies tailored to specific network environments. Extensible and Scalable : Open source, lightweight discovery agent is built to scale with enterprise environments and support various network protocols.","title":"Key Features"},{"location":"netbox-discovery/#how-it-works","text":"NetBox Discovery leverages network protocols (such as SSH, ICMP, UDP, TCP) to discover devices and other network assets. Discovered data is sent to Diode (and soon NetBox Assurance) to be matched and reconciled with NetBox to identify drift and deviations. The NetBox database can be updated where relevant, ensuring data accuracy and reducing manual entry.","title":"How It Works"},{"location":"netbox-discovery/#use-cases","text":"Data Center Infrastructure Management : Keep track of routers, switches, and other network devices. Network Asset Management : Maintain an up-to-date inventory of network assets. Network Audits : Perform network audits for compliance and troubleshooting.","title":"Use Cases"},{"location":"netbox-discovery/#support-and-resources","text":"Documentation : Get started with the NetBox Discovery agent documentation . GitHub Repository : Find the NetBox Discovery agent here . Community Support : Connect with the community on Slack in the #netbox channel. By leveraging NetBox Discovery , organizations can enhance their network visibility, streamline IT operations, and maintain an accurate source of truth for their network infrastructure.","title":"Support and Resources"},{"location":"netbox-discovery/agent/","text":"NetBox Discovery agent NetBox Cloud NetBox Enterprise NetBox Community The NetBox Discovery agent is based on the Orb open source project. Orb agent is one component of the NetBox Discovery solution and provides network discovery and observability capabilities. Resources Documentation : Get started with the NetBox Discovery agent here . GitHub Repository : Find the NetBox Discovery agent here . Community Support : Connect with the community on Slack in the #netbox channel. Requirements To get started with the NetBox Discovery agent, you'll need the following: NetBox : a running instance of NetBox . Diode plugin : NetBox Diode plugin installed in your NetBox instance. Diode : a running instance of Diode .","title":"Overview"},{"location":"netbox-discovery/agent/#netbox-discovery-agent","text":"NetBox Cloud NetBox Enterprise NetBox Community The NetBox Discovery agent is based on the Orb open source project. Orb agent is one component of the NetBox Discovery solution and provides network discovery and observability capabilities.","title":"NetBox Discovery agent"},{"location":"netbox-discovery/agent/#resources","text":"Documentation : Get started with the NetBox Discovery agent here . GitHub Repository : Find the NetBox Discovery agent here . Community Support : Connect with the community on Slack in the #netbox channel.","title":"Resources"},{"location":"netbox-discovery/agent/#requirements","text":"To get started with the NetBox Discovery agent, you'll need the following: NetBox : a running instance of NetBox . Diode plugin : NetBox Diode plugin installed in your NetBox instance. Diode : a running instance of Diode .","title":"Requirements"},{"location":"netbox-discovery/agent/config_samples/","text":"Configuration Samples NetBox Cloud NetBox Enterprise NetBox Community Here is a collection of configuration samples supported by orb agent Device-discovery backend This sample configuration file demonstrates the device discovery backend connecting to a Cisco router at 192.168.0.5. It retrieves device, interface, and IP information, then sends the data to a diode server running at 192.168.0.100. orb : config_manager : active : local backends : device_discovery : common : diode : target : grpc://192.168.0.100:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent01 policies : device_discovery : discovery_1 : config : schedule : \"* * * * *\" defaults : site : New York NY scope : - driver : ios hostname : 192.168.0.5 username : admin password : ${PASS} Run command: docker run -v /local/orb:/opt/orb/ \\ -e DIODE_API_KEY ={ YOUR_API_KEY } \\ -e PASS ={ DEVICE_PASSWORD } \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml Custom Drivers To specify community or custom NAPALM drivers, use the environment variable INSTALL_DRIVERS_PATH . Ensure that the required files are placed in the mounted volume ( /opt/orb ). Mounted folder example: /local/orb/ \u251c\u2500\u2500 agent.yaml \u251c\u2500\u2500 drivers.txt \u251c\u2500\u2500 napalm-mos/ \u2514\u2500\u2500 napalm-ros-0.3.2.tar.gz Example drivers.txt : napalm-sros==1.0.2 # try install from pypi napalm-ros-0.3.2.tar.gz # try install from a tar.gz ./napalm-mos # try to install from a folder that contains project.toml Run command: docker run -v /local/orb:/opt/orb/ \\ -e DIODE_API_KEY ={ YOUR_API_KEY } \\ -e PASS ={ DEVICE_PASSWORD } \\ -e INSTALL_DRIVERS_PATH = /opt/orb/drivers.txt \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml The relative path used by pip install should point to the directory containing the .txt file. Network-discovery backend orb : config_manager : active : local backends : network_discovery : common : diode : target : grpc://192.168.31.114:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent02 policies : network_discovery : policy_1 : config : schedule : \"0 */2 * * *\" timeout : 5 scope : targets : [ 192.168.1.1/22 , google.com ] Run command: docker run -v /local/orb:/opt/orb/ \\ -e DIODE_API_KEY ={ YOUR_API_KEY } \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml","title":"Configuration Samples"},{"location":"netbox-discovery/agent/config_samples/#configuration-samples","text":"NetBox Cloud NetBox Enterprise NetBox Community Here is a collection of configuration samples supported by orb agent","title":"Configuration Samples"},{"location":"netbox-discovery/agent/config_samples/#device-discovery-backend","text":"This sample configuration file demonstrates the device discovery backend connecting to a Cisco router at 192.168.0.5. It retrieves device, interface, and IP information, then sends the data to a diode server running at 192.168.0.100. orb : config_manager : active : local backends : device_discovery : common : diode : target : grpc://192.168.0.100:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent01 policies : device_discovery : discovery_1 : config : schedule : \"* * * * *\" defaults : site : New York NY scope : - driver : ios hostname : 192.168.0.5 username : admin password : ${PASS} Run command: docker run -v /local/orb:/opt/orb/ \\ -e DIODE_API_KEY ={ YOUR_API_KEY } \\ -e PASS ={ DEVICE_PASSWORD } \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml","title":"Device-discovery backend"},{"location":"netbox-discovery/agent/config_samples/#custom-drivers","text":"To specify community or custom NAPALM drivers, use the environment variable INSTALL_DRIVERS_PATH . Ensure that the required files are placed in the mounted volume ( /opt/orb ). Mounted folder example: /local/orb/ \u251c\u2500\u2500 agent.yaml \u251c\u2500\u2500 drivers.txt \u251c\u2500\u2500 napalm-mos/ \u2514\u2500\u2500 napalm-ros-0.3.2.tar.gz Example drivers.txt : napalm-sros==1.0.2 # try install from pypi napalm-ros-0.3.2.tar.gz # try install from a tar.gz ./napalm-mos # try to install from a folder that contains project.toml Run command: docker run -v /local/orb:/opt/orb/ \\ -e DIODE_API_KEY ={ YOUR_API_KEY } \\ -e PASS ={ DEVICE_PASSWORD } \\ -e INSTALL_DRIVERS_PATH = /opt/orb/drivers.txt \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml The relative path used by pip install should point to the directory containing the .txt file.","title":"Custom Drivers"},{"location":"netbox-discovery/agent/config_samples/#network-discovery-backend","text":"orb : config_manager : active : local backends : network_discovery : common : diode : target : grpc://192.168.31.114:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent02 policies : network_discovery : policy_1 : config : schedule : \"0 */2 * * *\" timeout : 5 scope : targets : [ 192.168.1.1/22 , google.com ] Run command: docker run -v /local/orb:/opt/orb/ \\ -e DIODE_API_KEY ={ YOUR_API_KEY } \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml","title":"Network-discovery backend"},{"location":"netbox-discovery/agent/configuration-file/","text":"NetBox Cloud NetBox Enterprise NetBox Community Agent configuration file To run, the NetBox Discovery agent requires a YAML configuration file. This configuration file consists of three main sections: config_manager , backends , and policies . Config Manager The config_manager section specifies how NetBox Discovery agent should retrieve it's configuration information. The configuration manager is responsible for processing the configuration to retrieve policies and pass them to the appropriate backends. orb : config_manager : active : local ... Currently, only the local manager is supported, which retrieves policies from the local configuration file passed to the agent. Backends The backends section specifies what Orb agent backends should be enabled. Each Orb agent backend offers specific discovery or observability capabilities and may require specific configuration information. orb : ... backends : network_discovery : ... device_discovery : ... Only the network_discovery and device_discovery backends are currently supported and they do not require any special configuration. Refer to Device Discovery and Network Discovery for policy settings specific to each backend. Commons A special common subsection of backends defines configuration settings that are shared with all backends. Currently, it supports passing diode server settings to all backends. backends : ... common : diode : target : grpc://${DIODE_IP_ADDRESS}:8080/diode api_key : ${DIODE_API_KEY} agent_name : ${AGENT_NAME} Policies The policies section specifies what discovery policies should be passed to each backend. Policies define specific settings for discovery (such as scheduling and default properties) and the scope (targets). Backends can run multiple policies simultaneously, but for each backend all policies must have a unique name. These policies are defined in the policies section and are grouped by backend: orb : ... policies : device_discovery : device_policy_1 : # see device_discovery section network_discovery : network_policy_1 : # see network_discovery section Configuration example Here is a complete configuration example: orb : config_manager : active : local backends : network_discovery : common : diode : target : grpc://${DIODE_IP_ADDRESS}:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent02 policies : network_discovery : policy_1 : config : schedule : \"0 */2 * * *\" timeout : 5 scope : targets : [ 192.168.1.1/22 , google.com ] device_discovery : discovery_1 : config : schedule : \"* * * * *\" defaults : site : New York NY scope : - driver : ios hostname : 192.168.0.5 username : admin password : ${PASS} You can find other example configurations for Device Discovery and Network Discovery .","title":"Configuration format"},{"location":"netbox-discovery/agent/configuration-file/#agent-configuration-file","text":"To run, the NetBox Discovery agent requires a YAML configuration file. This configuration file consists of three main sections: config_manager , backends , and policies .","title":"Agent configuration file"},{"location":"netbox-discovery/agent/configuration-file/#config-manager","text":"The config_manager section specifies how NetBox Discovery agent should retrieve it's configuration information. The configuration manager is responsible for processing the configuration to retrieve policies and pass them to the appropriate backends. orb : config_manager : active : local ... Currently, only the local manager is supported, which retrieves policies from the local configuration file passed to the agent.","title":"Config Manager"},{"location":"netbox-discovery/agent/configuration-file/#backends","text":"The backends section specifies what Orb agent backends should be enabled. Each Orb agent backend offers specific discovery or observability capabilities and may require specific configuration information. orb : ... backends : network_discovery : ... device_discovery : ... Only the network_discovery and device_discovery backends are currently supported and they do not require any special configuration. Refer to Device Discovery and Network Discovery for policy settings specific to each backend.","title":"Backends"},{"location":"netbox-discovery/agent/configuration-file/#policies","text":"The policies section specifies what discovery policies should be passed to each backend. Policies define specific settings for discovery (such as scheduling and default properties) and the scope (targets). Backends can run multiple policies simultaneously, but for each backend all policies must have a unique name. These policies are defined in the policies section and are grouped by backend: orb : ... policies : device_discovery : device_policy_1 : # see device_discovery section network_discovery : network_policy_1 : # see network_discovery section","title":"Policies"},{"location":"netbox-discovery/agent/configuration-file/#configuration-example","text":"Here is a complete configuration example: orb : config_manager : active : local backends : network_discovery : common : diode : target : grpc://${DIODE_IP_ADDRESS}:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent02 policies : network_discovery : policy_1 : config : schedule : \"0 */2 * * *\" timeout : 5 scope : targets : [ 192.168.1.1/22 , google.com ] device_discovery : discovery_1 : config : schedule : \"* * * * *\" defaults : site : New York NY scope : - driver : ios hostname : 192.168.0.5 username : admin password : ${PASS} You can find other example configurations for Device Discovery and Network Discovery .","title":"Configuration example"},{"location":"netbox-discovery/agent/device_discovery/","text":"Device Discovery NetBox Cloud NetBox Enterprise NetBox Community The device discovery backend leverages NAPALM to connect to network devices and collect network information. Configuration The device_discovery backend does not require any special configuration, though overriding host and port values can be specified. The backend will use the diode settings specified in the common subsection to forward discovery results. orb : backends : common : diode : target : grpc://192.168.0.100:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent01 device_discovery : host : 192.168.5.11 # default 0.0.0.0 port : 8857 # default 8072 Policy Device discovery policies are broken down into two subsections: config and scope . Config Config defines data for the whole scope and is optional overall. Parameter Type Required Description schedule cron format no If defined, it will execute scope following cron schedule time. If not defined, it will execute scope only once defaults map no key value pair that defines default values Defaults Current supported defaults: Key Description site NetBox Site Name Scope The scope defines a list of devices that can be accessed and pulled data. Parameter Type Required Description hostname string yes Device hostname username string yes Device username password string yes Device username's password optional_args map no NAPALM optional arguments defined here driver string no If defined, try to connect to device using the specified NAPALM driver. If not, it will try all the current installed drivers Policy example An example of the policy section, including all parameters supported by the device discovery backend: orb : ... policies : device_discovery : discovery_1 : config : schedule : \"* * * * *\" defaults : site : New York NY scope : - driver : ios hostname : 192.168.0.5 username : admin password : ${PASS} optional_args : canonical_int : True - hostname : myhost.com username : remote password : 12345 Sample configuration This sample configuration file demonstrates the device discovery backend connecting to a Cisco router at 192.168.0.5. It retrieves device, interface, and IP information, then sends the data to a diode server running at 192.168.0.100. orb : config_manager : active : local backends : device_discovery : common : diode : target : grpc://192.168.0.100:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent01 policies : device_discovery : discovery_1 : config : schedule : \"* * * * *\" defaults : site : New York NY scope : - driver : ios hostname : 192.168.0.5 username : admin password : ${PASS} Run command: docker run -v /local/orb:/opt/orb/ \\ -e DIODE_API_KEY ={ YOUR_API_KEY } \\ -e PASS ={ DEVICE_PASSWORD } \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml Custom device drivers To specify community or custom NAPALM drivers, use the environment variable INSTALL_DRIVERS_PATH . Ensure that the required files are placed in the mounted volume ( /opt/orb ). Mounted folder example: /local/orb/ \u251c\u2500\u2500 agent.yaml \u251c\u2500\u2500 drivers.txt \u251c\u2500\u2500 napalm-mos/ \u2514\u2500\u2500 napalm-ros-0.3.2.tar.gz Example drivers.txt : napalm-sros==1.0.2 # try install from pypi napalm-ros-0.3.2.tar.gz # try install from a tar.gz ./napalm-mos # try to install from a folder that contains project.toml Run command: docker run -v /local/orb:/opt/orb/ \\ -e DIODE_API_KEY ={ YOUR_API_KEY } \\ -e PASS ={ DEVICE_PASSWORD } \\ -e INSTALL_DRIVERS_PATH = /opt/orb/drivers.txt \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml The relative path used by pip install should point to the directory containing the .txt file.","title":"Device Discovery"},{"location":"netbox-discovery/agent/device_discovery/#device-discovery","text":"NetBox Cloud NetBox Enterprise NetBox Community The device discovery backend leverages NAPALM to connect to network devices and collect network information.","title":"Device Discovery"},{"location":"netbox-discovery/agent/device_discovery/#configuration","text":"The device_discovery backend does not require any special configuration, though overriding host and port values can be specified. The backend will use the diode settings specified in the common subsection to forward discovery results. orb : backends : common : diode : target : grpc://192.168.0.100:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent01 device_discovery : host : 192.168.5.11 # default 0.0.0.0 port : 8857 # default 8072","title":"Configuration"},{"location":"netbox-discovery/agent/device_discovery/#policy","text":"Device discovery policies are broken down into two subsections: config and scope .","title":"Policy"},{"location":"netbox-discovery/agent/device_discovery/#config","text":"Config defines data for the whole scope and is optional overall. Parameter Type Required Description schedule cron format no If defined, it will execute scope following cron schedule time. If not defined, it will execute scope only once defaults map no key value pair that defines default values","title":"Config"},{"location":"netbox-discovery/agent/device_discovery/#scope","text":"The scope defines a list of devices that can be accessed and pulled data. Parameter Type Required Description hostname string yes Device hostname username string yes Device username password string yes Device username's password optional_args map no NAPALM optional arguments defined here driver string no If defined, try to connect to device using the specified NAPALM driver. If not, it will try all the current installed drivers","title":"Scope"},{"location":"netbox-discovery/agent/device_discovery/#policy-example","text":"An example of the policy section, including all parameters supported by the device discovery backend: orb : ... policies : device_discovery : discovery_1 : config : schedule : \"* * * * *\" defaults : site : New York NY scope : - driver : ios hostname : 192.168.0.5 username : admin password : ${PASS} optional_args : canonical_int : True - hostname : myhost.com username : remote password : 12345","title":"Policy example"},{"location":"netbox-discovery/agent/device_discovery/#sample-configuration","text":"This sample configuration file demonstrates the device discovery backend connecting to a Cisco router at 192.168.0.5. It retrieves device, interface, and IP information, then sends the data to a diode server running at 192.168.0.100. orb : config_manager : active : local backends : device_discovery : common : diode : target : grpc://192.168.0.100:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent01 policies : device_discovery : discovery_1 : config : schedule : \"* * * * *\" defaults : site : New York NY scope : - driver : ios hostname : 192.168.0.5 username : admin password : ${PASS} Run command: docker run -v /local/orb:/opt/orb/ \\ -e DIODE_API_KEY ={ YOUR_API_KEY } \\ -e PASS ={ DEVICE_PASSWORD } \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml","title":"Sample configuration"},{"location":"netbox-discovery/agent/device_discovery/#custom-device-drivers","text":"To specify community or custom NAPALM drivers, use the environment variable INSTALL_DRIVERS_PATH . Ensure that the required files are placed in the mounted volume ( /opt/orb ). Mounted folder example: /local/orb/ \u251c\u2500\u2500 agent.yaml \u251c\u2500\u2500 drivers.txt \u251c\u2500\u2500 napalm-mos/ \u2514\u2500\u2500 napalm-ros-0.3.2.tar.gz Example drivers.txt : napalm-sros==1.0.2 # try install from pypi napalm-ros-0.3.2.tar.gz # try install from a tar.gz ./napalm-mos # try to install from a folder that contains project.toml Run command: docker run -v /local/orb:/opt/orb/ \\ -e DIODE_API_KEY ={ YOUR_API_KEY } \\ -e PASS ={ DEVICE_PASSWORD } \\ -e INSTALL_DRIVERS_PATH = /opt/orb/drivers.txt \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml The relative path used by pip install should point to the directory containing the .txt file.","title":"Custom device drivers"},{"location":"netbox-discovery/agent/get-started/","text":"NetBox Cloud NetBox Enterprise NetBox Community Before getting started You'll need the following to successfully run the NetBox Discovery agent end-to-end: NetBox : a running instance of NetBox . Diode plugin : NetBox Diode plugin installed in your NetBox instance. Diode : a running instance of Diode . Download agent image First pull the Docker image from Docker Hub : docker pull netboxlabs/orb-agent:latest NetBox Discovery is based on the Orb open source project, hence the orb-agent image name. Create an agent configuration file The NetBox Discovery agent requires a configuration, specifying what discovery tasks you'd like it to accomplish. Here's a sample configuration: orb : config_manager : active : local backends : network_discovery : common : diode : target : grpc://<DIODE_IP_ADDRESS>:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent1 policies : network_discovery : policy_1 : scope : targets : - 192.168.1.10-20 Copy the configuration to a file (named agent.yaml for these instructions). Edit the file as necessary to match your environment: Replace <DIODE_IP_ADDRESS> with the IP address or hostname of your Diode server Edit and add targets relevant to your environment (they can expressed as a mix of ranges, network prefixes with mask, IP addresses or domain names) You can find more complete examples for Device Discovery and Network Discovery . Run the agent Run the agent from the same directory where you created your agent configuration file ( agent.yaml ): docker run -v $( PWD ) :/opt/orb/ \\ -e DIODE_API_KEY = <api_key> \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml Replace <api_key> with the actual Diode API key you used in configuring your Diode server. View the output You can view output from the running agent: Agent Docker container logs (displayed in the terminal) Diode server Docker container logs ( docker logs diode-diode-reconciler-1 ) Ingestion Logs view in Netbox Diode plugin","title":"Getting started"},{"location":"netbox-discovery/agent/get-started/#before-getting-started","text":"You'll need the following to successfully run the NetBox Discovery agent end-to-end: NetBox : a running instance of NetBox . Diode plugin : NetBox Diode plugin installed in your NetBox instance. Diode : a running instance of Diode .","title":"Before getting started"},{"location":"netbox-discovery/agent/get-started/#download-agent-image","text":"First pull the Docker image from Docker Hub : docker pull netboxlabs/orb-agent:latest NetBox Discovery is based on the Orb open source project, hence the orb-agent image name.","title":"Download agent image"},{"location":"netbox-discovery/agent/get-started/#create-an-agent-configuration-file","text":"The NetBox Discovery agent requires a configuration, specifying what discovery tasks you'd like it to accomplish. Here's a sample configuration: orb : config_manager : active : local backends : network_discovery : common : diode : target : grpc://<DIODE_IP_ADDRESS>:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent1 policies : network_discovery : policy_1 : scope : targets : - 192.168.1.10-20 Copy the configuration to a file (named agent.yaml for these instructions). Edit the file as necessary to match your environment: Replace <DIODE_IP_ADDRESS> with the IP address or hostname of your Diode server Edit and add targets relevant to your environment (they can expressed as a mix of ranges, network prefixes with mask, IP addresses or domain names) You can find more complete examples for Device Discovery and Network Discovery .","title":"Create an agent configuration file"},{"location":"netbox-discovery/agent/get-started/#run-the-agent","text":"Run the agent from the same directory where you created your agent configuration file ( agent.yaml ): docker run -v $( PWD ) :/opt/orb/ \\ -e DIODE_API_KEY = <api_key> \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml Replace <api_key> with the actual Diode API key you used in configuring your Diode server.","title":"Run the agent"},{"location":"netbox-discovery/agent/get-started/#view-the-output","text":"You can view output from the running agent: Agent Docker container logs (displayed in the terminal) Diode server Docker container logs ( docker logs diode-diode-reconciler-1 ) Ingestion Logs view in Netbox Diode plugin","title":"View the output"},{"location":"netbox-discovery/agent/network_discovery/","text":"Network Discovery NetBox Cloud NetBox Enterprise NetBox Community The network discovery backend leverages NMAP to scan networks and discover IP information. Configuration The network_discovery backend does not require any special configuration, though overriding host and port values can be specified. The backend will use the diode settings specified in the common subsection to forward discovery results. orb : backends : common : diode : target : grpc://192.168.0.100:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent01 network_discovery : host : 192.168.5.11 # default 0.0.0.0 port : 8863 # default 8072 log_level : ERROR # default INFO log_format : JSON # default TEXT Policy Network discovery policies are broken down into two subsections: config and scope . Config Config defines data for the whole scope and is optional overall. Parameter Type Required Description schedule cron format no If defined, it will execute scope following cron schedule time. If not defined, it will execute scope only once defaults map no key value pair that defines default values timeout int no Timeout in minutes for the nmap scan operation. The default value is 2 minutes. Defaults Current supported defaults: Key Description comments NetBox Comments information to be added to discovered IP description NetBox Description data to be added to discovered IP Scope The scope defines a list of targets to be scanned. Parameter Type Required Description targets list yes The targets that NMAP will scan. These can be specified as IP addresses (192.168.1.1), IP ranges (192.168.1.10-20), IP subnets with mask (192.168.1.0/24) or resolvable domain names. Policy example An example of the policy section, including all parameters supported by the network discovery backend. orb : ... policies : network_discovery : discovery_1 : config : schedule : \"* * * * *\" timeout : 5 defaults : comments : none description : IP discovered by network discovery scope : targets : - 192.168.7.32 - 192.168.7.30-40 # IP range - 192.168.7.0/24 # IP subnet - google.com # dns lookup Sample configuration This sample configuration file demonstrates the network discovery backend scanning the 192.168.1.0/24 network and the resolved IP address associated with google.com . It generates IP address information and sends the data to a diode server running at 192.168.0.100. orb : config_manager : active : local backends : network_discovery : common : diode : target : grpc://192.168.0.100:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent02 policies : network_discovery : policy_1 : config : schedule : \"0 */2 * * *\" timeout : 5 scope : targets : [ 192.168.1.0/24 , google.com ] Run command: docker run -v /local/orb:/opt/orb/ \\ -e DIODE_API_KEY ={ YOUR_API_KEY } \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml","title":"Network Discovery"},{"location":"netbox-discovery/agent/network_discovery/#network-discovery","text":"NetBox Cloud NetBox Enterprise NetBox Community The network discovery backend leverages NMAP to scan networks and discover IP information.","title":"Network Discovery"},{"location":"netbox-discovery/agent/network_discovery/#configuration","text":"The network_discovery backend does not require any special configuration, though overriding host and port values can be specified. The backend will use the diode settings specified in the common subsection to forward discovery results. orb : backends : common : diode : target : grpc://192.168.0.100:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent01 network_discovery : host : 192.168.5.11 # default 0.0.0.0 port : 8863 # default 8072 log_level : ERROR # default INFO log_format : JSON # default TEXT","title":"Configuration"},{"location":"netbox-discovery/agent/network_discovery/#policy","text":"Network discovery policies are broken down into two subsections: config and scope .","title":"Policy"},{"location":"netbox-discovery/agent/network_discovery/#config","text":"Config defines data for the whole scope and is optional overall. Parameter Type Required Description schedule cron format no If defined, it will execute scope following cron schedule time. If not defined, it will execute scope only once defaults map no key value pair that defines default values timeout int no Timeout in minutes for the nmap scan operation. The default value is 2 minutes.","title":"Config"},{"location":"netbox-discovery/agent/network_discovery/#scope","text":"The scope defines a list of targets to be scanned. Parameter Type Required Description targets list yes The targets that NMAP will scan. These can be specified as IP addresses (192.168.1.1), IP ranges (192.168.1.10-20), IP subnets with mask (192.168.1.0/24) or resolvable domain names.","title":"Scope"},{"location":"netbox-discovery/agent/network_discovery/#policy-example","text":"An example of the policy section, including all parameters supported by the network discovery backend. orb : ... policies : network_discovery : discovery_1 : config : schedule : \"* * * * *\" timeout : 5 defaults : comments : none description : IP discovered by network discovery scope : targets : - 192.168.7.32 - 192.168.7.30-40 # IP range - 192.168.7.0/24 # IP subnet - google.com # dns lookup","title":"Policy example"},{"location":"netbox-discovery/agent/network_discovery/#sample-configuration","text":"This sample configuration file demonstrates the network discovery backend scanning the 192.168.1.0/24 network and the resolved IP address associated with google.com . It generates IP address information and sends the data to a diode server running at 192.168.0.100. orb : config_manager : active : local backends : network_discovery : common : diode : target : grpc://192.168.0.100:8080/diode api_key : ${DIODE_API_KEY} agent_name : agent02 policies : network_discovery : policy_1 : config : schedule : \"0 */2 * * *\" timeout : 5 scope : targets : [ 192.168.1.0/24 , google.com ] Run command: docker run -v /local/orb:/opt/orb/ \\ -e DIODE_API_KEY ={ YOUR_API_KEY } \\ netboxlabs/orb-agent:latest run -c /opt/orb/agent.yaml","title":"Sample configuration"},{"location":"netbox-enterprise/deploying-netbox-enterprise/","text":"Multiple deployment models to suit your environment NetBox Enterprise supports different deployment models to best address varying requirements and environments. For a fully managed, hands-off experience, we support an Embedded Cluster (EC) installation that takes care of everything, including deploying and managing the underlying Kubernetes cluster. All that\u2019s needed is a bare Linux operating system running on adequately sized compute resources. EC deployments deliver all the components and dependencies required to install and operate NetBox, including databases, application servers, application load balancers, and object stores. EC deployments also provide the option of leveraging external components, such as a cloud PostgreSQL cluster or an S3 Object Store. For customers who are already operating their own Kubernetes clusters, we also support a Kubernetes Off-The-Shelf (KOTS) installation that deploys NetBox Enterprise on your k8s cluster. KOTS deployments include all the same components and take care of all the dependencies just like EC deployments. They also provide the same flexibility in leveraging external database and object store components. Walking through a fully contained NetBox Enterprise installation Let\u2019s walk through an Embedded Cluster (EC) install to see just how easy it is to get started with NetBox Enterprise! Download the deployment package and license file to your Linux host: curl https://replicated.app/embedded/netbox-enterprise/stable -o netbox-enterprise-stable.tgz After uncompressing the package, simply launch the installation: sudo ./netbox-enterprise install --license license.yaml You\u2019ll be requested to create a password for the NetBox Enterprise admin console and the cluster will be deployed, ready to host all the NetBox application components. The deployment of the cluster is complete when you see this message: Visit the Admin Console to configure and install netbox-enterprise: http://my.netbox-enterprise.host:30000 Access the NetBox Enterprise admin console and configure NetBox Open the provided URL in your browser. You\u2019ll be prompted for the password you created in Step 2: You\u2019ll then be guided to configure NetBox for your environment: You\u2019ll be able to configure: Version of NetBox that you want to install: Whether to use a built-in or external PostgreSQL: Whether to use a built-in or external S3-Compatible object store: And finally, advanced settings to configure plugins and SSO remote authentication: The deployment of NetBox Enterprise will then proceed: The Unavailable status will change to Ready once the deployment is complete and NetBox has fully initialized: That\u2019s it! You\u2019re ready to get started with NetBox","title":"Deploying netbox enterprise"},{"location":"netbox-enterprise/deploying-netbox-enterprise/#multiple-deployment-models-to-suit-your-environment","text":"NetBox Enterprise supports different deployment models to best address varying requirements and environments. For a fully managed, hands-off experience, we support an Embedded Cluster (EC) installation that takes care of everything, including deploying and managing the underlying Kubernetes cluster. All that\u2019s needed is a bare Linux operating system running on adequately sized compute resources. EC deployments deliver all the components and dependencies required to install and operate NetBox, including databases, application servers, application load balancers, and object stores. EC deployments also provide the option of leveraging external components, such as a cloud PostgreSQL cluster or an S3 Object Store. For customers who are already operating their own Kubernetes clusters, we also support a Kubernetes Off-The-Shelf (KOTS) installation that deploys NetBox Enterprise on your k8s cluster. KOTS deployments include all the same components and take care of all the dependencies just like EC deployments. They also provide the same flexibility in leveraging external database and object store components.","title":"Multiple deployment models to suit your environment"},{"location":"netbox-enterprise/deploying-netbox-enterprise/#walking-through-a-fully-contained-netbox-enterprise-installation","text":"Let\u2019s walk through an Embedded Cluster (EC) install to see just how easy it is to get started with NetBox Enterprise! Download the deployment package and license file to your Linux host: curl https://replicated.app/embedded/netbox-enterprise/stable -o netbox-enterprise-stable.tgz After uncompressing the package, simply launch the installation: sudo ./netbox-enterprise install --license license.yaml You\u2019ll be requested to create a password for the NetBox Enterprise admin console and the cluster will be deployed, ready to host all the NetBox application components. The deployment of the cluster is complete when you see this message: Visit the Admin Console to configure and install netbox-enterprise: http://my.netbox-enterprise.host:30000 Access the NetBox Enterprise admin console and configure NetBox Open the provided URL in your browser. You\u2019ll be prompted for the password you created in Step 2: You\u2019ll then be guided to configure NetBox for your environment: You\u2019ll be able to configure: Version of NetBox that you want to install: Whether to use a built-in or external PostgreSQL: Whether to use a built-in or external S3-Compatible object store: And finally, advanced settings to configure plugins and SSO remote authentication: The deployment of NetBox Enterprise will then proceed: The Unavailable status will change to Ready once the deployment is complete and NetBox has fully initialized: That\u2019s it! You\u2019re ready to get started with NetBox","title":"Walking through a fully contained NetBox Enterprise installation"},{"location":"netbox-enterprise/nbe-backups/","text":"NetBox Enterprise Backups Much like the NetBox software itself, NetBox Enterprise uses 2 main datastores: PostgreSQL, and Redis. PostgreSQL is used for the primary model data in NetBox, including sites, facilities, racks, and so on. Redis is used for caching, the task queue, and some other data including stored scripts. Additionally, NetBox Enterprise uses an S3-compatible store for some specific resources, most notably image uploads. NOTE: The built-in S3-compatible store keeps its data in Redis, so it is not necessary to back it up separately. For each type of datastore you can choose to use a built-in deployment, or configure NetBox Enterprise to use an existing external resource already in your environment. External Databases Info If you are providing your own database(s) for use by NetBox Enterprise, it is expected that you have your own processes for high availability, backup, and restore. Using Disaster Recovery for Backups A disaster recovery backup will preserve the complete state of your NetBox Enterprise install, from allocated volumes to databases to custom configuration. This feature is included in Embedded Cluster installs, and can be enabled by installing some extra dependencies to your cluster for KOTS installs. Backing Up the Embedded Cluster Navigate to the backup configuration by clicking the Backup settings link in the Disaster Recovery section of the admin console. Input your S3 bucket, credentials, endpoint, and region. Click Update storage settings -- it will spend a few moments validating that your settings work. Perform a backup by clicking the Backups tab, and then clicking Start backup . Restoring the Embedded Cluster Download the latest embedded cluster installer following the same instructions you did for a new install, if you haven't already. Run: ./netbox-enterprise restore Enter the same S3 credentials you use for backups. Next, it will take a few minutes to bring up the node. When it's complete, you will be prompted to continue the restore: Enter Y to continue, and the restore will launch the cluster. (Optional) If you plan to have more than one node in the new cluster, you can go to the admin console and configure them when prompted. Enter continue to finish bringing the NetBox Enterprise application up. It will take a few more minutes to finish bringing the application up, and then you will see \"Application restored!\" NetBox Enterprise and the Admin Console should now be completely restored and available as normal. Manual Backup and Restore Besides disaster recovery, it is also a good idea to keep backups of your data in case you want to view, partially restore, or move your data to another system. NetBox Enterprise Namespace The default namespace for KOTS installs is netbox-enterprise , and the Embedded Cluster default is kotsadm . The instructions below default to kotsadm , but you can change the NETBOX_NAMESPACE export to match your system. Backing Up Your Data Backing up NetBox Enterprise's data manually is reasonably simple, and Kubernetes makes it easy to access them from the command-line. Before You Back Up: Accessing Your Cluster Before you can back anything up, you must first make sure you can access the cluster on the command line. See the advanced tools documentation for details on connecting to your NetBox Enterprise cluster. Media, Scripts, and Reports Media, scripts, and reports are stored in a volume accessible from the NetBox containers. To back them up, you can run this: export NETBOX_NAMESPACE = \"kotsadm\" && \\ NETBOX_MAIN_POD = \" $( kubectl get pod \\ -o name \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -l 'app.kubernetes.io/component=netbox' \\ | head -n 1 \\ ) \" && \\ kubectl exec \" ${ NETBOX_MAIN_POD } \" \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -c netbox \\ -- /bin/sh -c ' \\ cd /opt/netbox/netbox && \\ find media scripts reports -type f > /tmp/files.txt && \\ tar -czf - \\ --owner=0 \\ --group=0 \\ -T /tmp/files.txt' > netbox-data.tar.gz Built-In PostgreSQL The built-in PostgreSQL is deployed using the CrunchyData Postgres Operator. Since the PostgreSQL CLI tools are already available inside the cluster, all we need to do to dump the database is to call into the correct container and run a pg_dump there. To perform a database dump, run these commands: export NETBOX_NAMESPACE = \"kotsadm\" && \\ POSTGRESQL_MAIN_POD = \" $( kubectl get pod \\ -o name \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -l 'postgres-operator.crunchydata.com/role=master' \\ | head -n 1 \\ ) \" && \\ kubectl exec \" ${ POSTGRESQL_MAIN_POD } \" \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -c database \\ -- \\ pg_dump netbox > netbox.pgsql This will create a netbox.pgsql file in your local directory. Save it somewhere safe for future restores. For more details on backing up NetBox databases, see the official NetBox documentation . Built-In Redis The built-in Redis is deployed using the Bitnami Redis Helm chart. Backing up Redis is straightforward, since it does its work in memory and then writes checkpoints to the filesystem atomically. First, make sure that AOF rewrite isn't enabled, and confirm that a rewrite isn't in-process before you start backing up: export NETBOX_NAMESPACE = \"kotsadm\" && \\ export REDIS_MAIN_POD = \" $( kubectl get pod \\ -o name \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -l 'app.kubernetes.io/component=master,app.kubernetes.io/name=redis' \\ | head -n 1 \\ ) \" && \\ for COMMAND in \\ \"CONFIG SET auto-aof-rewrite-percentage 0\" \\ \"SAVE\" \\ \"INFO persistence\" ; do kubectl exec ${ REDIS_MAIN_POD } \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -i \\ -c redis \\ -- bash -c \\ \"REDISCLI_AUTH=\\$REDIS_PASSWORD redis-cli ${ COMMAND } \" \\ | grep 'aof_rewrite_in_progress' done Make sure that those commands output aof_rewrite_in_progress:0 , then you're ready to proceed. Otherwise, just run them again until it says 0. Next, all that's necessary to back up the data in your Redis install is a basic tar command to create an archive from the /data directory in the same shell: kubectl exec ${ REDIS_MAIN_POD } \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -c redis \\ -- /bin/sh -c ' \\ cd /data && \\ find * -type f > /tmp/files.txt && \\ tar -czf - \\ --owner=0 \\ --group=0 \\ -T /tmp/files.txt' > redis-data.tar.gz Finally, turn AOF rewrites back on: kubectl exec ${ REDIS_MAIN_POD } \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -c redis \\ -- bash -c \\ 'REDISCLI_AUTH=$REDIS_PASSWORD \\ redis-cli \\ CONFIG SET auto-aof-rewrite-percentage 100' Restoring Your Backups Restoring is almost as simple as backing up. You just need to put NetBox Enterprise into restore mode first. Enabling and Disabling Restore Mode Put NetBox Enterprise into \"Restore Mode\" by going to the Config tab and checking the Enable Restore Mode checkbox. Click the \"Save config\" button at the bottom of the form, and then when the admin console prompts you, click \"go to updated version\". Confirm that the New version available at the top denotes it's a config change, and if so click the \"Deploy\" button. This will shut down NetBox (and the built-in Redis, if you are using it) but leave the other NetBox Enterprise infrastructure up, so you can safely restore. When you are done restoring your data, just follow the same steps, unchecking Enable Restore Mode and deploying the updated configuration. Media, Scripts, and Reports To restore media, scripts, and reports, you just need to unpack them into the correct directory inside a NetBox container. Note The backup instructions above back up all three of the media/ , scripts/ , and reports/ subdirectories in one file. If you are restoring a backup from another NetBox instance, you might need to change the name of the tarball and the path after the -C at the end of this command to unpack your backup into the right location. export NETBOX_NAMESPACE = \"kotsadm\" && \\ export NETBOX_RESTORE_POD = \" $( kubectl get pod \\ -o name \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -l 'app.kubernetes.io/component=restore-mode' \\ | head -n 1 \\ ) \" && \\ cat netbox-data.tar.gz | kubectl exec ${ NETBOX_RESTORE_POD } \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -i \\ -- tar -xvzf - \\ --no-same-owner \\ --no-same-permission \\ -C /opt/netbox/netbox Built-In PostgreSQL To restore from a dump file, pipe the netbox.pgsql created during backup into psql in the PostgreSQL pod: export NETBOX_NAMESPACE = \"kotsadm\" POSTGRESQL_MAIN_POD = \" $( kubectl get pod \\ -o name \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -l 'postgres-operator.crunchydata.com/role=master' \\ | head -n 1 \\ ) \" && \\ kubectl exec \" ${ POSTGRESQL_MAIN_POD } \" \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -c database \\ -- dropdb --if-exists --force netbox && \\ kubectl exec \" ${ POSTGRESQL_MAIN_POD } \" \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -c database \\ -- createdb -E UTF8 netbox && \\ cat netbox.pgsql | kubectl exec \" ${ POSTGRESQL_MAIN_POD } \" \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -i \\ -c database \\ -- psql -d netbox -f- Following this run the below to ensure all database permissions are correct: export NETBOX_NAMESPACE = \"kotsadm\" POSTGRESQL_MAIN_POD = \" $( kubectl get pod \\ -o name \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -l 'postgres-operator.crunchydata.com/role=master' \\ | head -n 1 \\ ) \" && \\ kubectl exec \" ${ POSTGRESQL_MAIN_POD } \" \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -i \\ -c database \\ -- psql -c \"ALTER DATABASE netbox OWNER TO netbox;\" && \\ kubectl exec \" ${ POSTGRESQL_MAIN_POD } \" \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -i \\ -c database \\ -- psql -d netbox -c \"GRANT CREATE ON SCHEMA public TO netbox;\" Built-In Redis Since Redis isn't running in restore mode, there is no need to disable and re-enable append mode. All that is necessary is to unpack the files back into place. export NETBOX_NAMESPACE = \"kotsadm\" && \\ export REDIS_MAIN_POD = \" $( kubectl get pod \\ -o name \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -l 'app.kubernetes.io/component=master,app.kubernetes.io/name=redis' \\ | head -n 1 \\ ) \" && \\ cat redis-data.tar.gz | kubectl exec ${ REDIS_MAIN_POD } \\ -n \" ${ NETBOX_NAMESPACE } \" \\ -i \\ -c redis \\ -- tar -xvzf - \\ --no-same-owner \\ --no-same-permission \\ -C /data","title":"Backups"},{"location":"netbox-enterprise/nbe-backups/#netbox-enterprise-backups","text":"Much like the NetBox software itself, NetBox Enterprise uses 2 main datastores: PostgreSQL, and Redis. PostgreSQL is used for the primary model data in NetBox, including sites, facilities, racks, and so on. Redis is used for caching, the task queue, and some other data including stored scripts. Additionally, NetBox Enterprise uses an S3-compatible store for some specific resources, most notably image uploads. NOTE: The built-in S3-compatible store keeps its data in Redis, so it is not necessary to back it up separately. For each type of datastore you can choose to use a built-in deployment, or configure NetBox Enterprise to use an existing external resource already in your environment.","title":"NetBox Enterprise Backups"},{"location":"netbox-enterprise/nbe-backups/#external-databases","text":"Info If you are providing your own database(s) for use by NetBox Enterprise, it is expected that you have your own processes for high availability, backup, and restore.","title":"External Databases"},{"location":"netbox-enterprise/nbe-backups/#using-disaster-recovery-for-backups","text":"A disaster recovery backup will preserve the complete state of your NetBox Enterprise install, from allocated volumes to databases to custom configuration. This feature is included in Embedded Cluster installs, and can be enabled by installing some extra dependencies to your cluster for KOTS installs.","title":"Using Disaster Recovery for Backups"},{"location":"netbox-enterprise/nbe-backups/#backing-up-the-embedded-cluster","text":"Navigate to the backup configuration by clicking the Backup settings link in the Disaster Recovery section of the admin console. Input your S3 bucket, credentials, endpoint, and region. Click Update storage settings -- it will spend a few moments validating that your settings work. Perform a backup by clicking the Backups tab, and then clicking Start backup .","title":"Backing Up the Embedded Cluster"},{"location":"netbox-enterprise/nbe-backups/#restoring-the-embedded-cluster","text":"Download the latest embedded cluster installer following the same instructions you did for a new install, if you haven't already. Run: ./netbox-enterprise restore Enter the same S3 credentials you use for backups. Next, it will take a few minutes to bring up the node. When it's complete, you will be prompted to continue the restore: Enter Y to continue, and the restore will launch the cluster. (Optional) If you plan to have more than one node in the new cluster, you can go to the admin console and configure them when prompted. Enter continue to finish bringing the NetBox Enterprise application up. It will take a few more minutes to finish bringing the application up, and then you will see \"Application restored!\" NetBox Enterprise and the Admin Console should now be completely restored and available as normal.","title":"Restoring the Embedded Cluster"},{"location":"netbox-enterprise/nbe-backups/#manual-backup-and-restore","text":"Besides disaster recovery, it is also a good idea to keep backups of your data in case you want to view, partially restore, or move your data to another system. NetBox Enterprise Namespace The default namespace for KOTS installs is netbox-enterprise , and the Embedded Cluster default is kotsadm . The instructions below default to kotsadm , but you can change the NETBOX_NAMESPACE export to match your system.","title":"Manual Backup and Restore"},{"location":"netbox-enterprise/nbe-backups/#backing-up-your-data","text":"Backing up NetBox Enterprise's data manually is reasonably simple, and Kubernetes makes it easy to access them from the command-line. Before You Back Up: Accessing Your Cluster Before you can back anything up, you must first make sure you can access the cluster on the command line. See the advanced tools documentation for details on connecting to your NetBox Enterprise cluster.","title":"Backing Up Your Data"},{"location":"netbox-enterprise/nbe-backups/#restoring-your-backups","text":"Restoring is almost as simple as backing up. You just need to put NetBox Enterprise into restore mode first.","title":"Restoring Your Backups"},{"location":"netbox-enterprise/nbe-ec-installation/","text":"NetBox Enterprise Embedded Cluster Installation Conventional Installation You should be able to follow these instructions for installing the Embedded Cluster in most environments. If you are in a more restrictive environment, see the Advanced Installation section below. Deploying the cluster The following steps are required for an Embedded Cluster (EC) installation of NetBox Enterprise. Download the deployment package and license file to your host (the Authorization token should be provided by NetBox Labs): curl https://replicated.app/embedded/netbox-enterprise/stable -H \"Authorization: <provided by NetBox Labs>\" -o netbox-enterprise-stable.tgz 2. Uncompress the package and launch the installation: tar -xvzf netbox-enterprise-unstable.tgz sudo ./netbox-enterprise install --license license.yaml You\u2019ll be requested to create a password for the NetBox Enterprise admin console. A Kubernetes cluster will then be deployed, ready to host all the NetBox application components. The deployment of the cluster is complete with this message: Visit the Admin Console to configure and install netbox-enterprise: http://my.netbox-enterprise.host:30000 Deploying NetBox Access the NetBox Enterprise admin console and configure NetBox. Open the provided URL in a browser. A prompt will require the password created in Step 2: A wizard will guide the configuration of NetBox for the environment: Configuration information includes: Built-in or external PostgreSQL: Built-in or external S3-Compatible object store: Built-in or external Redis object store: Advanced settings to configure plugins and SSO remote authentication, and IPv4/IPv6 compatibility: Finally, accept the terms of service by writing \"ACCEPT\" (case-insensitive) and you can proceed to the deployment. Finish the Deployment Once you have accepted the terms of service and continued on to the main admin console, deployment will start. The first deployment will take some time, as it brings up all subsystems and runs migrations to initialize the database. The Unavailable status will change to Ready once the deployment is complete and NetBox has fully initialized: Verify the Deployment Once you see Ready , NetBox Enterprise is fully deployed, and available on ports 80 and 443 . Advanced Installation Proxies If you are installing in a restrictive environment, you may have to provide extra configuration at install-time. NetBox Enterprise as of version 1.6.0 has support for installing through proxies using the following configuration. Proxy Configuration Before you can install, you must configure your proxy to allow the following hostnames: app.enterprise.netboxlabs.com get.enterprise.netboxlabs.com proxy.enterprise.netboxlabs.com registry.enterprise.netboxlabs.com They are required to access various parts of the Enmbedded Cluster and NetBox Enterprise installation resources. Additionally, you may also want to configure a few more hosts: api.netbox.oss.netboxlabs.com - used to query an API for information on NetBox plugins census.netbox.oss.netboxlabs.com - used to collect anonymized data about your NetBox version. For details, see the NetBox documentation . Installation Once you have configured your proxy to allow access to the NetBox Enterprise hosts, you will need to pass some additional arguments to the Embedded Cluster installer. Note that the Embedded Cluster will not inherit proxy settings from the shell environment. --http-proxy <proxy-url> The proxy url should be a complete URL to reach the proxy. (eg, http://myhost:8888 ) * --https-proxy <proxy-url> Like --http-proxy , this should be the proxy's URL. * --no-proxy By default, the Embedded Cluster will automatically disable proxying on the internal cluster addresses, as well as the default network interface on your host. In some cases, if it can't autodetect an interface or you have a more complicated network, you may need to specify this manually in the form of a comma-separated list of addresses with CIDR netmasks ( 1.2.3.4/32 ), or domains ( foo.com , *.bar.com ). Man-In-The-Middle (MITM) Proxies If you are using a MITM proxy (ie, one which uses an internal TLS certificate authority for communication with the proxy, rather than directly passing encrypted traffic), you will need an additional option: --private-ca </path/to/private-ca-bundle> This will allow the Embedded Cluster to accept traffic that has been encrypted using your internal CA. Firewalld If you are using Firewalld (commonly found on RHEL installations, among others), you will need to create a zone for the cluster before installing. Determine any host IP addresses or networks (external or otherwise) that might need access to the cluster. Create a file called /etc/firewalld/zones/embedded-cluster.xml with the following contents: <?xml version=\"1.0\" encoding=\"utf-8\"?> <zone target= \"ACCEPT\" > <short> embedded-cluster </short> <description> Zone for Embedded Cluster communication </description> <!-- HOST IP ADDRESSES GO HERE --> <source address= \"10.244.0.0/17\" /> <source address= \"10.244.128.0/17\" /> <port protocol= \"tcp\" port= \"2380\" /> <port protocol= \"udp\" port= \"4789\" /> <port protocol= \"tcp\" port= \"6443\" /> <port protocol= \"tcp\" port= \"7443\" /> <port protocol= \"tcp\" port= \"9091\" /> <port protocol= \"tcp\" port= \"9443\" /> <port protocol= \"tcp\" port= \"10249\" /> <port protocol= \"tcp\" port= \"10250\" /> <port protocol= \"tcp\" port= \"10256\" /> <port protocol= \"tcp\" port= \"30000\" /> <port protocol= \"tcp\" port= \"22\" /> </zone> In the spot where it says <!-- HOST IP ADDRESSES GO HERE --> , add a <source /> tag for each host or network you want to allow. For example, if your external IP is 1.2.3.4 , and you also have a private class C network 192.168.123.0 , you would add two lines: <source address= \"1.2.3.4/32\" /> <source address= \"192.168.123.0/24\" /> Run sudo firewall-cmd --reload to load the zone configuration. SELinux There are two steps to installing with SELinux enabled with enforcement turned on. First, before you install the Embedded Cluster, run: setenforce 0 ...this will temporarily disable SELinux enforcement until you reenable it, or reboot. Next, follow the normal instructions for Conventional Installation above. Finally, run the following commands to make sure your Embedded Cluster installation is accessible with enforcement enabled: export EC_DIR = \"/var/lib/embedded-cluster\" export KUBE_DIR = \" ${ EC_DIR } /k0s\" sudo semanage fcontext -a -t container_var_lib_t \" ${ EC_DIR } \" sudo restorecon -R -v \" ${ EC_DIR } \" sudo semanage fcontext -a -t container_runtime_exec_t \" ${ KUBE_DIR } /bin/containerd.*\" sudo semanage fcontext -a -t container_runtime_exec_t \" ${ KUBE_DIR } /bin/runc\" sudo restorecon -R -v \" ${ KUBE_DIR } /bin\" sudo semanage fcontext -a -t container_var_lib_t \" ${ KUBE_DIR } /containerd(/.*)?\" sudo semanage fcontext -a -t container_ro_file_t \" ${ KUBE_DIR } /containerd/io.containerd.snapshotter.*/snapshots(/.*)?\" sudo restorecon -R -v ${ KUBE_DIR } /containerd","title":"Installation"},{"location":"netbox-enterprise/nbe-ec-installation/#netbox-enterprise-embedded-cluster-installation","text":"","title":"NetBox Enterprise Embedded Cluster Installation"},{"location":"netbox-enterprise/nbe-ec-installation/#conventional-installation","text":"You should be able to follow these instructions for installing the Embedded Cluster in most environments. If you are in a more restrictive environment, see the Advanced Installation section below.","title":"Conventional Installation"},{"location":"netbox-enterprise/nbe-ec-installation/#deploying-the-cluster","text":"The following steps are required for an Embedded Cluster (EC) installation of NetBox Enterprise. Download the deployment package and license file to your host (the Authorization token should be provided by NetBox Labs): curl https://replicated.app/embedded/netbox-enterprise/stable -H \"Authorization: <provided by NetBox Labs>\" -o netbox-enterprise-stable.tgz 2. Uncompress the package and launch the installation: tar -xvzf netbox-enterprise-unstable.tgz sudo ./netbox-enterprise install --license license.yaml You\u2019ll be requested to create a password for the NetBox Enterprise admin console. A Kubernetes cluster will then be deployed, ready to host all the NetBox application components. The deployment of the cluster is complete with this message: Visit the Admin Console to configure and install netbox-enterprise: http://my.netbox-enterprise.host:30000","title":"Deploying the cluster"},{"location":"netbox-enterprise/nbe-ec-installation/#deploying-netbox","text":"Access the NetBox Enterprise admin console and configure NetBox. Open the provided URL in a browser. A prompt will require the password created in Step 2: A wizard will guide the configuration of NetBox for the environment: Configuration information includes: Built-in or external PostgreSQL: Built-in or external S3-Compatible object store: Built-in or external Redis object store: Advanced settings to configure plugins and SSO remote authentication, and IPv4/IPv6 compatibility: Finally, accept the terms of service by writing \"ACCEPT\" (case-insensitive) and you can proceed to the deployment.","title":"Deploying NetBox"},{"location":"netbox-enterprise/nbe-ec-installation/#finish-the-deployment","text":"Once you have accepted the terms of service and continued on to the main admin console, deployment will start. The first deployment will take some time, as it brings up all subsystems and runs migrations to initialize the database. The Unavailable status will change to Ready once the deployment is complete and NetBox has fully initialized:","title":"Finish the Deployment"},{"location":"netbox-enterprise/nbe-ec-installation/#verify-the-deployment","text":"Once you see Ready , NetBox Enterprise is fully deployed, and available on ports 80 and 443 .","title":"Verify the Deployment"},{"location":"netbox-enterprise/nbe-ec-installation/#advanced-installation","text":"","title":"Advanced Installation"},{"location":"netbox-enterprise/nbe-ec-installation/#proxies","text":"If you are installing in a restrictive environment, you may have to provide extra configuration at install-time. NetBox Enterprise as of version 1.6.0 has support for installing through proxies using the following configuration.","title":"Proxies"},{"location":"netbox-enterprise/nbe-ec-installation/#firewalld","text":"If you are using Firewalld (commonly found on RHEL installations, among others), you will need to create a zone for the cluster before installing. Determine any host IP addresses or networks (external or otherwise) that might need access to the cluster. Create a file called /etc/firewalld/zones/embedded-cluster.xml with the following contents: <?xml version=\"1.0\" encoding=\"utf-8\"?> <zone target= \"ACCEPT\" > <short> embedded-cluster </short> <description> Zone for Embedded Cluster communication </description> <!-- HOST IP ADDRESSES GO HERE --> <source address= \"10.244.0.0/17\" /> <source address= \"10.244.128.0/17\" /> <port protocol= \"tcp\" port= \"2380\" /> <port protocol= \"udp\" port= \"4789\" /> <port protocol= \"tcp\" port= \"6443\" /> <port protocol= \"tcp\" port= \"7443\" /> <port protocol= \"tcp\" port= \"9091\" /> <port protocol= \"tcp\" port= \"9443\" /> <port protocol= \"tcp\" port= \"10249\" /> <port protocol= \"tcp\" port= \"10250\" /> <port protocol= \"tcp\" port= \"10256\" /> <port protocol= \"tcp\" port= \"30000\" /> <port protocol= \"tcp\" port= \"22\" /> </zone> In the spot where it says <!-- HOST IP ADDRESSES GO HERE --> , add a <source /> tag for each host or network you want to allow. For example, if your external IP is 1.2.3.4 , and you also have a private class C network 192.168.123.0 , you would add two lines: <source address= \"1.2.3.4/32\" /> <source address= \"192.168.123.0/24\" /> Run sudo firewall-cmd --reload to load the zone configuration.","title":"Firewalld"},{"location":"netbox-enterprise/nbe-ec-installation/#selinux","text":"There are two steps to installing with SELinux enabled with enforcement turned on. First, before you install the Embedded Cluster, run: setenforce 0 ...this will temporarily disable SELinux enforcement until you reenable it, or reboot. Next, follow the normal instructions for Conventional Installation above. Finally, run the following commands to make sure your Embedded Cluster installation is accessible with enforcement enabled: export EC_DIR = \"/var/lib/embedded-cluster\" export KUBE_DIR = \" ${ EC_DIR } /k0s\" sudo semanage fcontext -a -t container_var_lib_t \" ${ EC_DIR } \" sudo restorecon -R -v \" ${ EC_DIR } \" sudo semanage fcontext -a -t container_runtime_exec_t \" ${ KUBE_DIR } /bin/containerd.*\" sudo semanage fcontext -a -t container_runtime_exec_t \" ${ KUBE_DIR } /bin/runc\" sudo restorecon -R -v \" ${ KUBE_DIR } /bin\" sudo semanage fcontext -a -t container_var_lib_t \" ${ KUBE_DIR } /containerd(/.*)?\" sudo semanage fcontext -a -t container_ro_file_t \" ${ KUBE_DIR } /containerd/io.containerd.snapshotter.*/snapshots(/.*)?\" sudo restorecon -R -v ${ KUBE_DIR } /containerd","title":"SELinux"},{"location":"netbox-enterprise/nbe-ec-requirements/","text":"NetBox Enterprise Embedded Cluster Requirements Host system requirements Recommended The following are the recommended system requirements for a production deployment of NetBox Enterprise running two replicas. For larger environments with more replicas, additional resources should be allocated. 8 Virtual CPU (vCPU) 24 GB Memory (RAM) 100 GB SSD free disk space in /var/lib Note For non-production deployments of NetBox Enterprise, the minimum system requirements can be reduced to 4 Virtual CPU (vCPU) and 16 GB Memory (RAM). All other requirements remain the same. Host operating system Linux (Kernel versions 4.3 and above) Architecture x86-64","title":"Requirements"},{"location":"netbox-enterprise/nbe-ec-requirements/#netbox-enterprise-embedded-cluster-requirements","text":"","title":"NetBox Enterprise Embedded Cluster Requirements"},{"location":"netbox-enterprise/nbe-ec-requirements/#host-system-requirements","text":"","title":"Host system requirements"},{"location":"netbox-enterprise/nbe-ec-requirements/#host-operating-system","text":"Linux (Kernel versions 4.3 and above)","title":"Host operating system"},{"location":"netbox-enterprise/nbe-ec-requirements/#architecture","text":"x86-64","title":"Architecture"},{"location":"netbox-enterprise/nbe-kots-installation/","text":"NetBox Enterprise KOTS Installation Kubernetes dependencies Ensure you have the following Kubernetes dependencies installed. Please refer to the instructions for your operating system to install them. kubectl : general tool for interacting with Kubernetes clusters helm : a \"package manager\" for Kubernetes Install KOTS KOTS is a kubectl plugin and admin console to help manage Kubernetes Off-The-Shelf software from one or more Helm charts. To install, run the following command: curl https://kots.io/install | bash Install the NetBox Enterprise Helm chart Install the chart into the cluster: kubectl kots install netbox-enterprise You will be prompted to create a namespace to deploy to: Enter the namespace to deploy to: You will also be prompted to create a password for the Admin Console: Enter a new password for the admin console (6+ characters): The helm chart was successfully installed when you see this: \u2022 Deploying Admin Console \u2022 Creating namespace \u2713 \u2022 Waiting for datastore to be ready \u2713 \u2022 Waiting for Admin Console to be ready \u2713 \u2022 Press Ctrl+C to exit \u2022 Go to http://localhost:8800 to access the Admin Console Install NetBox Connect to the Admin Console Access the NetBox Enterprise Admin Console by opening the provided URL in a browser. Tip If you are connecting to the cluster over the network, you might need to configure port forwarding to connect to the Admin Console: kubectl port-forward -n <namespace> svc/kotsadm --address 0.0.0.0 3000:3000 Once connected, you will be prompted for the password you created earlier: You will then be prompted to provide your license file. Your license file should have been provided to you by NetBox Labs. Configure NetBox You will now be presented with a form to configure NetBox for your environment: You can configure the following NetBox configuration parameters: Version of NetBox to deploy NetBox superuser name and password Number of NetBox replicas to run (Optional) External PostgreSQL (Optional) External S3-compatible storage (Optional) External Redis cache Advanced settings: plugins, remote authentication (SSO) and user group sync You'll also need to accept the NetBox Labs Terms of Service by entering ACCEPT before proceeding: Deploy NetBox The deployment of NetBox Enterprise will then proceed: The Unavailable status will change to Ready once the deployment is complete and NetBox has fully initialized: NetBox Enterprise should now be fully deployed. Tip Although deployment is complete, you may still need to configure your ingress controller before you can connect without having to use port-forwarding. NetBox Enterprise is configured to expose a ClusterIP service with the name netbox-enterprise on port 80.","title":"Installation"},{"location":"netbox-enterprise/nbe-kots-installation/#netbox-enterprise-kots-installation","text":"","title":"NetBox Enterprise KOTS Installation"},{"location":"netbox-enterprise/nbe-kots-installation/#kubernetes-dependencies","text":"Ensure you have the following Kubernetes dependencies installed. Please refer to the instructions for your operating system to install them. kubectl : general tool for interacting with Kubernetes clusters helm : a \"package manager\" for Kubernetes","title":"Kubernetes dependencies"},{"location":"netbox-enterprise/nbe-kots-installation/#install-kots","text":"KOTS is a kubectl plugin and admin console to help manage Kubernetes Off-The-Shelf software from one or more Helm charts. To install, run the following command: curl https://kots.io/install | bash","title":"Install KOTS"},{"location":"netbox-enterprise/nbe-kots-installation/#install-the-netbox-enterprise-helm-chart","text":"Install the chart into the cluster: kubectl kots install netbox-enterprise You will be prompted to create a namespace to deploy to: Enter the namespace to deploy to: You will also be prompted to create a password for the Admin Console: Enter a new password for the admin console (6+ characters): The helm chart was successfully installed when you see this: \u2022 Deploying Admin Console \u2022 Creating namespace \u2713 \u2022 Waiting for datastore to be ready \u2713 \u2022 Waiting for Admin Console to be ready \u2713 \u2022 Press Ctrl+C to exit \u2022 Go to http://localhost:8800 to access the Admin Console","title":"Install the NetBox Enterprise Helm chart"},{"location":"netbox-enterprise/nbe-kots-installation/#install-netbox","text":"","title":"Install NetBox"},{"location":"netbox-enterprise/nbe-kots-requirements/","text":"NetBox Enterprise KOTS Requirements System requirements To install NetBox Enterprise on an existing cluster, the cluster must meet the following requirements: Recommended cluster requirements The following are the recommended system requirements for a production deployment of NetBox Enterprise running two replicas. For larger environments with more replicas, additional resources should be allocated. 8 Virtual CPU (vCPU) 24 GB Memory (RAM) 100 GB SSD free disk space in /var/lib Note For non-production deployments of NetBox Enterprise, the minimum system requirements can be reduced to 4 Virtual CPU (vCPU) and 16 GB Memory (RAM). All other requirements remain the same. Supported operating systems The following are the supported operating systems for nodes: Linux AMD64 Available StorageClass The cluster must have an existing StorageClass available. KOTS creates the required stateful components using the default StorageClass in the cluster. Kubernetes version compatibility KOTS installation of NetBox Enterprise is supported on most common Kubernetes clusters, running v1.27 or higher. Port forwarding To support port forwarding, Kubernetes clusters require that the SOcket CAT (socat) package is installed on each node. RBAC Requirements The user that runs the installation command must have at least the minimum role-based access control (RBAC) permissions that are required by KOTS. If the user does not have the required RBAC permissions, then an error message displays: Current user has insufficient privileges to install Admin Console . The required RBAC permissions vary depending on if the user attempts to install KOTS with cluster-scoped access or namespace-scoped access: Cluster-scoped RBAC Requirements (Default) Namespace-scoped RBAC Requirements Cluster-scoped RBAC Requirements (Default) By default, KOTS requires cluster-scoped access. With cluster-scoped access, a Kubernetes ClusterRole and ClusterRoleBinding are created that grant KOTS access to all resources across all namespaces in the cluster. To install KOTS with cluster-scoped access, the user must meet the following RBAC requirements: The user must be able to create workloads, ClusterRoles, and ClusterRoleBindings. The user must have cluster-admin permissions to create namespaces and assign RBAC roles across the cluster. Namespace-scoped RBAC Requirements KOTS can be installed with namespace-scoped access rather than the default cluster-scoped access. With namespace-scoped access, a Kubernetes Role and RoleBinding are automatically created that grant KOTS permissions only in the namespace where it is installed. Please contact us for more details.","title":"Requirements"},{"location":"netbox-enterprise/nbe-kots-requirements/#netbox-enterprise-kots-requirements","text":"","title":"NetBox Enterprise KOTS Requirements"},{"location":"netbox-enterprise/nbe-kots-requirements/#system-requirements","text":"To install NetBox Enterprise on an existing cluster, the cluster must meet the following requirements:","title":"System requirements"},{"location":"netbox-enterprise/nbe-kots-requirements/#rbac-requirements","text":"The user that runs the installation command must have at least the minimum role-based access control (RBAC) permissions that are required by KOTS. If the user does not have the required RBAC permissions, then an error message displays: Current user has insufficient privileges to install Admin Console . The required RBAC permissions vary depending on if the user attempts to install KOTS with cluster-scoped access or namespace-scoped access: Cluster-scoped RBAC Requirements (Default) Namespace-scoped RBAC Requirements","title":"RBAC Requirements"},{"location":"netbox-enterprise/nbe-overview/","text":"NetBox Enterprise Overview NetBox Enterprise is a distribution of NetBox built by NetBox Labs for organizations deploying NetBox in their own infrastructure. NetBox Enterprise users gain a simplified installation and upgrade process, as well as advanced features and integrations not available in the community editon of NetBox. Deployment models NetBox Enterprise supports two different deployment models to best address varying requirements and environments. Embedded Cluster installation The Embedded Cluster (EC) installation provides a fully managed, hands-off installation experience for installing NetBox Enterprise, including deploying and managing an underlying Kubernetes cluster. A bare Linux operating system with adequately sized compute resources is the only requirement. Embedded Cluster deployments deliver all the components and dependencies required to deploy and operate NetBox, including databases, application servers, application load balancers, and object stores. Embedded Cluster deployments still provide the flexibility of leveraging external components, such as a PostgreSQL cluster or an S3 Object Store. See the NetBox Enterprise Embedded Cluster Installation guide for more details. KOTS installation The Kubernetes Off-The-Shelf (KOTS) installation provides a more customizable installation experience of NetBox Enterprise. For organizations that are operating their own Kubernetes environments, the KOTS installation enables them to deploy NetBox in their own k8s cluster. KOTS deployments include all the necessary components and take care of all the dependencies just like the Embedded Cluster deployments. They also provide the same flexibility in leveraging external components, such as a PostgreSQL cluster or an S3 Object Store. See the NetBox Enterprise KOTS Installation guide for more details.","title":"Overview"},{"location":"netbox-enterprise/nbe-overview/#netbox-enterprise","text":"","title":"NetBox Enterprise"},{"location":"netbox-enterprise/nbe-overview/#overview","text":"NetBox Enterprise is a distribution of NetBox built by NetBox Labs for organizations deploying NetBox in their own infrastructure. NetBox Enterprise users gain a simplified installation and upgrade process, as well as advanced features and integrations not available in the community editon of NetBox.","title":"Overview"},{"location":"netbox-enterprise/nbe-overview/#deployment-models","text":"NetBox Enterprise supports two different deployment models to best address varying requirements and environments.","title":"Deployment models"},{"location":"netbox-enterprise/nbe-overview/#embedded-cluster-installation","text":"The Embedded Cluster (EC) installation provides a fully managed, hands-off installation experience for installing NetBox Enterprise, including deploying and managing an underlying Kubernetes cluster. A bare Linux operating system with adequately sized compute resources is the only requirement. Embedded Cluster deployments deliver all the components and dependencies required to deploy and operate NetBox, including databases, application servers, application load balancers, and object stores. Embedded Cluster deployments still provide the flexibility of leveraging external components, such as a PostgreSQL cluster or an S3 Object Store. See the NetBox Enterprise Embedded Cluster Installation guide for more details.","title":"Embedded Cluster installation"},{"location":"netbox-enterprise/nbe-overview/#kots-installation","text":"The Kubernetes Off-The-Shelf (KOTS) installation provides a more customizable installation experience of NetBox Enterprise. For organizations that are operating their own Kubernetes environments, the KOTS installation enables them to deploy NetBox in their own k8s cluster. KOTS deployments include all the necessary components and take care of all the dependencies just like the Embedded Cluster deployments. They also provide the same flexibility in leveraging external components, such as a PostgreSQL cluster or an S3 Object Store. See the NetBox Enterprise KOTS Installation guide for more details.","title":"KOTS installation"},{"location":"netbox-enterprise/nbe-release-notes/","text":"NetBox Enterprise 1.x Release Notes 1.4.0 Adds support for supplying custom environment variables (eg, for LDAP config). It also contains a small auth change to allow curly braces and spaces in the new password validator. A number of included plugins were updated to their latest compatible versions: * netbox_bgp was updated to 0.13.3 * netbox_floorplan_plugin was updated to 0.4.1 * netbox_plugin_dns was updated to 1.1.3 * netbox_topology_views was updated to 4.0.1 * slurpit_netbox was updated to 0.9.84 1.3.0 Compatible with any standard Kubernetes ingress controller now in KOTS installs, rather than only Nginx. Also fixes a potential data loss issue with uploaded images, as well as enabling script and report uploads. 1.2.0 Improves ingress configuration, adds support for inheriting the TLS configuration from the Embedded Cluster, and adds a \"restore mode\" for restoring manual backup data, plus many dependency updates and internal improvements. 1.1.0 Simplifies the firewall configuration necessary for installation by making sure all initialization downloads go through our proxy domain. 1.0.6 Adds support for NetBox resource usage adjustment and some improvements to startup time on a first install. It also adds support for backup and restore in the Embedded Cluster and KOTS installs, depending on your environment and license. 1.0.5 Adds support for KOTS installs to scrape Prometheus metrics from NetBox, as well as the embedded PostgreSQL, Redis, and SeaweedFS if they are enabled. Updated to support NetBox v4.0.9, and includes additional bug fixes and startup time improvements. 1.0.4 Adds OWASP password complexity validation to NetBox, and includes dependency updates. 1.0.3 Fixes issues with preflight checks, and includes minor dependency updates. 1.0.2 Provides a number of dependency updates and bug fixes, and includes initial support for backups of built-in Redis and PostgreSQL. 1.0.1 Provides bug fixes encountered during the initial rollout of the NetBox Enterprise application. 1.0.0 Provides final cleanup of the Beta stream in preparation for the wider release. Provides a number of internal changes, and includes fixes for an issue where annotations could render improperly and cause problems with upgrades. Updated to support NetBox v4.0.7.","title":"Release Notes"},{"location":"netbox-enterprise/nbe-release-notes/#netbox-enterprise-1x-release-notes","text":"","title":"NetBox Enterprise 1.x Release Notes"},{"location":"netbox-enterprise/nbe-release-notes/#140","text":"Adds support for supplying custom environment variables (eg, for LDAP config). It also contains a small auth change to allow curly braces and spaces in the new password validator. A number of included plugins were updated to their latest compatible versions: * netbox_bgp was updated to 0.13.3 * netbox_floorplan_plugin was updated to 0.4.1 * netbox_plugin_dns was updated to 1.1.3 * netbox_topology_views was updated to 4.0.1 * slurpit_netbox was updated to 0.9.84","title":"1.4.0"},{"location":"netbox-enterprise/nbe-release-notes/#130","text":"Compatible with any standard Kubernetes ingress controller now in KOTS installs, rather than only Nginx. Also fixes a potential data loss issue with uploaded images, as well as enabling script and report uploads.","title":"1.3.0"},{"location":"netbox-enterprise/nbe-release-notes/#120","text":"Improves ingress configuration, adds support for inheriting the TLS configuration from the Embedded Cluster, and adds a \"restore mode\" for restoring manual backup data, plus many dependency updates and internal improvements.","title":"1.2.0"},{"location":"netbox-enterprise/nbe-release-notes/#110","text":"Simplifies the firewall configuration necessary for installation by making sure all initialization downloads go through our proxy domain.","title":"1.1.0"},{"location":"netbox-enterprise/nbe-release-notes/#106","text":"Adds support for NetBox resource usage adjustment and some improvements to startup time on a first install. It also adds support for backup and restore in the Embedded Cluster and KOTS installs, depending on your environment and license.","title":"1.0.6"},{"location":"netbox-enterprise/nbe-release-notes/#105","text":"Adds support for KOTS installs to scrape Prometheus metrics from NetBox, as well as the embedded PostgreSQL, Redis, and SeaweedFS if they are enabled. Updated to support NetBox v4.0.9, and includes additional bug fixes and startup time improvements.","title":"1.0.5"},{"location":"netbox-enterprise/nbe-release-notes/#104","text":"Adds OWASP password complexity validation to NetBox, and includes dependency updates.","title":"1.0.4"},{"location":"netbox-enterprise/nbe-release-notes/#103","text":"Fixes issues with preflight checks, and includes minor dependency updates.","title":"1.0.3"},{"location":"netbox-enterprise/nbe-release-notes/#102","text":"Provides a number of dependency updates and bug fixes, and includes initial support for backups of built-in Redis and PostgreSQL.","title":"1.0.2"},{"location":"netbox-enterprise/nbe-release-notes/#101","text":"Provides bug fixes encountered during the initial rollout of the NetBox Enterprise application.","title":"1.0.1"},{"location":"netbox-enterprise/nbe-release-notes/#100","text":"Provides final cleanup of the Beta stream in preparation for the wider release. Provides a number of internal changes, and includes fixes for an issue where annotations could render improperly and cause problems with upgrades. Updated to support NetBox v4.0.7.","title":"1.0.0"},{"location":"netbox-enterprise/nbe-tls-ingress/","text":"TLS and Ingress: Accessing NetBox Enterprise Embedded Cluster Installs Ingress The Embedded Cluster provides its own ingress controller. No additional configuration is required to reach NetBox on HTTP and HTTPS. TLS Configuration When you first install the Embedded Cluster and log into the Admin Console, it asks you to configure the TLS certificate. By default, it will generate a self-signed certificate, but you are able to instead upload private key and certificate chain files. This key and certificate chain are used for any TLS connections to the Embedded Cluster, whether it's the Admin Console (on port 30000) or the main NetBox interface (on port 443). Key Replacement/Rotation If you configured your Admin Console to use a self-signed certificate on install and wish to replace it with your own key, or if you have an existing custom key that needs rotation, you can follow these steps to do so. Note Ensure you have your private key and a full certificate chain in PEM format. If you're using Let's Encrypt, this will be the privkeyXX.pem and fullchainXX.pem files. For other certificate providers, consult their documentation. First, access the Embedded Cluster's shell: /var/lib/embedded-cluster/bin/netbox-enterprise shell Then, delete the old secret and create the new one, providing the path to your chain and key files: kubectl -n kotsadm delete secret kotsadm-tls && \\ kubectl -n kotsadm create secret tls kotsadm-tls --cert = /path/to/cert.pem --key = /path/to/key.pem Finally, delete the proxy and ingress pods, so they relaunch with the new configuration: NGINX_POD = \" $( kubectl -n ingress-nginx get pods --selector = 'app.kubernetes.io/name=ingress-nginx' -o name ) \" PROXY_POD = \" $( kubectl -n kotsadm get pods --selector = 'app==kurl-proxy-kotsadm' -o name ) \" kubectl -n ingress-nginx delete \" ${ NGINX_POD } \" && \\ kubectl -n kotsadm delete \" ${ PROXY_POD } \" KOTS Installs Ingress Since NetBox Enterprise will be installed into an existing cluster when using a KOTS install, it is expected that ingress (and TLS configuration) will be provided by your environment. By default, NetBox Enterprise publishes an Ingress resource which is picked up automatically by a Kubernetes ingress controller. TLS As long as your ingress controller provides a TLS endpoint, there are no special changes necessary in the NetBox Enterprise configuration. For example, if you are using the ingress-nginx controller Helm chart, your NetBox instance will be available on HTTP and HTTPS if you set a default certificate like so: values.yaml controller : service : type : NodePort nodePorts : http : \"80\" https : \"443\" extraArgs : default-ssl-certificate : \"<NAMESPACE>/<SECRETNAME>\" The default-ssl-certificate line should point to the cluster location of your secret containing the certificate and key information, tagged with the type kubernetes.io/tls . For details, see the official Kubernetes documentation .","title":"TLS and Ingress"},{"location":"netbox-enterprise/nbe-tls-ingress/#tls-and-ingress-accessing-netbox-enterprise","text":"","title":"TLS and Ingress: Accessing NetBox Enterprise"},{"location":"netbox-enterprise/nbe-tls-ingress/#embedded-cluster-installs","text":"","title":"Embedded Cluster Installs"},{"location":"netbox-enterprise/nbe-tls-ingress/#ingress","text":"The Embedded Cluster provides its own ingress controller. No additional configuration is required to reach NetBox on HTTP and HTTPS.","title":"Ingress"},{"location":"netbox-enterprise/nbe-tls-ingress/#tls","text":"","title":"TLS"},{"location":"netbox-enterprise/nbe-tls-ingress/#kots-installs","text":"","title":"KOTS Installs"},{"location":"netbox-enterprise/nbe-tls-ingress/#ingress_1","text":"Since NetBox Enterprise will be installed into an existing cluster when using a KOTS install, it is expected that ingress (and TLS configuration) will be provided by your environment. By default, NetBox Enterprise publishes an Ingress resource which is picked up automatically by a Kubernetes ingress controller.","title":"Ingress"},{"location":"netbox-enterprise/nbe-tls-ingress/#tls_1","text":"As long as your ingress controller provides a TLS endpoint, there are no special changes necessary in the NetBox Enterprise configuration. For example, if you are using the ingress-nginx controller Helm chart, your NetBox instance will be available on HTTP and HTTPS if you set a default certificate like so: values.yaml controller : service : type : NodePort nodePorts : http : \"80\" https : \"443\" extraArgs : default-ssl-certificate : \"<NAMESPACE>/<SECRETNAME>\" The default-ssl-certificate line should point to the cluster location of your secret containing the certificate and key information, tagged with the type kubernetes.io/tls . For details, see the official Kubernetes documentation .","title":"TLS"},{"location":"netbox-enterprise/nbe-troubleshooting/","text":"Advanced Tools and Troubleshooting NetBox Enterprise is designed to harness the power of Kubernetes while minimizing the amount of work the average person needs to manage it. However, sometimes it's still useful or necessary to peek under the hood. Applications The following applications are used for various facets of administration: kubectl *: CLI for interacting with clusters. preflight *: CLI for manually running preflight validation checks. Install by running: curl https://krew.sh/preflight | bash support-bundle *: CLI for manually generating support bundles. Install by running: curl https://krew.sh/support-bundle | bash k9s : a TUI for managing and viewing cluster resources. * provided by the Embedded Cluster install Accessing Your Cluster from the Command Line Embedded Cluster If you are running the Embedded Cluster, you will need to first execute a command to get a shell environment that knows how to interact with it. To do this, run: /var/lib/embedded-cluster/bin/netbox-enterprise shell KOTS Install If you are running your own cluster and have installed using KOTS, make sure you have kubectl in your PATH and that it is able to access your cluster. The specifics will depend on the type of cluster and where you are accessing it from. Accessing Your Cluster from the Web Embedded Cluster On the embedded cluster, the admin console is always available at https://your-cluster-host-or-ip:30000/ KOTS Install To access the admin console in a KOTS install, run: kubectl kots admin-console --namespace netbox-enterprise This will create a port-forward into the cluster and provide you with a link to reach the console. Generating a Support Bundle Command-Line Access your cluster from the shell. If you haven't installed the support-bundle package , do so now. Run: kubectl support-bundle /var/lib/embedded-cluster/support/host-support-bundle.yaml --load-cluster-specs This will run a series of tests and provide a short summary of what it found, much like the preflights that run during install and when deploying. When complete, the TUI will display, like so: Typing s to save will save a short summary .txt file of the output you can see in the TUI. Typing q to quit will quit without saving the summary. In both cases, a .tar.gz support bundle will also be created in the current directory. This file can be used by NetBox Labs to troubleshoot your system.","title":"Advanced Tools and Troubleshooting"},{"location":"netbox-enterprise/nbe-troubleshooting/#advanced-tools-and-troubleshooting","text":"NetBox Enterprise is designed to harness the power of Kubernetes while minimizing the amount of work the average person needs to manage it. However, sometimes it's still useful or necessary to peek under the hood.","title":"Advanced Tools and Troubleshooting"},{"location":"netbox-enterprise/nbe-troubleshooting/#applications","text":"The following applications are used for various facets of administration: kubectl *: CLI for interacting with clusters. preflight *: CLI for manually running preflight validation checks. Install by running: curl https://krew.sh/preflight | bash support-bundle *: CLI for manually generating support bundles. Install by running: curl https://krew.sh/support-bundle | bash k9s : a TUI for managing and viewing cluster resources. * provided by the Embedded Cluster install","title":"Applications"},{"location":"netbox-enterprise/nbe-troubleshooting/#accessing-your-cluster-from-the-command-line","text":"","title":"Accessing Your Cluster from the Command Line"},{"location":"netbox-enterprise/nbe-troubleshooting/#embedded-cluster","text":"If you are running the Embedded Cluster, you will need to first execute a command to get a shell environment that knows how to interact with it. To do this, run: /var/lib/embedded-cluster/bin/netbox-enterprise shell","title":"Embedded Cluster"},{"location":"netbox-enterprise/nbe-troubleshooting/#kots-install","text":"If you are running your own cluster and have installed using KOTS, make sure you have kubectl in your PATH and that it is able to access your cluster. The specifics will depend on the type of cluster and where you are accessing it from.","title":"KOTS Install"},{"location":"netbox-enterprise/nbe-troubleshooting/#accessing-your-cluster-from-the-web","text":"","title":"Accessing Your Cluster from the Web"},{"location":"netbox-enterprise/nbe-troubleshooting/#embedded-cluster_1","text":"On the embedded cluster, the admin console is always available at https://your-cluster-host-or-ip:30000/","title":"Embedded Cluster"},{"location":"netbox-enterprise/nbe-troubleshooting/#kots-install_1","text":"To access the admin console in a KOTS install, run: kubectl kots admin-console --namespace netbox-enterprise This will create a port-forward into the cluster and provide you with a link to reach the console.","title":"KOTS Install"},{"location":"netbox-enterprise/nbe-troubleshooting/#generating-a-support-bundle","text":"","title":"Generating a Support Bundle"},{"location":"netbox-enterprise/nbe-troubleshooting/#command-line","text":"Access your cluster from the shell. If you haven't installed the support-bundle package , do so now. Run: kubectl support-bundle /var/lib/embedded-cluster/support/host-support-bundle.yaml --load-cluster-specs This will run a series of tests and provide a short summary of what it found, much like the preflights that run during install and when deploying. When complete, the TUI will display, like so: Typing s to save will save a short summary .txt file of the output you can see in the TUI. Typing q to quit will quit without saving the summary. In both cases, a .tar.gz support bundle will also be created in the current directory. This file can be used by NetBox Labs to troubleshoot your system.","title":"Command-Line"},{"location":"netbox-extensions/branching/","text":"NetBox Branching NetBox is the world's leading source of truth for network infrastructure, featuring an extensive and complex data model. But sometimes it can be challenging to orchestrate changes, especially when working within a large team. This plugin introduces a new paradigm for NetBox to help overcome these challenges: branching. If you're familiar with git or similar version control systems, the concept of branching should be familiar. Essentially, this plugin allows you to make copies of NetBox's data model and alter them independently. Your changes will be reflected only within the branch you're working on, until you decide to merge your branch into the main data model. This allows you and your colleagues to stage changes within isolated environments and avoid interfering with one another's work or pushing changes to the network prematurely. Each branch can be synchronized as needed to keep up to date with external changes, and merged when needed. Features Users can create new branches and switch between them seamlessly while navigating the web UI. Each branch exists in isolation from its peers: Changes made within one branch won't affect any other branches. Standard NetBox permissions are employed to control which users can perform branch operations. Branches can be created, synchronized, merged, reverted, and deleted through the REST API. No external dependencies! This plugin requires only NetBox v4.1 or later and a conventional PostgreSQL database (v12.0 or later). Terminology Main is shorthand for the primary NetBox state. Any changes made outside the context of a specific branch are made here. The creation, modification, or deletion of an object is a change . A branch is an independent copy of the NetBox data model which diverges from main at a set point in time. Any changes to main after that time will not be reflected in the branch. Likewise, changes made within the branch will not be reflected in main. Branches are provisioned automatically upon creation. The initial state of a branch is identical to the state of main at the time it was provisioned. Changes in main can be synchronized at any time into a branch. Branches are independent of one another: Changes must be synchronized into each branch individually. This ensures complete isolation among branches. Once the work within a branch has been completed, it can be merged into main. Once a branch has been merged, it is generally no longer used. Merged changes can be reverted provided the branch has not yet been deleted. This effectively replays the changes in reverse order to undo the relevant changes. Workflow The first step is to create a new branch . Upon creation, a background job is automatically queued to provision a dedicated PostgreSQL schema for the branch. When provisioning is complete, the branch's status is updated to \"ready.\" Users can now activate the branch and begin making changes within it. These changes will be contained to the branch, and will not impact main. Likewise, any changes to main will not be reflected in the branch until it has been synchronized by a user. A branch may be synchronized repeatedly to keep it up to date with main over time. Once work in the branch has been completed, it can be merged into main. sequenceDiagram actor User B participant Main participant Branch actor User A Main->>Branch: Provision new branch User A->>Branch: Make changes User B->>Main: Make unrelated changes Main->>Branch: Synchronize changes User A->>Branch: Make more changes Branch->>Main: Merge branch In the event a branch should not have been merged, it can be reverted. Previously merged changes to main will be unwound and the branch will be restored to its pre-merge state. The branch is again marked as ready for additional changes, if needed, and can be merged again. sequenceDiagram participant Main participant Branch actor User A Main->>Branch: Provision new branch User A->>Branch: Make changes Branch->>Main: Merge branch Note left of Main: Error detected! Main->>Branch: Revert changes User A->>Branch: Correct error Branch->>Main: Merge branch Getting Started Database Preparation Before installing this plugin, ensure that the PostgreSQL user as which NetBox authenticates has permission to create new schemas in the database. This can be achieved by issuing the following command in the PostgreSQL shell (substituting $database and $user with their respective values): GRANT CREATE ON DATABASE $ database TO $ user ; Plugin Installation 1. Virtual Environment The plugin can be installed from PyPI . First, activate the Python virtual environment used by NetBox (which is typically located at /opt/netbox/venv/ ): source /opt/netbox/venv/bin/activate Note You may need to modify the source command above if your virtual environment has been installed in a different location. 2. Python Package Use pip to install the Python package: pip install netboxlabs-netbox-branching 3. Enable Plugin Add netbox_branching to the end of the PLUGINS list in configuration.py . PLUGINS = [ # ... 'netbox_branching' , ] Warning netbox_branching must be the last (or only) plugin in the list. Branching support will not be registered for models provided by any plugin appearing later in the list. Note If there are no plugins already installed, you might need to create this parameter. If so, be sure to define PLUGINS as a list containing the plugin name as above, rather than just the name. 4. Configuration This plugin employs dynamic schema resolution, which requires that we override two low-level Django settings. First, we'll wrap NetBox's configured DATABASE parameter with DynamicSchemaDict to support dynamic schemas. Second, we'll employ the plugin's custom database router. Create a new file named local_settings.py in the same directory as settings.py , and add the content below. from netbox_branching.utilities import DynamicSchemaDict from .configuration import DATABASE # Wrap DATABASES with DynamicSchemaDict for dynamic schema support DATABASES = DynamicSchemaDict ({ 'default' : DATABASE , }) # Employ our custom database router DATABASE_ROUTERS = [ 'netbox_branching.database.BranchAwareRouter' , ] 5. Database Migrations Run the included database migrations: cd /opt/netbox/netbox ./manage.py migrate Known Limitations There are currently a few limitations to the functionality provided by this plugin that are worth highlighting. We hope to address these in future releases. Branches may not persist across minor version upgrades of NetBox. Users are strongly encouraged to merge or remove all open branches prior to upgrading to a new minor release of NetBox (e.g. from v4.1 to v4.2). This is because database migrations introduced by the upgrade will not be applied to branch schemas, potentially resulting in an invalid state. However, it should be considered safe to upgrade to new patch releases (e.g. v4.1.0 to v4.1.1) with open branches. Open branches will not reflect newly installed plugins. Any branches created before installing a new plugin will not be updated to support its models. Note, however, that installing a new plugin will generally not impede the use of existing branches. Users are encouraged to install all necessary plugins prior to creating branches. (This also applies to database migrations introduced by upgrading a plugin.)","title":"Overview"},{"location":"netbox-extensions/branching/#netbox-branching","text":"NetBox is the world's leading source of truth for network infrastructure, featuring an extensive and complex data model. But sometimes it can be challenging to orchestrate changes, especially when working within a large team. This plugin introduces a new paradigm for NetBox to help overcome these challenges: branching. If you're familiar with git or similar version control systems, the concept of branching should be familiar. Essentially, this plugin allows you to make copies of NetBox's data model and alter them independently. Your changes will be reflected only within the branch you're working on, until you decide to merge your branch into the main data model. This allows you and your colleagues to stage changes within isolated environments and avoid interfering with one another's work or pushing changes to the network prematurely. Each branch can be synchronized as needed to keep up to date with external changes, and merged when needed.","title":"NetBox Branching"},{"location":"netbox-extensions/branching/#features","text":"Users can create new branches and switch between them seamlessly while navigating the web UI. Each branch exists in isolation from its peers: Changes made within one branch won't affect any other branches. Standard NetBox permissions are employed to control which users can perform branch operations. Branches can be created, synchronized, merged, reverted, and deleted through the REST API. No external dependencies! This plugin requires only NetBox v4.1 or later and a conventional PostgreSQL database (v12.0 or later).","title":"Features"},{"location":"netbox-extensions/branching/#terminology","text":"Main is shorthand for the primary NetBox state. Any changes made outside the context of a specific branch are made here. The creation, modification, or deletion of an object is a change . A branch is an independent copy of the NetBox data model which diverges from main at a set point in time. Any changes to main after that time will not be reflected in the branch. Likewise, changes made within the branch will not be reflected in main. Branches are provisioned automatically upon creation. The initial state of a branch is identical to the state of main at the time it was provisioned. Changes in main can be synchronized at any time into a branch. Branches are independent of one another: Changes must be synchronized into each branch individually. This ensures complete isolation among branches. Once the work within a branch has been completed, it can be merged into main. Once a branch has been merged, it is generally no longer used. Merged changes can be reverted provided the branch has not yet been deleted. This effectively replays the changes in reverse order to undo the relevant changes.","title":"Terminology"},{"location":"netbox-extensions/branching/#workflow","text":"The first step is to create a new branch . Upon creation, a background job is automatically queued to provision a dedicated PostgreSQL schema for the branch. When provisioning is complete, the branch's status is updated to \"ready.\" Users can now activate the branch and begin making changes within it. These changes will be contained to the branch, and will not impact main. Likewise, any changes to main will not be reflected in the branch until it has been synchronized by a user. A branch may be synchronized repeatedly to keep it up to date with main over time. Once work in the branch has been completed, it can be merged into main. sequenceDiagram actor User B participant Main participant Branch actor User A Main->>Branch: Provision new branch User A->>Branch: Make changes User B->>Main: Make unrelated changes Main->>Branch: Synchronize changes User A->>Branch: Make more changes Branch->>Main: Merge branch In the event a branch should not have been merged, it can be reverted. Previously merged changes to main will be unwound and the branch will be restored to its pre-merge state. The branch is again marked as ready for additional changes, if needed, and can be merged again. sequenceDiagram participant Main participant Branch actor User A Main->>Branch: Provision new branch User A->>Branch: Make changes Branch->>Main: Merge branch Note left of Main: Error detected! Main->>Branch: Revert changes User A->>Branch: Correct error Branch->>Main: Merge branch","title":"Workflow"},{"location":"netbox-extensions/branching/#getting-started","text":"","title":"Getting Started"},{"location":"netbox-extensions/branching/#database-preparation","text":"Before installing this plugin, ensure that the PostgreSQL user as which NetBox authenticates has permission to create new schemas in the database. This can be achieved by issuing the following command in the PostgreSQL shell (substituting $database and $user with their respective values): GRANT CREATE ON DATABASE $ database TO $ user ;","title":"Database Preparation"},{"location":"netbox-extensions/branching/#plugin-installation","text":"","title":"Plugin Installation"},{"location":"netbox-extensions/branching/#known-limitations","text":"There are currently a few limitations to the functionality provided by this plugin that are worth highlighting. We hope to address these in future releases. Branches may not persist across minor version upgrades of NetBox. Users are strongly encouraged to merge or remove all open branches prior to upgrading to a new minor release of NetBox (e.g. from v4.1 to v4.2). This is because database migrations introduced by the upgrade will not be applied to branch schemas, potentially resulting in an invalid state. However, it should be considered safe to upgrade to new patch releases (e.g. v4.1.0 to v4.1.1) with open branches. Open branches will not reflect newly installed plugins. Any branches created before installing a new plugin will not be updated to support its models. Note, however, that installing a new plugin will generally not impede the use of existing branches. Users are encouraged to install all necessary plugins prior to creating branches. (This also applies to database migrations introduced by upgrading a plugin.)","title":"Known Limitations"},{"location":"netbox-extensions/branching/changelog/","text":"Change Log v0.5.2 Bug Fixes #163 - Ensure changelog records for non-branching models are created in main schema v0.5.1 Enhancements #123 - Introduce template tags for branch action buttons #129 - Implement pre-event signals for branch actions Bug Fixes #98 - Cable changes in branch should not impact main schema #119 - Fix the dynamic selection of related objects in forms while a branch is active #120 - max_branches config parameter should disregard archived branches #138 - Fix rendering the ID column of the change diffs table #140 - Fix representation of branch status in REST API #142 - Fix tab record counts for archived branches v0.5.0 Enhancements #83 - Add a \"share\" button under object views when a branch is active #84 - Introduce the max_working_branches configuration parameter #88 - Add branching support for NetBox's graphQL API #90 - Introduce the ability to archive & deprovision merged branches without deleting them #97 - Introduce the exempt_models config parameter to disable branching support for plugin models #116 - Disable branching support for applicable core models Bug Fixes #81 - Fix event rule triggering for the branch_reverted event #91 - Disregard the active branch (if any) when alerting on changes under object views #94 - Fix branch merging after modifying an object with custom field data #101 - Permit (but warn about) database queries issued before branching support has been initialized #102 - Record individual object actions in branch job logs v0.4.0 Enhancements #52 - Introduce the max_branches config parameter #71 - Ensure the consistent application of logging messages #76 - Validate required configuration items on initialization Bug Fixes #57 - Avoid recording ChangeDiff records for unsupported object types #59 - BranchAwareRouter should consider branching support for model when determining database connection to use #61 - Fix transaction rollback when performing a dry run sync #66 - Capture object representation on ChangeDiff when creating a new object within a branch #69 - Represent null values for ChangeDiff fields consistently in REST API #73 - Ensure all relevant branch diffs are updated when an object is modified in main v0.3.1 Bug Fixes #42 - Fix exception raised when viewing custom scripts #44 - Handle truncated SQL sequence names to avoid exceptions during branch provisioning #48 - Ensure background job is terminated in the event branch provisioning errors #50 - Branch state should remain as \"merged\" after dry-run revert v0.3.0 Enhancements #2 - Enable the ability to revert a previously merged branch #3 - Require review & acknowledgment of conflicts before syncing or merging a branch #4 - Include a three-way diff summary in the REST API representation of a modified object #13 - Add a link to the active branch in the branch selector dropdown #15 - Default to performing a \"dry run\" for branch sync & merge #17 - Utilize NetBox's JobRunner class for background jobs #29 - Register a branch column on NetBox's global changelog table #36 - Run the branch provisioning process within an isolated transaction Bug Fixes #10 - Fix branch merge failure when deleted object was modified in another branch #11 - Fix quick search functionality for branch diffs tab #16 - Fix support for many-to-many assignments #24 - Correct the REST API schema for the sync, merge, and revert branch endpoints #30 - Include only unmerged branches with relevant changes in object view notifications #31 - Prevent the deletion of a branch in a transitional state v0.2.0 Initial private release","title":"Changelog"},{"location":"netbox-extensions/branching/changelog/#change-log","text":"","title":"Change Log"},{"location":"netbox-extensions/branching/changelog/#v052","text":"","title":"v0.5.2"},{"location":"netbox-extensions/branching/changelog/#bug-fixes","text":"#163 - Ensure changelog records for non-branching models are created in main schema","title":"Bug Fixes"},{"location":"netbox-extensions/branching/changelog/#v051","text":"","title":"v0.5.1"},{"location":"netbox-extensions/branching/changelog/#enhancements","text":"#123 - Introduce template tags for branch action buttons #129 - Implement pre-event signals for branch actions","title":"Enhancements"},{"location":"netbox-extensions/branching/changelog/#bug-fixes_1","text":"#98 - Cable changes in branch should not impact main schema #119 - Fix the dynamic selection of related objects in forms while a branch is active #120 - max_branches config parameter should disregard archived branches #138 - Fix rendering the ID column of the change diffs table #140 - Fix representation of branch status in REST API #142 - Fix tab record counts for archived branches","title":"Bug Fixes"},{"location":"netbox-extensions/branching/changelog/#v050","text":"","title":"v0.5.0"},{"location":"netbox-extensions/branching/changelog/#enhancements_1","text":"#83 - Add a \"share\" button under object views when a branch is active #84 - Introduce the max_working_branches configuration parameter #88 - Add branching support for NetBox's graphQL API #90 - Introduce the ability to archive & deprovision merged branches without deleting them #97 - Introduce the exempt_models config parameter to disable branching support for plugin models #116 - Disable branching support for applicable core models","title":"Enhancements"},{"location":"netbox-extensions/branching/changelog/#bug-fixes_2","text":"#81 - Fix event rule triggering for the branch_reverted event #91 - Disregard the active branch (if any) when alerting on changes under object views #94 - Fix branch merging after modifying an object with custom field data #101 - Permit (but warn about) database queries issued before branching support has been initialized #102 - Record individual object actions in branch job logs","title":"Bug Fixes"},{"location":"netbox-extensions/branching/changelog/#v040","text":"","title":"v0.4.0"},{"location":"netbox-extensions/branching/changelog/#enhancements_2","text":"#52 - Introduce the max_branches config parameter #71 - Ensure the consistent application of logging messages #76 - Validate required configuration items on initialization","title":"Enhancements"},{"location":"netbox-extensions/branching/changelog/#bug-fixes_3","text":"#57 - Avoid recording ChangeDiff records for unsupported object types #59 - BranchAwareRouter should consider branching support for model when determining database connection to use #61 - Fix transaction rollback when performing a dry run sync #66 - Capture object representation on ChangeDiff when creating a new object within a branch #69 - Represent null values for ChangeDiff fields consistently in REST API #73 - Ensure all relevant branch diffs are updated when an object is modified in main","title":"Bug Fixes"},{"location":"netbox-extensions/branching/changelog/#v031","text":"","title":"v0.3.1"},{"location":"netbox-extensions/branching/changelog/#bug-fixes_4","text":"#42 - Fix exception raised when viewing custom scripts #44 - Handle truncated SQL sequence names to avoid exceptions during branch provisioning #48 - Ensure background job is terminated in the event branch provisioning errors #50 - Branch state should remain as \"merged\" after dry-run revert","title":"Bug Fixes"},{"location":"netbox-extensions/branching/changelog/#v030","text":"","title":"v0.3.0"},{"location":"netbox-extensions/branching/changelog/#enhancements_3","text":"#2 - Enable the ability to revert a previously merged branch #3 - Require review & acknowledgment of conflicts before syncing or merging a branch #4 - Include a three-way diff summary in the REST API representation of a modified object #13 - Add a link to the active branch in the branch selector dropdown #15 - Default to performing a \"dry run\" for branch sync & merge #17 - Utilize NetBox's JobRunner class for background jobs #29 - Register a branch column on NetBox's global changelog table #36 - Run the branch provisioning process within an isolated transaction","title":"Enhancements"},{"location":"netbox-extensions/branching/changelog/#bug-fixes_5","text":"#10 - Fix branch merge failure when deleted object was modified in another branch #11 - Fix quick search functionality for branch diffs tab #16 - Fix support for many-to-many assignments #24 - Correct the REST API schema for the sync, merge, and revert branch endpoints #30 - Include only unmerged branches with relevant changes in object view notifications #31 - Prevent the deletion of a branch in a transitional state","title":"Bug Fixes"},{"location":"netbox-extensions/branching/changelog/#v020","text":"Initial private release","title":"v0.2.0"},{"location":"netbox-extensions/branching/configuration/","text":"Configuration Parameters exempt_models Default: [] (empty list) A list of models provided by other plugins which should be exempt from branching support. (Only models which support change logging need be listed; all other models are ineligible for branching support.) Warning A model may not be exempted from branching support if it has one or more relationships to models for which branching is supported. Branching must be supported consistently for all inter-related models; otherwise, data corruption can occur. Configure this setting only if you have a specific need to disable branching for certain models provided by plugins. Models must be specified by app label and model name, as such: exempt_models = ( 'my_plugin.foo' , 'my_plugin.bar' , ) It is also possible to exclude all models from within a plugin by substituting an asterisk ( * ) for the model name: exempt_models = ( 'my_plugin.*' , ) max_working_branches Default: None The maximum number of operational branches that can exist simultaneously. This count excludes branches which have been merged or archived. max_branches Default: None The maximum total number of branches that can exist simultaneously, including merged branches that have not been deleted. It may be desirable to limit the total number of provisioned branches to safeguard against excessive database size. schema_prefix Default: branch_ The string to prefix to the unique branch ID when provisioning the PostgreSQL schema for a branch. Per the PostgreSQL documentation , this string must begin with a letter or underscore. Note that a valid prefix is required, as the randomly-generated branch ID alone may begin with a digit, which would not qualify as a valid schema name.","title":"Configuration"},{"location":"netbox-extensions/branching/configuration/#configuration-parameters","text":"","title":"Configuration Parameters"},{"location":"netbox-extensions/branching/configuration/#exempt_models","text":"Default: [] (empty list) A list of models provided by other plugins which should be exempt from branching support. (Only models which support change logging need be listed; all other models are ineligible for branching support.) Warning A model may not be exempted from branching support if it has one or more relationships to models for which branching is supported. Branching must be supported consistently for all inter-related models; otherwise, data corruption can occur. Configure this setting only if you have a specific need to disable branching for certain models provided by plugins. Models must be specified by app label and model name, as such: exempt_models = ( 'my_plugin.foo' , 'my_plugin.bar' , ) It is also possible to exclude all models from within a plugin by substituting an asterisk ( * ) for the model name: exempt_models = ( 'my_plugin.*' , )","title":"exempt_models"},{"location":"netbox-extensions/branching/configuration/#max_working_branches","text":"Default: None The maximum number of operational branches that can exist simultaneously. This count excludes branches which have been merged or archived.","title":"max_working_branches"},{"location":"netbox-extensions/branching/configuration/#max_branches","text":"Default: None The maximum total number of branches that can exist simultaneously, including merged branches that have not been deleted. It may be desirable to limit the total number of provisioned branches to safeguard against excessive database size.","title":"max_branches"},{"location":"netbox-extensions/branching/configuration/#schema_prefix","text":"Default: branch_ The string to prefix to the unique branch ID when provisioning the PostgreSQL schema for a branch. Per the PostgreSQL documentation , this string must begin with a letter or underscore. Note that a valid prefix is required, as the randomly-generated branch ID alone may begin with a digit, which would not qualify as a valid schema name.","title":"schema_prefix"},{"location":"netbox-extensions/branching/rest-api/","text":"Using the REST API This plugin includes support for activating and deactivating branches via the REST API in addition to conventional creation, modification, and deletion operations. API Token Required You'll need a valid NetBox REST API token to follow any of the examples shown here. API tokens can be provisioned by navigating to the API tokens list in the user menu. Creating a Branch Branches are created in a manner similar to most objects in NetBox. A POST request (including a valid authentication token) is sent to the branches/ API endpoint with the desired attributes, such as name and description: Request curl -X POST \\ -H \"Authorization: Token $TOKEN\" \\ -H \"Content-Type: application/json\" \\ -H \"Accept: application/json; indent=4\" \\ http://netbox:8000/api/plugins/branching/branches/ \\ --data '{\"name\": \"Branch 1\", \"description\": \"My new branch\"}' Response { \"id\" : 2 , \"url\" : \"http://netbox:8000/api/plugins/branching/branches/2/\" , \"display\" : \"Branch 1\" , \"name\" : \"Branch 1\" , \"status\" : \"new\" , \"owner\" : { \"id\" : 1 , \"url\" : \"http://netbox:8000/api/users/users/1/\" , \"display\" : \"admin\" , \"username\" : \"admin\" }, \"description\" : \"My new branch\" , \"schema_id\" : \"td5smq0f\" , \"last_sync\" : null , \"merged_time\" : null , \"merged_by\" : null , \"comments\" : \"\" , \"tags\" : [], \"custom_fields\" : {}, \"created\" : \"2024-08-12T17:07:46.196956Z\" , \"last_updated\" : \"2024-08-12T17:07:46.196970Z\" } Once a new branch has been created, it will be provisioned automatically, just as when one is created via the web UI. The branch's status will show \"ready\" when provisioning has completed. Once provisioned, branches can be modified and deleted via the /api/plugins/branching/branches/<id>/ endpoint, similar to most objects in NetBox. Activating a Branch Unlike the web UI, where a user's selected branch remains active until it is changed, the desired branch must be specified with each REST API request. This is accomplished by including the X-NetBox-Branch HTTP header specifying the branch's schema ID. X-NetBox-Branch: $SCHEMA_ID Schema IDs The schema ID for a branch can be found in its REST API representation or on its detail view in the web UI. This is a pseudorandom eight-character alphanumeric identifier generated automatically when a branch is created. Note that the value passed to the HTTP header does not include the branch_ prefix, which comprises part of the schema's name in the underlying database. The example below returns all site objects that exist within the branch with schema ID td5smq0f : Request curl -X POST \\ -H \"Authorization: Token $TOKEN\" \\ -H \"Content-Type: application/json\" \\ -H \"Accept: application/json; indent=4\" \\ -H \"X-NetBox-Branch: td5smq0f\" \\ http://netbox:8000/api/dcim/sites/ The branch is effectively \"deactivated\" for future API requests by simply omitting the header. Note The X-NetBox-Branch header is required only when making changes to NetBox objects within the context of an active branch. It is not required when creating, modifying, or deleting a branch itself. Syncing & Merging Branches Several REST API endpoints are provided to handle synchronizing, merging, and reverting branches: Endpoint Description /api/plugins/branching/branches/<id>/sync/ Synchronize changes from main to the branch /api/plugins/branching/branches/<id>/merge/ Merge a branch into main /api/plugins/branching/branches/<id>/revert/ Revert a previously merged branch To synchronize updates from main into a branch, send a POST request to the desired branch's sync/ endpoint. This endpoint requires a commit argument: Setting this to false effects a dry-run, where the changes to the branch are automatically rolled back at the end of the job. (This can be helpful to check for potential errors before committing to a set of changes.) Request curl -X POST \\ -H \"Authorization: Token $TOKEN\" \\ -H \"Content-Type: application/json\" \\ -H \"Accept: application/json; indent=4\" \\ http://netbox:8000/api/plugins/branching/branches/2/sync/ \\ --data '{\"commit\": true}' If successful, this will return data about the background job that has been enqueued to handle the synchronization of data. This job can be queried to determine the progress of the synchronization. Response { \"id\" : 4 , \"url\" : \"http://netbox:8000/api/core/jobs/4/\" , \"display_url\" : \"http://netbox:8000/core/jobs/4/\" , \"display\" : \"f0c6dea2-d5bb-4683-851e-2ac705510af4\" , \"object_type\" : \"netbox_branching.branch\" , \"object_id\" : 2 , \"name\" : \"Sync branch\" , \"status\" : { \"value\" : \"pending\" , \"label\" : \"Pending\" }, \"created\" : \"2024-08-12T17:27:57.448405Z\" , \"scheduled\" : null , \"interval\" : null , \"started\" : null , \"completed\" : null , \"user\" : { \"id\" : 1 , \"url\" : \"http://netbox:8000/api/users/users/1/\" , \"display\" : \"admin\" , \"username\" : \"admin\" }, \"data\" : null , \"error\" : \"\" , \"job_id\" : \"f0c6dea2-d5bb-4683-851e-2ac705510af4\" } This same pattern can be followed to merge and revert branches via their respective API endpoints, listed above.","title":"Using the REST API"},{"location":"netbox-extensions/branching/rest-api/#using-the-rest-api","text":"This plugin includes support for activating and deactivating branches via the REST API in addition to conventional creation, modification, and deletion operations. API Token Required You'll need a valid NetBox REST API token to follow any of the examples shown here. API tokens can be provisioned by navigating to the API tokens list in the user menu.","title":"Using the REST API"},{"location":"netbox-extensions/branching/rest-api/#creating-a-branch","text":"Branches are created in a manner similar to most objects in NetBox. A POST request (including a valid authentication token) is sent to the branches/ API endpoint with the desired attributes, such as name and description: Request curl -X POST \\ -H \"Authorization: Token $TOKEN\" \\ -H \"Content-Type: application/json\" \\ -H \"Accept: application/json; indent=4\" \\ http://netbox:8000/api/plugins/branching/branches/ \\ --data '{\"name\": \"Branch 1\", \"description\": \"My new branch\"}' Response { \"id\" : 2 , \"url\" : \"http://netbox:8000/api/plugins/branching/branches/2/\" , \"display\" : \"Branch 1\" , \"name\" : \"Branch 1\" , \"status\" : \"new\" , \"owner\" : { \"id\" : 1 , \"url\" : \"http://netbox:8000/api/users/users/1/\" , \"display\" : \"admin\" , \"username\" : \"admin\" }, \"description\" : \"My new branch\" , \"schema_id\" : \"td5smq0f\" , \"last_sync\" : null , \"merged_time\" : null , \"merged_by\" : null , \"comments\" : \"\" , \"tags\" : [], \"custom_fields\" : {}, \"created\" : \"2024-08-12T17:07:46.196956Z\" , \"last_updated\" : \"2024-08-12T17:07:46.196970Z\" } Once a new branch has been created, it will be provisioned automatically, just as when one is created via the web UI. The branch's status will show \"ready\" when provisioning has completed. Once provisioned, branches can be modified and deleted via the /api/plugins/branching/branches/<id>/ endpoint, similar to most objects in NetBox.","title":"Creating a Branch"},{"location":"netbox-extensions/branching/rest-api/#activating-a-branch","text":"Unlike the web UI, where a user's selected branch remains active until it is changed, the desired branch must be specified with each REST API request. This is accomplished by including the X-NetBox-Branch HTTP header specifying the branch's schema ID. X-NetBox-Branch: $SCHEMA_ID Schema IDs The schema ID for a branch can be found in its REST API representation or on its detail view in the web UI. This is a pseudorandom eight-character alphanumeric identifier generated automatically when a branch is created. Note that the value passed to the HTTP header does not include the branch_ prefix, which comprises part of the schema's name in the underlying database. The example below returns all site objects that exist within the branch with schema ID td5smq0f : Request curl -X POST \\ -H \"Authorization: Token $TOKEN\" \\ -H \"Content-Type: application/json\" \\ -H \"Accept: application/json; indent=4\" \\ -H \"X-NetBox-Branch: td5smq0f\" \\ http://netbox:8000/api/dcim/sites/ The branch is effectively \"deactivated\" for future API requests by simply omitting the header. Note The X-NetBox-Branch header is required only when making changes to NetBox objects within the context of an active branch. It is not required when creating, modifying, or deleting a branch itself.","title":"Activating a Branch"},{"location":"netbox-extensions/branching/rest-api/#syncing-merging-branches","text":"Several REST API endpoints are provided to handle synchronizing, merging, and reverting branches: Endpoint Description /api/plugins/branching/branches/<id>/sync/ Synchronize changes from main to the branch /api/plugins/branching/branches/<id>/merge/ Merge a branch into main /api/plugins/branching/branches/<id>/revert/ Revert a previously merged branch To synchronize updates from main into a branch, send a POST request to the desired branch's sync/ endpoint. This endpoint requires a commit argument: Setting this to false effects a dry-run, where the changes to the branch are automatically rolled back at the end of the job. (This can be helpful to check for potential errors before committing to a set of changes.) Request curl -X POST \\ -H \"Authorization: Token $TOKEN\" \\ -H \"Content-Type: application/json\" \\ -H \"Accept: application/json; indent=4\" \\ http://netbox:8000/api/plugins/branching/branches/2/sync/ \\ --data '{\"commit\": true}' If successful, this will return data about the background job that has been enqueued to handle the synchronization of data. This job can be queried to determine the progress of the synchronization. Response { \"id\" : 4 , \"url\" : \"http://netbox:8000/api/core/jobs/4/\" , \"display_url\" : \"http://netbox:8000/core/jobs/4/\" , \"display\" : \"f0c6dea2-d5bb-4683-851e-2ac705510af4\" , \"object_type\" : \"netbox_branching.branch\" , \"object_id\" : 2 , \"name\" : \"Sync branch\" , \"status\" : { \"value\" : \"pending\" , \"label\" : \"Pending\" }, \"created\" : \"2024-08-12T17:27:57.448405Z\" , \"scheduled\" : null , \"interval\" : null , \"started\" : null , \"completed\" : null , \"user\" : { \"id\" : 1 , \"url\" : \"http://netbox:8000/api/users/users/1/\" , \"display\" : \"admin\" , \"username\" : \"admin\" }, \"data\" : null , \"error\" : \"\" , \"job_id\" : \"f0c6dea2-d5bb-4683-851e-2ac705510af4\" } This same pattern can be followed to merge and revert branches via their respective API endpoints, listed above.","title":"Syncing &amp; Merging Branches"},{"location":"netbox-extensions/branching/models/branch/","text":"Branches A branch represents a divergent state from the main database. Fields Name The branch's unique name. Owner The NetBox user who created the branch. Schema ID The unique, randomly-generated identifier of the PostgreSQL schema which houses the branch in the database. Status The current status of the branch. This must be one of the following values. Status Description New Not yet provisioned in the database Provisioning A job is running to provision the branch's PostgreSQL schema Ready The branch is healthy and ready to be synchronized or merged Syncing A job is running to synchronize changes from main into the branch Merging A job is running to merge changes from the branch into main Reverting A job is running to revert previously merged changes in main Merged Changes from this branch have been successfully merged into main Archived A merged branch which has been deprovisioned in the database Failed Provisioning the schema for this branch has failed Last Sync The time at which this branch was most recently synchronized with main. This value will be null if the branch has never been synchronized. Tip Reference the synced_time attribute on a branch to return either the branch's last_sync time or, if null, its creation time. Merged Time The time at which the branch was merged into main. This value will be null if the branch has not been merged. Merged By The NetBox user who merged the branch. This value will be null if the branch has not been merged.","title":"Branches"},{"location":"netbox-extensions/branching/models/branch/#branches","text":"A branch represents a divergent state from the main database.","title":"Branches"},{"location":"netbox-extensions/branching/models/branch/#fields","text":"","title":"Fields"},{"location":"netbox-extensions/branching/models/branch/#name","text":"The branch's unique name.","title":"Name"},{"location":"netbox-extensions/branching/models/branch/#owner","text":"The NetBox user who created the branch.","title":"Owner"},{"location":"netbox-extensions/branching/models/branch/#schema-id","text":"The unique, randomly-generated identifier of the PostgreSQL schema which houses the branch in the database.","title":"Schema ID"},{"location":"netbox-extensions/branching/models/branch/#status","text":"The current status of the branch. This must be one of the following values. Status Description New Not yet provisioned in the database Provisioning A job is running to provision the branch's PostgreSQL schema Ready The branch is healthy and ready to be synchronized or merged Syncing A job is running to synchronize changes from main into the branch Merging A job is running to merge changes from the branch into main Reverting A job is running to revert previously merged changes in main Merged Changes from this branch have been successfully merged into main Archived A merged branch which has been deprovisioned in the database Failed Provisioning the schema for this branch has failed","title":"Status"},{"location":"netbox-extensions/branching/models/branch/#last-sync","text":"The time at which this branch was most recently synchronized with main. This value will be null if the branch has never been synchronized. Tip Reference the synced_time attribute on a branch to return either the branch's last_sync time or, if null, its creation time.","title":"Last Sync"},{"location":"netbox-extensions/branching/models/branch/#merged-time","text":"The time at which the branch was merged into main. This value will be null if the branch has not been merged.","title":"Merged Time"},{"location":"netbox-extensions/branching/models/branch/#merged-by","text":"The NetBox user who merged the branch. This value will be null if the branch has not been merged.","title":"Merged By"},{"location":"netbox-extensions/branching/models/branchevent/","text":"Branch Events Branch operations, such as syncing and merging, are tracked as events. This record of events serves as a history for each branch. Fields Time The time at which the event occurred. Branch The branch to which this event pertains. User The NetBox user responsible for triggering this event. This field may be null if the event was triggered by an internal process. Type The type of event. This must be one of the following: Type Description Provisioned The branch's schema was provisioned in the database Synced Changes from main were synchronized into the branch Merged Changes from the branch were merged into main Reverted Previously merged changes were reverted","title":"Branch Events"},{"location":"netbox-extensions/branching/models/branchevent/#branch-events","text":"Branch operations, such as syncing and merging, are tracked as events. This record of events serves as a history for each branch.","title":"Branch Events"},{"location":"netbox-extensions/branching/models/branchevent/#fields","text":"","title":"Fields"},{"location":"netbox-extensions/branching/models/branchevent/#time","text":"The time at which the event occurred.","title":"Time"},{"location":"netbox-extensions/branching/models/branchevent/#branch","text":"The branch to which this event pertains.","title":"Branch"},{"location":"netbox-extensions/branching/models/branchevent/#user","text":"The NetBox user responsible for triggering this event. This field may be null if the event was triggered by an internal process.","title":"User"},{"location":"netbox-extensions/branching/models/branchevent/#type","text":"The type of event. This must be one of the following: Type Description Provisioned The branch's schema was provisioned in the database Synced Changes from main were synchronized into the branch Merged Changes from the branch were merged into main Reverted Previously merged changes were reverted","title":"Type"},{"location":"netbox-extensions/branching/models/changediff/","text":"Change Diffs A change diff summarized all changes to particular NetBox object within a branch . It serves to simplify the process of reviewing changes within a branch, and avoids the need to review successive individual changes which might otherwise prove tedious. Fields Branch The branch to which this change pertains. Object The NetBox object to which this change pertains. Action The type of change. This must be one of the following: Created Updated Deleted Original Data A snapshot of the object prior to the change. Modified Data A snapshot of the object as it has been modified within the branch. Current Data A snapshot of the object as it currently exists in main. Conflicts A list of attributes with conflicting values. For example, if a site's status has been changed to different values in both main and in the branch, this will be flagged as a conflict: Adopting the new value from either version would overwrite the other.","title":"Change Diffs"},{"location":"netbox-extensions/branching/models/changediff/#change-diffs","text":"A change diff summarized all changes to particular NetBox object within a branch . It serves to simplify the process of reviewing changes within a branch, and avoids the need to review successive individual changes which might otherwise prove tedious.","title":"Change Diffs"},{"location":"netbox-extensions/branching/models/changediff/#fields","text":"","title":"Fields"},{"location":"netbox-extensions/branching/models/changediff/#branch","text":"The branch to which this change pertains.","title":"Branch"},{"location":"netbox-extensions/branching/models/changediff/#object","text":"The NetBox object to which this change pertains.","title":"Object"},{"location":"netbox-extensions/branching/models/changediff/#action","text":"The type of change. This must be one of the following: Created Updated Deleted","title":"Action"},{"location":"netbox-extensions/branching/models/changediff/#original-data","text":"A snapshot of the object prior to the change.","title":"Original Data"},{"location":"netbox-extensions/branching/models/changediff/#modified-data","text":"A snapshot of the object as it has been modified within the branch.","title":"Modified Data"},{"location":"netbox-extensions/branching/models/changediff/#current-data","text":"A snapshot of the object as it currently exists in main.","title":"Current Data"},{"location":"netbox-extensions/branching/models/changediff/#conflicts","text":"A list of attributes with conflicting values. For example, if a site's status has been changed to different values in both main and in the branch, this will be flagged as a conflict: Adopting the new value from either version would overwrite the other.","title":"Conflicts"},{"location":"netbox-extensions/branching/models/objectchange/","text":"Object Changes This model serves as a proxy for NetBox's native ObjectChange model. It does not introduce any new database fields. Rather, it implements several functions which assist in the application and reversal of changes from a branch (namely apply() and undo() ). Tip There is typically no need to employ this model in external code. Use the NetBox's native ObjectChange model instead.","title":"Object Changes"},{"location":"netbox-extensions/branching/models/objectchange/#object-changes","text":"This model serves as a proxy for NetBox's native ObjectChange model. It does not introduce any new database fields. Rather, it implements several functions which assist in the application and reversal of changes from a branch (namely apply() and undo() ). Tip There is typically no need to employ this model in external code. Use the NetBox's native ObjectChange model instead.","title":"Object Changes"},{"location":"netbox-extensions/branching/using-branches/creating-a-branch/","text":"Creating a Branch First, navigate to Branching > Branches to view the list of any existing branches. Click the \"Add\" button at top right to create a new branch. Note If you don't see this button, check that you have permission to create a branch. Pick a unique name for your branch, and add a description if you like. When a branch is first created, its status will show as \"new,\" indicating that its corresponding PostgreSQL schema has not yet been provisioned in the database. A background job is queued automatically to perform this task, which my take a few seconds to several minutes, depending on the size of your database. Tip You can check on the status of the provisioning job under the \"Jobs\" tab of the branch view. Once the branch's schema has been provisioned, the status will be updated to \"ready,\" and the branch will become available to activate. You can activate a branch by selecting it from the dropdown menu at top right. When a branch is active, any changes you make in NetBox (aside from system resources such as users, permissions, etc.) will be reflected only within that branch. For example, if you create a new site when a branch is active, and then switch back to the main branch, the site will no longer appear. Switch back to the original branch, and the site will appear again. Branch Details Within the branch view, you'll notice several tabs. Each of these pertains to a set of changes related to the branch. Diff - This tab provides a summary of all the objects that have been created, updated, or deleted within the branch. Changes Behind - This tab lists all changes that have been made in main since the branch was last synchronized. Synchronizing the branch will update it to include these changes. Changes Ahead - This tab lists all changes made within your branch. Merging the branch will replicate these changes into main. Merged Changes - Once a branch has been merged, this tab lists all changes that have been applied from the branch. (This tab appears only for merged branches.)","title":"Creating a Branch"},{"location":"netbox-extensions/branching/using-branches/creating-a-branch/#creating-a-branch","text":"First, navigate to Branching > Branches to view the list of any existing branches. Click the \"Add\" button at top right to create a new branch. Note If you don't see this button, check that you have permission to create a branch. Pick a unique name for your branch, and add a description if you like. When a branch is first created, its status will show as \"new,\" indicating that its corresponding PostgreSQL schema has not yet been provisioned in the database. A background job is queued automatically to perform this task, which my take a few seconds to several minutes, depending on the size of your database. Tip You can check on the status of the provisioning job under the \"Jobs\" tab of the branch view. Once the branch's schema has been provisioned, the status will be updated to \"ready,\" and the branch will become available to activate. You can activate a branch by selecting it from the dropdown menu at top right. When a branch is active, any changes you make in NetBox (aside from system resources such as users, permissions, etc.) will be reflected only within that branch. For example, if you create a new site when a branch is active, and then switch back to the main branch, the site will no longer appear. Switch back to the original branch, and the site will appear again.","title":"Creating a Branch"},{"location":"netbox-extensions/branching/using-branches/creating-a-branch/#branch-details","text":"Within the branch view, you'll notice several tabs. Each of these pertains to a set of changes related to the branch. Diff - This tab provides a summary of all the objects that have been created, updated, or deleted within the branch. Changes Behind - This tab lists all changes that have been made in main since the branch was last synchronized. Synchronizing the branch will update it to include these changes. Changes Ahead - This tab lists all changes made within your branch. Merging the branch will replicate these changes into main. Merged Changes - Once a branch has been merged, this tab lists all changes that have been applied from the branch. (This tab appears only for merged branches.)","title":"Branch Details"},{"location":"netbox-extensions/branching/using-branches/reverting-a-branch/","text":"Reverting a Branch Once a branch has been merged, it is generally no longer needed, and can no longer be activated. However, occasionally you may find it necessary to undo the changes from a branch (due to an error or an otherwise undesired state). This can be done by reverting the branch. Only merged branches can be reverted. Warning Only branches which have not yet been archived or deleted can be reverted. Once a branch's schema has been deprovisioned, it can no longer be reverted. Before reverting a branch, review the changes listed under its \"Merged Changes\" tab. NetBox will attempt to undo these specific changes when reverting the branch. To revert a merged branch, click the \"Revert\" button. You will be asked to review the changes and to acknowledge any conflicts before executing the reversion. Continuing with the merge will queue a background job to carry out reverting the changes. When the job is running, the branch's status will show \"reverting.\" Tip You can check on the status of the reversion job under the \"Jobs\" tab of the branch view. Once the reversion has completed, the branch will be returned to its pre-merge status, and will again be available to activate. Its event history will show that the branch has been reverted. A Note on Change Logging Reverting a merged branch does not erase any records from the global change log. The original changes resulting from the initial branch merge will be retained, and new change records signifying the inverse of those changes will be added. So, if you're hoping to cover your tracks after doing something foolish, reverting a branch won't help you. But it does provide a convenient path for backing out an undesirable change. For example, suppose you made three changes within a branch before merging it: Create site A Change the description of device B from \"foo\" to \"bar\" Delete tenant C Reverting the branch will apply the following changes, in this order: Create tenant C with its original attributes Change the description of device B from \"bar\" to \"too\" Delete site A After reverting the branch, the global change log will include a record for each of the six discrete changes.","title":"Reverting a Branch"},{"location":"netbox-extensions/branching/using-branches/reverting-a-branch/#reverting-a-branch","text":"Once a branch has been merged, it is generally no longer needed, and can no longer be activated. However, occasionally you may find it necessary to undo the changes from a branch (due to an error or an otherwise undesired state). This can be done by reverting the branch. Only merged branches can be reverted. Warning Only branches which have not yet been archived or deleted can be reverted. Once a branch's schema has been deprovisioned, it can no longer be reverted. Before reverting a branch, review the changes listed under its \"Merged Changes\" tab. NetBox will attempt to undo these specific changes when reverting the branch. To revert a merged branch, click the \"Revert\" button. You will be asked to review the changes and to acknowledge any conflicts before executing the reversion. Continuing with the merge will queue a background job to carry out reverting the changes. When the job is running, the branch's status will show \"reverting.\" Tip You can check on the status of the reversion job under the \"Jobs\" tab of the branch view. Once the reversion has completed, the branch will be returned to its pre-merge status, and will again be available to activate. Its event history will show that the branch has been reverted.","title":"Reverting a Branch"},{"location":"netbox-extensions/branching/using-branches/reverting-a-branch/#a-note-on-change-logging","text":"Reverting a merged branch does not erase any records from the global change log. The original changes resulting from the initial branch merge will be retained, and new change records signifying the inverse of those changes will be added. So, if you're hoping to cover your tracks after doing something foolish, reverting a branch won't help you. But it does provide a convenient path for backing out an undesirable change. For example, suppose you made three changes within a branch before merging it: Create site A Change the description of device B from \"foo\" to \"bar\" Delete tenant C Reverting the branch will apply the following changes, in this order: Create tenant C with its original attributes Change the description of device B from \"bar\" to \"too\" Delete site A After reverting the branch, the global change log will include a record for each of the six discrete changes.","title":"A Note on Change Logging"},{"location":"netbox-extensions/branching/using-branches/syncing-merging/","text":"Syncing & Merging Changes Syncing a Branch Synchronizing a branch replicates all recent changes from main into the branch. These changes can be reviewed under the \"Changes Behind\" tab under the branch view. To synchronize a branch, click the \"Sync\" button. (If this button is not visible, verify that the branch status shows \"ready\" and that you have permission to synchronize the branch.) While a branch is being synchronized, its status will show \"synchronizing.\" Tip You can check on the status of the syncing job under the \"Jobs\" tab of the branch view. Merging a Branch Merging a branch replicates all its changes into main, and updates the branch's status to \"merged.\" These changes can be reviewed under the \"Changes Ahead\" tab under the branch view. Typically, once a branch has been merged, it is no longer used. To merge a branch, click the \"Merge\" button. (If this button is not visible, verify that the branch status shows \"ready\" and that you have permission to merge the branch.) While a branch is being merged, its status will show \"merging.\" Tip You can check on the status of the merging job under the \"Jobs\" tab of the branch view. Once a branch has been merged, it can be reverted , archived, or deleted. Archiving a branch removes its associated schema from the PostgreSQL database to deallocate space. An archived branch cannot be restored, however the branch record is retained for future reference. Dealing with Conflicts In the event an object has been modified in both your branch and in main in a diverging manner, this will be flagged as a conflict. For example, if both you and another user have modified the description of an interface to two different values in main and in the branch, this represents a conflict. The good news is that you will be able to proceed with synchronizing or merging your branch even if conflicts exist, however you will need to acknowledge each such conflict to ensure that overwriting the relevant data in your branch with the data from main is acceptable. Do this by selecting each conflict before continuing with the merge. Alternatively, if the conflicting changes are problematic, you can go back and make the necessary changes in main to avoid overwriting data within your branch. Dry Runs By default, NetBox will perform a \"dry run\" when synchronizing or merging a branch. This means that it will replicate all the relevant changes to check for errors before ultimately aborting the change and returning the branch to its original state. To permanently apply these changes instead, check the \"commit changes\" checkbox.","title":"Syncing & Merging Changes"},{"location":"netbox-extensions/branching/using-branches/syncing-merging/#syncing-merging-changes","text":"","title":"Syncing &amp; Merging Changes"},{"location":"netbox-extensions/branching/using-branches/syncing-merging/#syncing-a-branch","text":"Synchronizing a branch replicates all recent changes from main into the branch. These changes can be reviewed under the \"Changes Behind\" tab under the branch view. To synchronize a branch, click the \"Sync\" button. (If this button is not visible, verify that the branch status shows \"ready\" and that you have permission to synchronize the branch.) While a branch is being synchronized, its status will show \"synchronizing.\" Tip You can check on the status of the syncing job under the \"Jobs\" tab of the branch view.","title":"Syncing a Branch"},{"location":"netbox-extensions/branching/using-branches/syncing-merging/#merging-a-branch","text":"Merging a branch replicates all its changes into main, and updates the branch's status to \"merged.\" These changes can be reviewed under the \"Changes Ahead\" tab under the branch view. Typically, once a branch has been merged, it is no longer used. To merge a branch, click the \"Merge\" button. (If this button is not visible, verify that the branch status shows \"ready\" and that you have permission to merge the branch.) While a branch is being merged, its status will show \"merging.\" Tip You can check on the status of the merging job under the \"Jobs\" tab of the branch view. Once a branch has been merged, it can be reverted , archived, or deleted. Archiving a branch removes its associated schema from the PostgreSQL database to deallocate space. An archived branch cannot be restored, however the branch record is retained for future reference.","title":"Merging a Branch"},{"location":"netbox-extensions/branching/using-branches/syncing-merging/#dealing-with-conflicts","text":"In the event an object has been modified in both your branch and in main in a diverging manner, this will be flagged as a conflict. For example, if both you and another user have modified the description of an interface to two different values in main and in the branch, this represents a conflict. The good news is that you will be able to proceed with synchronizing or merging your branch even if conflicts exist, however you will need to acknowledge each such conflict to ensure that overwriting the relevant data in your branch with the data from main is acceptable. Do this by selecting each conflict before continuing with the merge. Alternatively, if the conflicting changes are problematic, you can go back and make the necessary changes in main to avoid overwriting data within your branch.","title":"Dealing with Conflicts"},{"location":"netbox-extensions/branching/using-branches/syncing-merging/#dry-runs","text":"By default, NetBox will perform a \"dry run\" when synchronizing or merging a branch. This means that it will replicate all the relevant changes to check for errors before ultimately aborting the change and returning the branch to its original state. To permanently apply these changes instead, check the \"commit changes\" checkbox.","title":"Dry Runs"},{"location":"netbox-extensions/changes/","text":"NetBox Change Management This plugin adds change management support to NetBox . Leveraging the netbox-branching plugin, it implements policy and workflow controls to ensure proposed changes undergo formal review prior to being merged. It also retains a written record of all approved changes. Getting Started Defining a Policy Change policies determine who is eligible to approve a change request and how many approvals a change request requires. Each policy contains one or more rules which define these parameters. Begin by creating a new policy with a name of your choosing, then add however many rules are necessary to enforce your organization's change policy. For example, suppose your team requires that every change be approved by two engineers (members of the Engineering group in NetBox) and one of the two lead engineers (Alice and Bob). This can be achieved by adding two rules to the policy. Rule Minimum reviews Reviewer groups Reviewers #1 2 Engineering - #2 1 - Alice, Bob This policy will be met only when at least two members of the Engineering group and Alice or Bob submit approvals. Create a Change Request When you've finished staging your changes in a branch, click the \"request review\" button at the top of the branch view. This will take you to the change request creation form. Enter a name for your change request (or keep the default value, taken from the branch's name) and select the change policy which applies to your request. Each change request will be opened in \"draft\" status with medium priority by default, but these can be changed. Go ahead and change the status to \"needs review\" if it's ready for review now. Finally, provide a brief summary of your changes for reviewers. Reviewing a Change Request Once a change request has been submitted, it can be reviewed by other users. To review a change request, click the \"add a review\" link above the list of reviews (if any). Select the status of your review and provide any comments you have. Your review will now show up under the change request. Alternatively, if you'd like to provide more detailed feedback, select the \"changes\" tab. Here, you can comment on specific changes within the branch and cite any concerns or suggestions you have. Other users can then reply to your comments. Applying a Change Request Once a change request has been approved, the \"merge\" button will appear. Clicking it will take you to the form to merge the corresponding branch. Once the branch has been merged successfully, the change request's status will be automatically updated to \"completed.\"","title":"Overview"},{"location":"netbox-extensions/changes/#netbox-change-management","text":"This plugin adds change management support to NetBox . Leveraging the netbox-branching plugin, it implements policy and workflow controls to ensure proposed changes undergo formal review prior to being merged. It also retains a written record of all approved changes.","title":"NetBox Change Management"},{"location":"netbox-extensions/changes/#getting-started","text":"","title":"Getting Started"},{"location":"netbox-extensions/changes/#defining-a-policy","text":"Change policies determine who is eligible to approve a change request and how many approvals a change request requires. Each policy contains one or more rules which define these parameters. Begin by creating a new policy with a name of your choosing, then add however many rules are necessary to enforce your organization's change policy. For example, suppose your team requires that every change be approved by two engineers (members of the Engineering group in NetBox) and one of the two lead engineers (Alice and Bob). This can be achieved by adding two rules to the policy. Rule Minimum reviews Reviewer groups Reviewers #1 2 Engineering - #2 1 - Alice, Bob This policy will be met only when at least two members of the Engineering group and Alice or Bob submit approvals.","title":"Defining a Policy"},{"location":"netbox-extensions/changes/#create-a-change-request","text":"When you've finished staging your changes in a branch, click the \"request review\" button at the top of the branch view. This will take you to the change request creation form. Enter a name for your change request (or keep the default value, taken from the branch's name) and select the change policy which applies to your request. Each change request will be opened in \"draft\" status with medium priority by default, but these can be changed. Go ahead and change the status to \"needs review\" if it's ready for review now. Finally, provide a brief summary of your changes for reviewers.","title":"Create a Change Request"},{"location":"netbox-extensions/changes/#reviewing-a-change-request","text":"Once a change request has been submitted, it can be reviewed by other users. To review a change request, click the \"add a review\" link above the list of reviews (if any). Select the status of your review and provide any comments you have. Your review will now show up under the change request. Alternatively, if you'd like to provide more detailed feedback, select the \"changes\" tab. Here, you can comment on specific changes within the branch and cite any concerns or suggestions you have. Other users can then reply to your comments.","title":"Reviewing a Change Request"},{"location":"netbox-extensions/changes/#applying-a-change-request","text":"Once a change request has been approved, the \"merge\" button will appear. Clicking it will take you to the form to merge the corresponding branch. Once the branch has been merged successfully, the change request's status will be automatically updated to \"completed.\"","title":"Applying a Change Request"},{"location":"netbox-extensions/changes/changelog/","text":"Change Log v0.2.0 Initial release","title":"Changelog"},{"location":"netbox-extensions/changes/changelog/#change-log","text":"","title":"Change Log"},{"location":"netbox-extensions/changes/changelog/#v020","text":"Initial release","title":"v0.2.0"},{"location":"netbox-extensions/changes/configuration/","text":"Configuration Parameters The following plugin configuration parameters are available. protect_main Default: False When enabled, all object creations, changes, and deletions must be made within a branch. Changes to objects in main will not be permitted, except for those object types which do not support branching.","title":"Configuration"},{"location":"netbox-extensions/changes/configuration/#configuration-parameters","text":"The following plugin configuration parameters are available.","title":"Configuration Parameters"},{"location":"netbox-extensions/changes/configuration/#protect_main","text":"Default: False When enabled, all object creations, changes, and deletions must be made within a branch. Changes to objects in main will not be permitted, except for those object types which do not support branching.","title":"protect_main"},{"location":"netbox-extensions/changes/models/changerequest/","text":"Change Requests A change request is submitted to request approval of proposed changes in a branch before it can be merged. All rules of the assigned change policy must be met for the request to be approved. When submitting a change request for a branch, the owner selects the governing policy and designates a priority. Fields Name The user-defined name of the change request. Owner The user who submitted the change request. Policy The policy which must be met for the change request to be approved. Note The policy is selected by the change request owner. Branch The branch which will be merged when the change request has been approved. Status The current status of the change request. Valid statuses are listed below. Status Description Draft Not yet ready for review Needs review Waiting for reviews to satisfy the assigned policy Approved The assigned policy has been met Completed The assigned branch has been merged Rejected The proposed changes have been rejected Priority The priority of the change request relative to other open requests. Valid priorities are listed below. High (5) Medium/high (4) Medium (3) Medium/low (2) Low (1) Summary A short summary of the proposed changes, reasoning for why they are being made, and any other relevant notes for reviewers.","title":"Change Request"},{"location":"netbox-extensions/changes/models/changerequest/#change-requests","text":"A change request is submitted to request approval of proposed changes in a branch before it can be merged. All rules of the assigned change policy must be met for the request to be approved. When submitting a change request for a branch, the owner selects the governing policy and designates a priority.","title":"Change Requests"},{"location":"netbox-extensions/changes/models/changerequest/#fields","text":"","title":"Fields"},{"location":"netbox-extensions/changes/models/changerequest/#name","text":"The user-defined name of the change request.","title":"Name"},{"location":"netbox-extensions/changes/models/changerequest/#owner","text":"The user who submitted the change request.","title":"Owner"},{"location":"netbox-extensions/changes/models/changerequest/#policy","text":"The policy which must be met for the change request to be approved. Note The policy is selected by the change request owner.","title":"Policy"},{"location":"netbox-extensions/changes/models/changerequest/#branch","text":"The branch which will be merged when the change request has been approved.","title":"Branch"},{"location":"netbox-extensions/changes/models/changerequest/#status","text":"The current status of the change request. Valid statuses are listed below. Status Description Draft Not yet ready for review Needs review Waiting for reviews to satisfy the assigned policy Approved The assigned policy has been met Completed The assigned branch has been merged Rejected The proposed changes have been rejected","title":"Status"},{"location":"netbox-extensions/changes/models/changerequest/#priority","text":"The priority of the change request relative to other open requests. Valid priorities are listed below. High (5) Medium/high (4) Medium (3) Medium/low (2) Low (1)","title":"Priority"},{"location":"netbox-extensions/changes/models/changerequest/#summary","text":"A short summary of the proposed changes, reasoning for why they are being made, and any other relevant notes for reviewers.","title":"Summary"},{"location":"netbox-extensions/changes/models/comment/","text":"Comments As part of the review process, users can leave comments on change requests to ask question or suggest changes. Each comment may start a thread of replies and can be marked resolved, which will hide the reply thread. Fields Author The user who created the comment. Change Request The change request to which the comment applies. Change Diff The specific change within the change request the comment applies (optional). Content The comment body. Resolved A boolean attribute indicating whether the comment has been addressed by the change request owner.","title":"Comment"},{"location":"netbox-extensions/changes/models/comment/#comments","text":"As part of the review process, users can leave comments on change requests to ask question or suggest changes. Each comment may start a thread of replies and can be marked resolved, which will hide the reply thread.","title":"Comments"},{"location":"netbox-extensions/changes/models/comment/#fields","text":"","title":"Fields"},{"location":"netbox-extensions/changes/models/comment/#author","text":"The user who created the comment.","title":"Author"},{"location":"netbox-extensions/changes/models/comment/#change-request","text":"The change request to which the comment applies.","title":"Change Request"},{"location":"netbox-extensions/changes/models/comment/#change-diff","text":"The specific change within the change request the comment applies (optional).","title":"Change Diff"},{"location":"netbox-extensions/changes/models/comment/#content","text":"The comment body.","title":"Content"},{"location":"netbox-extensions/changes/models/comment/#resolved","text":"A boolean attribute indicating whether the comment has been addressed by the change request owner.","title":"Resolved"},{"location":"netbox-extensions/changes/models/commentreply/","text":"Comment Replies Each comment on a change request starts a new discussion thread to which users can reply. This helps keep the discussion around a change request organized. Fields Author The user who created the reply. Comment The comment to which the reply thread belongs. Content The reply body.","title":"Comment Reply"},{"location":"netbox-extensions/changes/models/commentreply/#comment-replies","text":"Each comment on a change request starts a new discussion thread to which users can reply. This helps keep the discussion around a change request organized.","title":"Comment Replies"},{"location":"netbox-extensions/changes/models/commentreply/#fields","text":"","title":"Fields"},{"location":"netbox-extensions/changes/models/commentreply/#author","text":"The user who created the reply.","title":"Author"},{"location":"netbox-extensions/changes/models/commentreply/#comment","text":"The comment to which the reply thread belongs.","title":"Comment"},{"location":"netbox-extensions/changes/models/commentreply/#content","text":"The reply body.","title":"Content"},{"location":"netbox-extensions/changes/models/policy/","text":"Policies A policy defines the conditions that must be met for a change request to be merged. Each policy defines one or more rules which assert these conditions. All rules must be met for the policy to be satisfied. Note A policy with no rules defined will always fail. Fields Name The name by which the policy is referenced.","title":"Policy"},{"location":"netbox-extensions/changes/models/policy/#policies","text":"A policy defines the conditions that must be met for a change request to be merged. Each policy defines one or more rules which assert these conditions. All rules must be met for the policy to be satisfied. Note A policy with no rules defined will always fail.","title":"Policies"},{"location":"netbox-extensions/changes/models/policy/#fields","text":"","title":"Fields"},{"location":"netbox-extensions/changes/models/policy/#name","text":"The name by which the policy is referenced.","title":"Name"},{"location":"netbox-extensions/changes/models/policyrule/","text":"Policy Rules Each policy contains one or more rules which assert certain conditions that must be met for the policy to be met. For example, you might define a policy that requires the approval of two engineers and one manager. Users whose reviews will satisfy the rule are identified by assigning individual users and/or groups of users for each rule. The minimum reviews parameter defines how many approved must be submitted for the rule to be met. Fields Name The short name by which the rule is identified. Enabled A boolean indicating whether the rule is enabled. Rules are enabled by default. Minimum Reviews The minimum number of eligible reviewers which must approve the change in order for the rule to pass. Note A value of zero may be set to assert that a rule shall always pass, although this is generally not recommended. Reviewer Groups Groups of users whose approval will satisfy this rule. Reviewers Individual users whose approval will satisfy this rule.","title":"Policy Rule"},{"location":"netbox-extensions/changes/models/policyrule/#policy-rules","text":"Each policy contains one or more rules which assert certain conditions that must be met for the policy to be met. For example, you might define a policy that requires the approval of two engineers and one manager. Users whose reviews will satisfy the rule are identified by assigning individual users and/or groups of users for each rule. The minimum reviews parameter defines how many approved must be submitted for the rule to be met.","title":"Policy Rules"},{"location":"netbox-extensions/changes/models/policyrule/#fields","text":"","title":"Fields"},{"location":"netbox-extensions/changes/models/policyrule/#name","text":"The short name by which the rule is identified.","title":"Name"},{"location":"netbox-extensions/changes/models/policyrule/#enabled","text":"A boolean indicating whether the rule is enabled. Rules are enabled by default.","title":"Enabled"},{"location":"netbox-extensions/changes/models/policyrule/#minimum-reviews","text":"The minimum number of eligible reviewers which must approve the change in order for the rule to pass. Note A value of zero may be set to assert that a rule shall always pass, although this is generally not recommended.","title":"Minimum Reviews"},{"location":"netbox-extensions/changes/models/policyrule/#reviewer-groups","text":"Groups of users whose approval will satisfy this rule.","title":"Reviewer Groups"},{"location":"netbox-extensions/changes/models/policyrule/#reviewers","text":"Individual users whose approval will satisfy this rule.","title":"Reviewers"},{"location":"netbox-extensions/changes/models/review/","text":"Reviews Reviews are submitted to approve, reject, or comment on a change request . The users eligible to review a particular change request are determined by its assigned change policy . Fields Change Request The change request being reviewed. User The author of the review. Status The current status of the review. Valid statuses are listed below. Status Description Pending The review is in progress Comment The reviewer has questions or feedback Changes Requested The reviewer has requested modifications to the proposed changes Approved The proposed changes are accepted Rejected The proposed changes are rejected","title":"Review"},{"location":"netbox-extensions/changes/models/review/#reviews","text":"Reviews are submitted to approve, reject, or comment on a change request . The users eligible to review a particular change request are determined by its assigned change policy .","title":"Reviews"},{"location":"netbox-extensions/changes/models/review/#fields","text":"","title":"Fields"},{"location":"netbox-extensions/changes/models/review/#change-request","text":"The change request being reviewed.","title":"Change Request"},{"location":"netbox-extensions/changes/models/review/#user","text":"The author of the review.","title":"User"},{"location":"netbox-extensions/changes/models/review/#status","text":"The current status of the review. Valid statuses are listed below. Status Description Pending The review is in progress Comment The reviewer has questions or feedback Changes Requested The reviewer has requested modifications to the proposed changes Approved The proposed changes are accepted Rejected The proposed changes are rejected","title":"Status"},{"location":"netbox-extensions/diode/","text":"Diode Currently in Public Preview The Diode project is currently in Public Preview . Please see NetBox Labs Product and Feature Lifecycle for more details. Overview Diode is a NetBox data ingestion service that aims to simplify and enhance the process to add and update network data in NetBox. The guiding principle behind Diode is to make it as easy as possible to get data into NetBox by removing as much burden as possible from the user while shifting that effort to technology. Diode is a sidecar service to NetBox that provides a gRPC/protobuf API designed for ingestion of common NetBox data models. Diode reduces the need to preprocess data to make it conform to the strict object hierarchy imposed by the NetBox data model. This allows data to be sent to NetBox in a more freeform manner, in blocks that are intuitive for network engineers such as by device or by interface. Related information is treated as attributes or properties of these blocks. Diode takes care of the heavy lifting of transforming this data to make it align with NetBox\u2019s structured and comprehensive data model. Diode will create placeholder objects to compensate for missing information, allowing fragmented or incomplete information about the network to be collected. Supported versions of NetBox Diode has been tested with NetBox versions 3.7.2 and above. Diode components There are three required components to the Diode service: Diode NetBox plugin - This component provides API key management and ORM integration into NetBox for the Diode server. See how to install the Diode plugin . Diode server - This component provides the ingestion and reconciliation services that process the incoming data. See how to run the Diode server . Diode client - This component receives the data to be ingested and forwards that data as gRPC/protobuf to the Diode server. It is implemented as an SDK and can be embedded in scripts and integrations. See how to install the Diode Python SDK . Additional resources Additional resources including example scripts can be found in the NetBox Labs NetBox Learning repository .","title":"Overview"},{"location":"netbox-extensions/diode/#diode","text":"Currently in Public Preview The Diode project is currently in Public Preview . Please see NetBox Labs Product and Feature Lifecycle for more details.","title":"Diode"},{"location":"netbox-extensions/diode/#overview","text":"Diode is a NetBox data ingestion service that aims to simplify and enhance the process to add and update network data in NetBox. The guiding principle behind Diode is to make it as easy as possible to get data into NetBox by removing as much burden as possible from the user while shifting that effort to technology. Diode is a sidecar service to NetBox that provides a gRPC/protobuf API designed for ingestion of common NetBox data models. Diode reduces the need to preprocess data to make it conform to the strict object hierarchy imposed by the NetBox data model. This allows data to be sent to NetBox in a more freeform manner, in blocks that are intuitive for network engineers such as by device or by interface. Related information is treated as attributes or properties of these blocks. Diode takes care of the heavy lifting of transforming this data to make it align with NetBox\u2019s structured and comprehensive data model. Diode will create placeholder objects to compensate for missing information, allowing fragmented or incomplete information about the network to be collected.","title":"Overview"},{"location":"netbox-extensions/diode/#supported-versions-of-netbox","text":"Diode has been tested with NetBox versions 3.7.2 and above.","title":"Supported versions of NetBox"},{"location":"netbox-extensions/diode/#diode-components","text":"There are three required components to the Diode service: Diode NetBox plugin - This component provides API key management and ORM integration into NetBox for the Diode server. See how to install the Diode plugin . Diode server - This component provides the ingestion and reconciliation services that process the incoming data. See how to run the Diode server . Diode client - This component receives the data to be ingested and forwards that data as gRPC/protobuf to the Diode server. It is implemented as an SDK and can be embedded in scripts and integrations. See how to install the Diode Python SDK .","title":"Diode components"},{"location":"netbox-extensions/diode/#additional-resources","text":"Additional resources including example scripts can be found in the NetBox Labs NetBox Learning repository .","title":"Additional resources"},{"location":"netbox-extensions/diode/diode-agent/","text":"The Diode Agent is a lightweight network device discovery tool that uses NAPALM to streamline data entry into NetBox through the Diode ingestion service. The following is a basic set of instructions to get started using Diode Agent on a local machine. Requirements The Diode NAPALM Agent requires a Python runtime environment and has the following requirements: Diode service - see the Get started guide Diode SDK - see the Installing the Diode client SDK guide Python 3.10 or greater Install the agent Clone the agent repository: cd /opt git clone https://github.com/netboxlabs/diode-agent.git cd /opt/diode-agent/ Create a Python virtual environment and install the agent: python3 -m venv venv source venv/bin/activate pip install /opt/diode-agent/diode-napalm-agent --no-cache-dir Create a discovery configuration file The agent requires a configuration file to provide an inventory of devices to be discovered. A sample configuration file is provided with the agent. Create a copy of the sample configuration file: cp /opt/diode-agent/diode-napalm-agent/config.sample.yaml /opt/diode-agent/config.yaml Edit the config.yaml to suit the environment: The config section needs to be updated to reflect the Diode server environment The data section should include a list of all devices (and their credentials) to be discovered diode : config : target : grpc://localhost:8081 api_key : ${DIODE_API_KEY} policies : discovery_1 : config : netbox : site : New York NY data : - hostname : 192.168.0.32 username : ${USER} password : admin - driver : eos hostname : 127.0.0.1 username : admin password : ${ARISTA_PASSWORD} optional_args : enable_password : ${ARISTA_PASSWORD} Tip Variables (using ${ENV} syntax) can be referenced in the configuration file from environmental variables or from a provided .env file. Tip The driver device attribute is optional. If not specified, the agent will attempt to find a match from NAPALM supported drivers. Note Detailed information about optional_args can be found in the NAPALM documentation . Supported network device drivers The default supported drivers are the natively supported NAPALM drivers: Arista EOS (\"eos\") Cisco IOS (\"ios\") Cisco IOS-XR (\"iosxr\") Cisco NX-OS (\"nxos\") Juniper JunOS (\"junos\") Run the agent The agent must be run in the Python virtual environment created earlier. To run the agent with the discovery configuration file: diode-napalm-agent -c config.yaml Verify The Diode agent is successfully installed if the command diode-napalm-agent returns: usage: diode-napalm-agent [ -h ] [ -V ] -c config.yaml [ -e .env ] [ -w N ] Diode Agent for NAPALM options: -h, --help show this help message and exit -V, --version Display Diode Agent, NAPALM and Diode SDK versions -c config.yaml, --config config.yaml Agent yaml configuration file -e .env, --env .env File containing environment variables -w N, --workers N Number of workers to be used","title":"Diode agent"},{"location":"netbox-extensions/diode/diode-agent/#requirements","text":"The Diode NAPALM Agent requires a Python runtime environment and has the following requirements: Diode service - see the Get started guide Diode SDK - see the Installing the Diode client SDK guide Python 3.10 or greater","title":"Requirements"},{"location":"netbox-extensions/diode/diode-agent/#install-the-agent","text":"Clone the agent repository: cd /opt git clone https://github.com/netboxlabs/diode-agent.git cd /opt/diode-agent/ Create a Python virtual environment and install the agent: python3 -m venv venv source venv/bin/activate pip install /opt/diode-agent/diode-napalm-agent --no-cache-dir","title":"Install the agent"},{"location":"netbox-extensions/diode/diode-agent/#create-a-discovery-configuration-file","text":"The agent requires a configuration file to provide an inventory of devices to be discovered. A sample configuration file is provided with the agent. Create a copy of the sample configuration file: cp /opt/diode-agent/diode-napalm-agent/config.sample.yaml /opt/diode-agent/config.yaml Edit the config.yaml to suit the environment: The config section needs to be updated to reflect the Diode server environment The data section should include a list of all devices (and their credentials) to be discovered diode : config : target : grpc://localhost:8081 api_key : ${DIODE_API_KEY} policies : discovery_1 : config : netbox : site : New York NY data : - hostname : 192.168.0.32 username : ${USER} password : admin - driver : eos hostname : 127.0.0.1 username : admin password : ${ARISTA_PASSWORD} optional_args : enable_password : ${ARISTA_PASSWORD} Tip Variables (using ${ENV} syntax) can be referenced in the configuration file from environmental variables or from a provided .env file. Tip The driver device attribute is optional. If not specified, the agent will attempt to find a match from NAPALM supported drivers. Note Detailed information about optional_args can be found in the NAPALM documentation .","title":"Create a discovery configuration file"},{"location":"netbox-extensions/diode/diode-agent/#run-the-agent","text":"The agent must be run in the Python virtual environment created earlier. To run the agent with the discovery configuration file: diode-napalm-agent -c config.yaml","title":"Run the agent"},{"location":"netbox-extensions/diode/diode-agent/#verify","text":"The Diode agent is successfully installed if the command diode-napalm-agent returns: usage: diode-napalm-agent [ -h ] [ -V ] -c config.yaml [ -e .env ] [ -w N ] Diode Agent for NAPALM options: -h, --help show this help message and exit -V, --version Display Diode Agent, NAPALM and Diode SDK versions -c config.yaml, --config config.yaml Agent yaml configuration file -e .env, --env .env File containing environment variables -w N, --workers N Number of workers to be used","title":"Verify"},{"location":"netbox-extensions/diode/diode-client/","text":"The Diode SDK is a Python library for sending data to the Diode server over gRPC/protbuf for ingestion in to NetBox. Requirements The Diode SDK requires Python version 3.10 or greater. Install the Diode SDK Create a virtual environment and activate it: python3 -m venv venv source venv/bin/activate Upgrade pip: python3 -m pip install --upgrade pip Install the SDK package: pip install netboxlabs-diode-sdk Configure the client Set the following environment variable with the DIODE_API_KEY API key from the plugin installation: export DIODE_API_KEY = <API key from Diode plugin installation> Verify The Diode client is successfully installed if the pip freeze command returns: pip freeze | grep diode netboxlabs-diode-sdk == 0 .1.0 Next step The next step is to explore and download example Diode scripts or to install and run the Diode discovery agent .","title":"Installing the Diode client SDK"},{"location":"netbox-extensions/diode/diode-client/#requirements","text":"The Diode SDK requires Python version 3.10 or greater.","title":"Requirements"},{"location":"netbox-extensions/diode/diode-client/#install-the-diode-sdk","text":"Create a virtual environment and activate it: python3 -m venv venv source venv/bin/activate Upgrade pip: python3 -m pip install --upgrade pip Install the SDK package: pip install netboxlabs-diode-sdk","title":"Install the Diode SDK"},{"location":"netbox-extensions/diode/diode-client/#configure-the-client","text":"Set the following environment variable with the DIODE_API_KEY API key from the plugin installation: export DIODE_API_KEY = <API key from Diode plugin installation>","title":"Configure the client"},{"location":"netbox-extensions/diode/diode-client/#verify","text":"The Diode client is successfully installed if the pip freeze command returns: pip freeze | grep diode netboxlabs-diode-sdk == 0 .1.0","title":"Verify"},{"location":"netbox-extensions/diode/diode-client/#next-step","text":"The next step is to explore and download example Diode scripts or to install and run the Diode discovery agent .","title":"Next step"},{"location":"netbox-extensions/diode/diode-get-started/","text":"Get started Components Diode runs as a sidecar service to NetBox and can run anywhere with network connectivity to NetBox. To get started, the following components need to be installed and running: Installing the Diode plugin - installed on the NetBox host Running the Diode server - installed anywhere where Docker is available Installing the Diode client - installed on the client where data will be ingested","title":"Components"},{"location":"netbox-extensions/diode/diode-get-started/#get-started","text":"","title":"Get started"},{"location":"netbox-extensions/diode/diode-get-started/#components","text":"Diode runs as a sidecar service to NetBox and can run anywhere with network connectivity to NetBox. To get started, the following components need to be installed and running: Installing the Diode plugin - installed on the NetBox host Running the Diode server - installed anywhere where Docker is available Installing the Diode client - installed on the client where data will be ingested","title":"Components"},{"location":"netbox-extensions/diode/diode-plugin/","text":"Info The following instructions assume you have installed NetBox in the /opt/netbox directory. Adjust instructions as necessary if you've installed NetBox in a different directory. Install the plugin Source the NetBox Python virtual environment: cd /opt/netbox source venv/bin/activate Install the plugin in the Python virtual environment: pip install netboxlabs-diode-netbox-plugin Configure NetBox Edit the NetBox configuration.py file and add the netbox_diode_plugin to the PLUGINS list. The default location for this file is /opt/netbox/netbox/netbox/configuration.py . PLUGINS = [ \"netbox_diode_plugin\" , ] Restart NetBox to load the plugin: sudo systemctl restart netbox netbox-rq Configure the plugin Diode requires three API keys that must be passed as environment variables to function. These API keys are random 40 character long alphanumeric strings and can be generated and set to the appropriate environment variables with the following commands: # API key for the Diode service to interact with NetBox export DIODE_TO_NETBOX_API_KEY = $( head -c20 </dev/urandom | xxd -p ) ; env | grep DIODE_TO_NETBOX_API_KEY # API key for the NetBox service to interact with Diode export NETBOX_TO_DIODE_API_KEY = $( head -c20 </dev/urandom | xxd -p ) ; env | grep NETBOX_TO_DIODE_API_KEY # API key for Diode SDKs to ingest data into Diode export DIODE_API_KEY = $( head -c20 </dev/urandom | xxd -p ) ; env | grep DIODE_API_KEY Warning Store the API key strings in a safe place as they will be needed to configure the Diode server Run migrations to configure the plugin to use generated API keys: cd /opt/netbox/netbox ./manage.py migrate netbox_diode_plugin Verify The plugin is successfully installed and configured: The NetBox Labs DIODE plugin is visible in the right-hand navigation bar Three NetBox users and three corresponding API keys have been created: DIODE DIODE_TO_NETBOX NETBOX_TO_DIODE Next step The next step is to configure and run the Diode server","title":"Installing the Diode plugin"},{"location":"netbox-extensions/diode/diode-plugin/#install-the-plugin","text":"Source the NetBox Python virtual environment: cd /opt/netbox source venv/bin/activate Install the plugin in the Python virtual environment: pip install netboxlabs-diode-netbox-plugin","title":"Install the plugin"},{"location":"netbox-extensions/diode/diode-plugin/#configure-netbox","text":"Edit the NetBox configuration.py file and add the netbox_diode_plugin to the PLUGINS list. The default location for this file is /opt/netbox/netbox/netbox/configuration.py . PLUGINS = [ \"netbox_diode_plugin\" , ] Restart NetBox to load the plugin: sudo systemctl restart netbox netbox-rq","title":"Configure NetBox"},{"location":"netbox-extensions/diode/diode-plugin/#configure-the-plugin","text":"Diode requires three API keys that must be passed as environment variables to function. These API keys are random 40 character long alphanumeric strings and can be generated and set to the appropriate environment variables with the following commands: # API key for the Diode service to interact with NetBox export DIODE_TO_NETBOX_API_KEY = $( head -c20 </dev/urandom | xxd -p ) ; env | grep DIODE_TO_NETBOX_API_KEY # API key for the NetBox service to interact with Diode export NETBOX_TO_DIODE_API_KEY = $( head -c20 </dev/urandom | xxd -p ) ; env | grep NETBOX_TO_DIODE_API_KEY # API key for Diode SDKs to ingest data into Diode export DIODE_API_KEY = $( head -c20 </dev/urandom | xxd -p ) ; env | grep DIODE_API_KEY Warning Store the API key strings in a safe place as they will be needed to configure the Diode server Run migrations to configure the plugin to use generated API keys: cd /opt/netbox/netbox ./manage.py migrate netbox_diode_plugin","title":"Configure the plugin"},{"location":"netbox-extensions/diode/diode-plugin/#verify","text":"The plugin is successfully installed and configured: The NetBox Labs DIODE plugin is visible in the right-hand navigation bar Three NetBox users and three corresponding API keys have been created: DIODE DIODE_TO_NETBOX NETBOX_TO_DIODE","title":"Verify"},{"location":"netbox-extensions/diode/diode-plugin/#next-step","text":"The next step is to configure and run the Diode server","title":"Next step"},{"location":"netbox-extensions/diode/diode-server/","text":"Requirements The Diode server requires a Docker environment (and docker compose ), version 27.0.3 or above. Configure the Diode server The Diode server is configured using a configuration file and an environment file: docker-compose.yml - configures and run the Diode server docker containers .env - stores the specific environmental settings for the environmnet In a clean directory: mkdir /opt/diode cd /opt/diode Download the default docker-compose.yml and .env files from the Diode project repository: curl -o docker-compose.yml https://raw.githubusercontent.com/netboxlabs/diode/develop/diode-server/docker/docker-compose.yaml curl -o .env https://raw.githubusercontent.com/netboxlabs/diode/develop/diode-server/docker/sample.env Edit the .env to match the environment: NETBOX_DIODE_PLUGIN_API_BASE_URL : URL for NetBox, appended with /api/plugins/diode DIODE_TO_NETBOX_API_KEY : API key from Diode plugin installation DIODE_API_KEY : API key from Diode plugin installation NETBOX_TO_DIODE_API_KEY : API key from Diode plugin installation Run the Diode server From the /opt/diode directory, download and run the Diode server containers: docker compose up -d Verify The Diode server is successfully configured and running if the command docker compose ps returns the following four containers with a STATUS of Up : docker compose ps NAME IMAGE STATUS diode-diode-ingester-1 netboxlabs/diode-ingester:latest Up diode-diode-reconciler-1 netboxlabs/diode-reconciler:latest Up diode-diode-redis-1 redis/redis-stack-server:latest Up diode-ingress-nginx-1 nginx:latest Up Next step The next step is to install the Diode client","title":"Running the Diode server"},{"location":"netbox-extensions/diode/diode-server/#requirements","text":"The Diode server requires a Docker environment (and docker compose ), version 27.0.3 or above.","title":"Requirements"},{"location":"netbox-extensions/diode/diode-server/#configure-the-diode-server","text":"The Diode server is configured using a configuration file and an environment file: docker-compose.yml - configures and run the Diode server docker containers .env - stores the specific environmental settings for the environmnet In a clean directory: mkdir /opt/diode cd /opt/diode Download the default docker-compose.yml and .env files from the Diode project repository: curl -o docker-compose.yml https://raw.githubusercontent.com/netboxlabs/diode/develop/diode-server/docker/docker-compose.yaml curl -o .env https://raw.githubusercontent.com/netboxlabs/diode/develop/diode-server/docker/sample.env Edit the .env to match the environment: NETBOX_DIODE_PLUGIN_API_BASE_URL : URL for NetBox, appended with /api/plugins/diode DIODE_TO_NETBOX_API_KEY : API key from Diode plugin installation DIODE_API_KEY : API key from Diode plugin installation NETBOX_TO_DIODE_API_KEY : API key from Diode plugin installation","title":"Configure the Diode server"},{"location":"netbox-extensions/diode/diode-server/#run-the-diode-server","text":"From the /opt/diode directory, download and run the Diode server containers: docker compose up -d","title":"Run the Diode server"},{"location":"netbox-extensions/diode/diode-server/#verify","text":"The Diode server is successfully configured and running if the command docker compose ps returns the following four containers with a STATUS of Up : docker compose ps NAME IMAGE STATUS diode-diode-ingester-1 netboxlabs/diode-ingester:latest Up diode-diode-reconciler-1 netboxlabs/diode-reconciler:latest Up diode-diode-redis-1 redis/redis-stack-server:latest Up diode-ingress-nginx-1 nginx:latest Up","title":"Verify"},{"location":"netbox-extensions/diode/diode-server/#next-step","text":"The next step is to install the Diode client","title":"Next step"},{"location":"netbox-integrations/netbox-ansible-collection/","text":"NetBox Integrations NetBox Ansible Collection - Quick Start A short guide to getting started with the Ansible Collection for Netbox. The collection is available from Ansible Galaxy , and NetBox Labs and Red Hat customers can access the certified and supported collection, via Ansible Automation Hub . This doc is based on the Galaxy installation and shows how to use the collection from the command line, rather than from within Ansible Automation Hub. Code Examples All code used in the examples below can be found in the NetBox Learning git repository , in the directory netbox-ansible-collection-quick-start . Collection Overview The NetBox Ansible project provides an Ansible collection for interacting with NetBox, the leading solution for modeling and documenting modern networks. By combining the traditional disciplines of IP address management (IPAM) and datacenter infrastructure management (DCIM) with powerful APIs and extensions, NetBox provides the ideal \"source of truth\" to power network automation. This Ansible collection consists of a set of modules to define the intended network state in NetBox, along with plugins to drive automation of the network using data from NetBox. Requirements You must be running one of the two most recent releases of NetBox A NetBox write-enabled API token when using modules or a read-only token for the nb_lookup and nb_inventory plugins. Python 3.10+ Python modules: pytz pynetbox Ansible 2.15+ Note This guide assumes you have a working NetBox installation, populated with some device data of your own. The easiest way to do this is to set up a NetBox Cloud Free Plan instance, and you can be up an running in seconds. The NetBox instance used in this example has 2 sites with some devices already added: Getting Started with the Collection Installation and Setup Clone the Git repo and change into the netbox-ansible-collection-quick-start directory: git clone https://github.com/netboxlabs/netbox-learning.git cd netbox-learning/netbox-ansible-collection-quick-start Create and activate a Python 3 virtual environment: python3 -m venv ./venv source venv/bin/activate Install Python Modules and Ansible pip install pytz pip install pynetbox pip install ansible Install the NetBox Ansible Collection. Before using this collection, you need to install it with the Ansible Galaxy command-line tool: ansible-galaxy collection install netbox.netbox 5. Set environment variables for your NetBox API token and URL of your NetBox instance: export NETBOX_API=<YOUR_NETBOX_URL> (note - must include http:// or https://) export NETBOX_TOKEN=<YOUR_NETBOX_API_TOKEN> Use Case 1 - NetBox as a Dynamic Inventory Source for Ansible The Inventory Plugin component of the collection is used to dynamically generate the inventory from NetBox to be used in Ansible playbooks. In the example ansible.cfg file we are specifying that the inventory should be sourced from the file netbox_inv.yml : # ansible.cfg [defaults] inventory = ./netbox_inv.yml The plugin is highly configurable in terms of defining returned hosts and groupings etc in the inventory, so please consult the docs . In this case we are grouping the returned hosts by the device_roles and sites as defined in the NetBox database: # netbox_inv.yml plugin: netbox.netbox.nb_inventory validate_certs: False group_by: - device_roles - sites To view a graph of the inventory retrieved from NetBox, you can run the ansible-inventory command and use the -i flag to specify the netbox_inv.yml file as the source, followed by --graph : ansible-inventory -i netbox_inv.yml --graph From the returned output we can see that our NetBox instance has returned the data expected grouped the devices by device_roles and sites : @all: |--@device_roles_access: | |--sw3 | |--sw4 |--@device_roles_access_switch: | |--SWITCH-1 |--@device_roles_distribution: | |--sw1 | |--sw2 |--@device_roles_security_appliance: | |--SEC-APP-1 |--@device_roles_wireless_ap: | |--AP-1 |--@sites_cisco_devnet: | |--sw1 | |--sw2 | |--sw3 | |--sw4 |--@sites_meraki_sandbox: | |--AP-1 | |--SEC-APP-1 | |--SWITCH-1 |--@ungrouped: To list all the devices in the inventory, use the same command, but with the --list suffix: ansible-inventory -i netbox_inv.yml --list The output below has been shortened to show the inventory data returned for a single device, and all of this can be used in further playbooks to automate operations against the target device: \"sw1\": { \"ansible_host\": \"10.10.20.175\", \"custom_fields\": { \"ccc_device_id\": \"32446e0a-032b-4724-93e9-acbbab47371b\", \"cisco_catalyst_center\": \"sandboxdnac.cisco.com\" }, \"device_roles\": [ \"distribution\" ], \"device_types\": [ \"c9kv-uadp-8p\" ], \"is_virtual\": false, \"local_context_data\": [ null ], \"locations\": [], \"manufacturers\": [ \"cisco\" ], \"platforms\": [ \"ios-xe\" ], \"primary_ip4\": \"10.10.20.175\", \"regions\": [], \"serial\": \"9SB9FYAFA2O\", \"services\": [], \"site_groups\": [], \"sites\": [ \"cisco-devnet\" ], \"status\": { \"label\": \"Active\", \"value\": \"active\" }, \"tags\": [] } To run a playbook that uses the dynamic inventory, specify the inventory file when you run the playbook: ansible-playbook -i netbox_inv.yml <PLAYBOOK NAME> To target hosts or groups from the inventory in your playbook, reference the hosts or groups as normal in the playbook: --- - name: Playbook using NetBox Inventory Plugin for Ansible hosts: device_roles_distribution, device_roles_access Use Case 2 - Define Intended Network State in NetBox Define the intended state of your network in NetBox, by interacting with the NetBox database to define objects and their associated state in the following ways: Make sure objects exit Update objects if they do exist Remove objects if they do not not exist For example, to make sure a new aggregate network prefix exists: tasks: - name: Create aggregate within NetBox with only required information netbox.netbox.netbox_aggregate: netbox_url: http://netbox.local netbox_token: thisIsMyToken data: prefix: 192.168.0.0/16 rir: Test RIR state: present The example playbook populate_netbox_ipam.yml will ensure that the RFC1918 IPv4 aggregates exist in NetBox, as well as some predefined Prefix and VLAN Roles: # populate_netbox_ipam.yml --- - name: PLAY 1 - Create RIRs connection: local hosts: localhost gather_facts: False roles: - role: create_rirs tags: rirs - name: PLAY 2 - Create Aggregates connection: local hosts: localhost gather_facts: False roles: - role: create_aggregates tags: aggregates - name: PLAY 3 - Create Prefix and VLAN Roles connection: local hosts: localhost gather_facts: False roles: - role: create_prefix_and_vlan_roles tags: prefix_and_roles The playbook is modularized using roles , for example the file roles/create_aggregates/tasks/main.yml loops over the list of aggregates defined in the file roles/create_aggregates/vars/main.yml : # roles/create_aggregates/tasks/main.yml --- - name: Create Aggregates within NetBox netbox.netbox.netbox_aggregate: netbox_url: \"{{ lookup('ansible.builtin.env', 'NETBOX_API') }}\" netbox_token: \"{{ lookup('ansible.builtin.env', 'NETBOX_TOKEN') }}\" data: \"{{ aggregate }}\" state: present loop: \"{{ ipam_aggregates }}\" loop_control: loop_var: aggregate label: \"{{ aggregate['prefix']}}\" # roles/create_aggregates/vars/main.yml --- ipam_aggregates: - prefix: 10.0.0.0/8 rir: RFC 1918 - prefix: 172.16.0.0/12 rir: RFC 1918 - prefix: 192.168.0.0/16 rir: RFC 1918 Running the playbook results in the following output: ansible-playbook populate_netbox_ipam.yml PLAY [PLAY 1 - Create RIRs] *********************************************************************************************************************************** TASK [create_rirs : Create RIRs] ****************************************************************************************************************************** ok: [localhost] => (item=RFC 1918) PLAY [PLAY 2 - Create Aggregates] ***************************************************************************************************************************** TASK [create_aggregates : Create Aggregates within NetBox] **************************************************************************************************** ok: [localhost] => (item=10.0.0.0/8) ok: [localhost] => (item=172.16.0.0/12) ok: [localhost] => (item=192.168.0.0/16) PLAY [PLAY 3 - Create Prefix and VLAN Roles] ****************************************************************************************************************** TASK [create_prefix_and_vlan_roles : Create Prefix and VLAN Roles within NetBox] ****************************************************************************** ok: [localhost] => (item=Branch_Data) ok: [localhost] => (item=Branch_Voice) ok: [localhost] => (item=Branch_WiFi) ok: [localhost] => (item=Guest_WiFi) ok: [localhost] => (item=Network_Management) ok: [localhost] => (item=Point_to_Point) PLAY RECAP **************************************************************************************************************************************************** localhost : ok=3 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 Use Case 3 - Query and Return Elements from NetBox Use the Lookup Plugin to query NetBox and return data to drive network automation, such as lists of devices, device configurations, prefixes and IP addresses etc. In the example playbook lookup_site_and_device_data.yml we first of all query the NetBox sites API endpoint and then print a list of all the sites. Then we query the devices API endpoint, filter on the site cisco-devnet and print a list of the devices at that site: # lookup_site_and_device_data.yml --- - name: Lookup NetBox Site and Device Data hosts: localhost gather_facts: no vars: netbox_url: \"{{ lookup('ansible.builtin.env', 'NETBOX_API') }}\" netbox_token: \"{{ lookup('ansible.builtin.env', 'NETBOX_TOKEN') }}\" tasks: - name: \"Query NetBox for all sites\" set_fact: sites: \"{{ query('netbox.netbox.nb_lookup', 'sites', api_endpoint=netbox_url, token=netbox_token) }}\" - name: \"Print the list of sites\" debug: msg: \"{{ sites | json_query('[*].value.name') }}\" - name: \"Query NetBox for devices at the Cisco DevNet Site\" set_fact: devices: \"{{ query('netbox.netbox.nb_lookup', 'devices', api_filter='site=cisco-devnet', api_endpoint=netbox_url, token=netbox_token) }}\" - name: \"Print a list of devices at Cisco DevNet Site\" debug: msg: \"{{ devices | json_query('[*].value.name') }}\" The playbook run results in the following output: ansible-playbook lookup_site_and_device_data.yml PLAY [Lookup NetBox Site and Device Data] ********************************************************************************************************************* TASK [Query NetBox for all sites] ***************************************************************************************************************************** ok: [localhost] TASK [Print the list of sites] ******************************************************************************************************************************** ok: [localhost] => msg: - Cisco DevNet - Meraki Sandbox TASK [Query NetBox for devices at the Cisco DevNet Site] ****************************************************************************************************** ok: [localhost] TASK [Print a list of devices at Cisco DevNet Site] *********************************************************************************************************** ok: [localhost] => msg: - sw1 - sw2 - sw3 - sw4 PLAY RECAP **************************************************************************************************************************************************** localhost : ok=4 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 References Collection on Ansible Galaxy Collection on Ansible Automation Hub Docs for NetBox Inventory Plugin Docs for NetBox Lookup Plugin","title":"NetBox Ansible Collection"},{"location":"netbox-integrations/netbox-ansible-collection/#netbox-integrations","text":"","title":"NetBox Integrations"},{"location":"netbox-integrations/netbox-ansible-collection/#netbox-ansible-collection-quick-start","text":"A short guide to getting started with the Ansible Collection for Netbox. The collection is available from Ansible Galaxy , and NetBox Labs and Red Hat customers can access the certified and supported collection, via Ansible Automation Hub . This doc is based on the Galaxy installation and shows how to use the collection from the command line, rather than from within Ansible Automation Hub.","title":"NetBox Ansible Collection - Quick Start"},{"location":"netbox-integrations/netbox-ansible-collection/#code-examples","text":"All code used in the examples below can be found in the NetBox Learning git repository , in the directory netbox-ansible-collection-quick-start .","title":"Code Examples"},{"location":"netbox-integrations/netbox-ansible-collection/#collection-overview","text":"The NetBox Ansible project provides an Ansible collection for interacting with NetBox, the leading solution for modeling and documenting modern networks. By combining the traditional disciplines of IP address management (IPAM) and datacenter infrastructure management (DCIM) with powerful APIs and extensions, NetBox provides the ideal \"source of truth\" to power network automation. This Ansible collection consists of a set of modules to define the intended network state in NetBox, along with plugins to drive automation of the network using data from NetBox.","title":"Collection Overview"},{"location":"netbox-integrations/netbox-ansible-collection/#requirements","text":"You must be running one of the two most recent releases of NetBox A NetBox write-enabled API token when using modules or a read-only token for the nb_lookup and nb_inventory plugins. Python 3.10+ Python modules: pytz pynetbox Ansible 2.15+ Note This guide assumes you have a working NetBox installation, populated with some device data of your own. The easiest way to do this is to set up a NetBox Cloud Free Plan instance, and you can be up an running in seconds. The NetBox instance used in this example has 2 sites with some devices already added:","title":"Requirements"},{"location":"netbox-integrations/netbox-ansible-collection/#getting-started-with-the-collection","text":"","title":"Getting Started with the Collection"},{"location":"netbox-integrations/netbox-ansible-collection/#installation-and-setup","text":"Clone the Git repo and change into the netbox-ansible-collection-quick-start directory: git clone https://github.com/netboxlabs/netbox-learning.git cd netbox-learning/netbox-ansible-collection-quick-start Create and activate a Python 3 virtual environment: python3 -m venv ./venv source venv/bin/activate Install Python Modules and Ansible pip install pytz pip install pynetbox pip install ansible Install the NetBox Ansible Collection. Before using this collection, you need to install it with the Ansible Galaxy command-line tool: ansible-galaxy collection install netbox.netbox 5. Set environment variables for your NetBox API token and URL of your NetBox instance: export NETBOX_API=<YOUR_NETBOX_URL> (note - must include http:// or https://) export NETBOX_TOKEN=<YOUR_NETBOX_API_TOKEN>","title":"Installation and Setup"},{"location":"netbox-integrations/netbox-ansible-collection/#use-case-1-netbox-as-a-dynamic-inventory-source-for-ansible","text":"The Inventory Plugin component of the collection is used to dynamically generate the inventory from NetBox to be used in Ansible playbooks. In the example ansible.cfg file we are specifying that the inventory should be sourced from the file netbox_inv.yml : # ansible.cfg [defaults] inventory = ./netbox_inv.yml The plugin is highly configurable in terms of defining returned hosts and groupings etc in the inventory, so please consult the docs . In this case we are grouping the returned hosts by the device_roles and sites as defined in the NetBox database: # netbox_inv.yml plugin: netbox.netbox.nb_inventory validate_certs: False group_by: - device_roles - sites To view a graph of the inventory retrieved from NetBox, you can run the ansible-inventory command and use the -i flag to specify the netbox_inv.yml file as the source, followed by --graph : ansible-inventory -i netbox_inv.yml --graph From the returned output we can see that our NetBox instance has returned the data expected grouped the devices by device_roles and sites : @all: |--@device_roles_access: | |--sw3 | |--sw4 |--@device_roles_access_switch: | |--SWITCH-1 |--@device_roles_distribution: | |--sw1 | |--sw2 |--@device_roles_security_appliance: | |--SEC-APP-1 |--@device_roles_wireless_ap: | |--AP-1 |--@sites_cisco_devnet: | |--sw1 | |--sw2 | |--sw3 | |--sw4 |--@sites_meraki_sandbox: | |--AP-1 | |--SEC-APP-1 | |--SWITCH-1 |--@ungrouped: To list all the devices in the inventory, use the same command, but with the --list suffix: ansible-inventory -i netbox_inv.yml --list The output below has been shortened to show the inventory data returned for a single device, and all of this can be used in further playbooks to automate operations against the target device: \"sw1\": { \"ansible_host\": \"10.10.20.175\", \"custom_fields\": { \"ccc_device_id\": \"32446e0a-032b-4724-93e9-acbbab47371b\", \"cisco_catalyst_center\": \"sandboxdnac.cisco.com\" }, \"device_roles\": [ \"distribution\" ], \"device_types\": [ \"c9kv-uadp-8p\" ], \"is_virtual\": false, \"local_context_data\": [ null ], \"locations\": [], \"manufacturers\": [ \"cisco\" ], \"platforms\": [ \"ios-xe\" ], \"primary_ip4\": \"10.10.20.175\", \"regions\": [], \"serial\": \"9SB9FYAFA2O\", \"services\": [], \"site_groups\": [], \"sites\": [ \"cisco-devnet\" ], \"status\": { \"label\": \"Active\", \"value\": \"active\" }, \"tags\": [] } To run a playbook that uses the dynamic inventory, specify the inventory file when you run the playbook: ansible-playbook -i netbox_inv.yml <PLAYBOOK NAME> To target hosts or groups from the inventory in your playbook, reference the hosts or groups as normal in the playbook: --- - name: Playbook using NetBox Inventory Plugin for Ansible hosts: device_roles_distribution, device_roles_access","title":"Use Case 1 - NetBox as a Dynamic Inventory Source for Ansible"},{"location":"netbox-integrations/netbox-ansible-collection/#use-case-2-define-intended-network-state-in-netbox","text":"Define the intended state of your network in NetBox, by interacting with the NetBox database to define objects and their associated state in the following ways: Make sure objects exit Update objects if they do exist Remove objects if they do not not exist For example, to make sure a new aggregate network prefix exists: tasks: - name: Create aggregate within NetBox with only required information netbox.netbox.netbox_aggregate: netbox_url: http://netbox.local netbox_token: thisIsMyToken data: prefix: 192.168.0.0/16 rir: Test RIR state: present The example playbook populate_netbox_ipam.yml will ensure that the RFC1918 IPv4 aggregates exist in NetBox, as well as some predefined Prefix and VLAN Roles: # populate_netbox_ipam.yml --- - name: PLAY 1 - Create RIRs connection: local hosts: localhost gather_facts: False roles: - role: create_rirs tags: rirs - name: PLAY 2 - Create Aggregates connection: local hosts: localhost gather_facts: False roles: - role: create_aggregates tags: aggregates - name: PLAY 3 - Create Prefix and VLAN Roles connection: local hosts: localhost gather_facts: False roles: - role: create_prefix_and_vlan_roles tags: prefix_and_roles The playbook is modularized using roles , for example the file roles/create_aggregates/tasks/main.yml loops over the list of aggregates defined in the file roles/create_aggregates/vars/main.yml : # roles/create_aggregates/tasks/main.yml --- - name: Create Aggregates within NetBox netbox.netbox.netbox_aggregate: netbox_url: \"{{ lookup('ansible.builtin.env', 'NETBOX_API') }}\" netbox_token: \"{{ lookup('ansible.builtin.env', 'NETBOX_TOKEN') }}\" data: \"{{ aggregate }}\" state: present loop: \"{{ ipam_aggregates }}\" loop_control: loop_var: aggregate label: \"{{ aggregate['prefix']}}\" # roles/create_aggregates/vars/main.yml --- ipam_aggregates: - prefix: 10.0.0.0/8 rir: RFC 1918 - prefix: 172.16.0.0/12 rir: RFC 1918 - prefix: 192.168.0.0/16 rir: RFC 1918 Running the playbook results in the following output: ansible-playbook populate_netbox_ipam.yml PLAY [PLAY 1 - Create RIRs] *********************************************************************************************************************************** TASK [create_rirs : Create RIRs] ****************************************************************************************************************************** ok: [localhost] => (item=RFC 1918) PLAY [PLAY 2 - Create Aggregates] ***************************************************************************************************************************** TASK [create_aggregates : Create Aggregates within NetBox] **************************************************************************************************** ok: [localhost] => (item=10.0.0.0/8) ok: [localhost] => (item=172.16.0.0/12) ok: [localhost] => (item=192.168.0.0/16) PLAY [PLAY 3 - Create Prefix and VLAN Roles] ****************************************************************************************************************** TASK [create_prefix_and_vlan_roles : Create Prefix and VLAN Roles within NetBox] ****************************************************************************** ok: [localhost] => (item=Branch_Data) ok: [localhost] => (item=Branch_Voice) ok: [localhost] => (item=Branch_WiFi) ok: [localhost] => (item=Guest_WiFi) ok: [localhost] => (item=Network_Management) ok: [localhost] => (item=Point_to_Point) PLAY RECAP **************************************************************************************************************************************************** localhost : ok=3 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0","title":"Use Case 2 - Define Intended Network State in NetBox"},{"location":"netbox-integrations/netbox-ansible-collection/#use-case-3-query-and-return-elements-from-netbox","text":"Use the Lookup Plugin to query NetBox and return data to drive network automation, such as lists of devices, device configurations, prefixes and IP addresses etc. In the example playbook lookup_site_and_device_data.yml we first of all query the NetBox sites API endpoint and then print a list of all the sites. Then we query the devices API endpoint, filter on the site cisco-devnet and print a list of the devices at that site: # lookup_site_and_device_data.yml --- - name: Lookup NetBox Site and Device Data hosts: localhost gather_facts: no vars: netbox_url: \"{{ lookup('ansible.builtin.env', 'NETBOX_API') }}\" netbox_token: \"{{ lookup('ansible.builtin.env', 'NETBOX_TOKEN') }}\" tasks: - name: \"Query NetBox for all sites\" set_fact: sites: \"{{ query('netbox.netbox.nb_lookup', 'sites', api_endpoint=netbox_url, token=netbox_token) }}\" - name: \"Print the list of sites\" debug: msg: \"{{ sites | json_query('[*].value.name') }}\" - name: \"Query NetBox for devices at the Cisco DevNet Site\" set_fact: devices: \"{{ query('netbox.netbox.nb_lookup', 'devices', api_filter='site=cisco-devnet', api_endpoint=netbox_url, token=netbox_token) }}\" - name: \"Print a list of devices at Cisco DevNet Site\" debug: msg: \"{{ devices | json_query('[*].value.name') }}\" The playbook run results in the following output: ansible-playbook lookup_site_and_device_data.yml PLAY [Lookup NetBox Site and Device Data] ********************************************************************************************************************* TASK [Query NetBox for all sites] ***************************************************************************************************************************** ok: [localhost] TASK [Print the list of sites] ******************************************************************************************************************************** ok: [localhost] => msg: - Cisco DevNet - Meraki Sandbox TASK [Query NetBox for devices at the Cisco DevNet Site] ****************************************************************************************************** ok: [localhost] TASK [Print a list of devices at Cisco DevNet Site] *********************************************************************************************************** ok: [localhost] => msg: - sw1 - sw2 - sw3 - sw4 PLAY RECAP **************************************************************************************************************************************************** localhost : ok=4 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0","title":"Use Case 3 - Query and Return Elements from NetBox"},{"location":"netbox-integrations/netbox-ansible-collection/#references","text":"Collection on Ansible Galaxy Collection on Ansible Automation Hub Docs for NetBox Inventory Plugin Docs for NetBox Lookup Plugin","title":"References"},{"location":"netbox-integrations/pyats/","text":"Getting Started With NetBox, PyATS and Genie Learn More You can view an on-demand Webinar Getting Started with Network Test Automation: NetBox + pyATS hosted by NetBox Labs. Code Examples All code used in the examples below can be found in the NetBox Learning git repository , in the directory netbox-pyats-webinar . Set Up and Installation Clone the Git repo and change into the netbox-pyats-webinar directory: git clone https://github.com/netboxlabs/netbox-learning.git cd netbox-learning/netbox-pyats-webinar Create and activate Python 3 virtual environment: python3 -m venv ./venv source venv/bin/activate Upgrade pip: python3 -m pip install --upgrade pip Install PyATS: As per the official documentation , there are a options to perform a minimal installation (option 1) or a full installation (opton 2). Option 1 Minimal install that includes the Genie library and that allows you to use the interactive testbed creation command to create your testbed files from NetBox: pip install pyats[library] pip install pyats.contrib Option 2 Full installation that includes all packages and libraries: pip install pyats[full] Tip If you are using Zsh on a Mac then you need to quote the install string. pip install \"pyats[full]\" Note If you plan to run the example script ospf_neighbor_table.py then you will also need to install the prettytable library with pip install prettytable or you can simply run the command pip install -r requirements.txt to install this along with pyATS, Genie and the contrib library. There is also a PyATS Docker Image . This command will pull down the container if you don't have it locally and drop you into a Bash shell: docker run -it ciscotestautomation/pyats:latest /bin/bash Lab Network Our lab network consists of 2 x Cisco CSR100V routers and they are documented in NetBox under the Site PyATS Webinar and are directly connected to each other over port GigabitEthernet2 on the 192.168.1.0/30 subnet. They are both running OSPF, and you can find the the configuration for this in the initial_device_configs.md file: Generating The testbed file Dynamically from NetBox Inventory Option 1 Use the pyats create testbed netbox command to build your testbed file. Note that where a value is prefixed with os.getenv or %ENV then these values are being pulled in from the local environment variables that you need to set with the export command eg. export NETBOX_URL=https://example.cloud.netboxapp.com/ , export DEF_PYATS_USER=admin : pyats create testbed netbox \\ --output testbed.yaml \\ --netbox-url=${NETBOX_URL} \\ --user-token=${NETBOX_USER_TOKEN} \\ --def_user='%ENV{DEF_PYATS_USER}' \\ --def_pass='%ENV{DEF_PYATS_PASS}' \\ --url_filter='site=pyats-webinar' \\ --topology In this example we are generating a testbed file called testbed.yaml and filtering NetBox by the site name pyats-webinar . When you hit enter the output will look like this: Begin retrieving data from netbox... Configuring testbed default credentials. Retrieving associated data for CSR1... Retrieving associated data for CSR2... Testbed file generated: testbed.yaml Option 2 Run the generate_testbed_file.py Python script. Note that where a value is prefixed with os.getenv or %ENV then these values are being pulled in from the local environment variables that you need to set with the export command eg. export NETBOX_URL=https://example.cloud.netboxapp.com/ , export DEF_PYATS_USER=admin . In this script we are generating a testbed file called testbed.yaml and filtering NetBox by the site name pyats-webinar , but you could just as easily filter on other fields as in the examples commented out: # Description: This script generates a testbed file based on the Netbox data # using the pyATS framework. It uses the Netbox class from the # pyats.contrib.creators.netbox module to create the testbed file. # Import the necessary libraries from pyats.contrib.creators.netbox import Netbox import yaml import os # Define Netbox URL, user token, and default credentials netbox_url = os.getenv('NETBOX_URL') user_token = os.getenv('NETBOX_USER_TOKEN') def_user = '%ENV{DEF_PYATS_USER}' def_pass = '%ENV{DEF_PYATS_PASS}' url_filter = 'site=pyats-webinar' # url_filter = 'site_id=68' # url_filter = 'site=pyats-webinar&os=ios-xe' # url_filter = 'platform=ios-xe' # Create testbed object and build data structure nb_testbed = Netbox( netbox_url=netbox_url, user_token=user_token, def_user=def_user, def_pass=def_pass, url_filter=url_filter, ssl_verify=False, topology=True ) # Generate testbed file tb = nb_testbed._generate() tb_yaml = yaml.dump(tb) with open(\"testbed.yaml\", \"w\") as f: f.write(tb_yaml) The resulting testbed file produced by either option will look something like this, depending on your network. Note that as we included the --topology switch the testbed file output includes the interfaces and connections from NetBox also: devices: CSR1: alias: CSR1 connections: cli: ip: 10.90.0.35 protocol: ssh credentials: default: password: '%ENV{DEF_PYATS_PASS}' username: '%ENV{DEF_PYATS_USER}' os: iosxe platform: iosxe type: CSR1000V CSR2: alias: CSR2 connections: cli: ip: 10.90.0.36 protocol: ssh credentials: default: password: '%ENV{DEF_PYATS_PASS}' username: '%ENV{DEF_PYATS_USER}' os: iosxe platform: iosxe type: CSR1000V testbed: credentials: default: password: '%ENV{DEF_PYATS_PASS}' username: '%ENV{DEF_PYATS_USER}' topology: CSR1: interfaces: GigabitEthernet1: alias: CSR1_GigabitEthernet1 ipv4: 10.90.0.35/27 type: ethernet GigabitEthernet2: alias: CSR1_GigabitEthernet2 ipv4: 192.168.1.1/30 link: cable_num_34 type: ethernet GigabitEthernet3: alias: CSR1_GigabitEthernet3 type: ethernet GigabitEthernet4: alias: CSR1_GigabitEthernet4 type: ethernet GigabitEthernet5: alias: CSR1_GigabitEthernet5 type: ethernet CSR2: interfaces: GigabitEthernet1: alias: CSR2_GigabitEthernet1 ipv4: 10.90.0.36/27 type: ethernet GigabitEthernet2: alias: CSR2_GigabitEthernet2 ipv4: 192.168.1.2/30 link: cable_num_34 type: ethernet GigabitEthernet3: alias: CSR2_GigabitEthernet3 type: ethernet GigabitEthernet4: alias: CSR2_GigabitEthernet4 type: ethernet GigabitEthernet5: alias: CSR2_GigabitEthernet5 type: ethernet Structured Data Vs Unstructured Data When you run a command at the CLI of a network device, you get unstructured data back as the response, which is just a blob of text: CSR1#sh ip interface brief Interface IP-Address OK? Method Status Protocol GigabitEthernet1 10.0.0.15 YES manual up up GigabitEthernet2 192.168.1.1 YES manual up up Loopback0 1.1.1.1 YES manual up up This is great for humans, as we can read this, but a computer cannot understand this data. Also if the next version of the OS you are using makes a change to the way that the output is formatted then you will have a problem and have to re-write your scripts to handle this. This is where the Genie parser comes into play as it will parse the output into structured data. The data is then represented using key/value pairs in JSON format that can be used by a computer: { \"interface\": { \"GigabitEthernet1\": { \"interface_is_ok\": \"YES\", \"ip_address\": \"10.0.0.15\", \"method\": \"manual\", \"protocol\": \"up\", \"status\": \"up\" }, \"GigabitEthernet2\": { \"interface_is_ok\": \"YES\", \"ip_address\": \"192.168.1.1\", \"method\": \"manual\", \"protocol\": \"up\", \"status\": \"up\" }, \"Loopback0\": { \"interface_is_ok\": \"YES\", \"ip_address\": \"1.1.1.1\", \"method\": \"manual\", \"protocol\": \"up\", \"status\": \"up\" } } } Running Your First Tests With The Genie CLI Genie Parsing There are parsers available for a large number of network OS's (not just Cisco), and you can view the complete list here In this example we will run the genie parse command to parse the output of the show ip ospf neighbor command and limit it to just device CSR1 : genie parse 'show ip ospf neighbor' --testbed-file testbed.yaml --device CSR1 0%| | 0/1 [00:00<?, ?it/s]{ \"interfaces\": { \"GigabitEthernet2\": { \"neighbors\": { \"2.2.2.2\": { \"address\": \"192.168.1.2\", \"dead_time\": \"00:00:34\", \"priority\": 1, \"state\": \"FULL/DR\" } } } } } This will output the parsed data to your terminal, but if you want to save the output just append the directory you wish to save it to with the --output switch. This will save both the _console file (the unstructured data) and the _parsed file (the structured data), along with the connection_ log (the raw output of the full connection process) into the chosen directory: genie parse 'show ip ospf neighbor' --testbed-file testbed.yaml --device CSR1 --output csr1 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:01<00:00, 1.01s/it] +==============================================================================+ | Genie Parse Summary for CSR1 | +==============================================================================+ | Connected to CSR1 | | - Log: csr1/connection_CSR1.txt | |------------------------------------------------------------------------------| | Parsed command 'show ip ospf neighbor' | | - Parsed structure: csr1/CSR1_show-ip-ospf-neighbor_parsed.txt | | - Device Console: csr1/CSR1_show-ip-ospf-neighbor_console.txt | |------------------------------------------------------------------------------| Genie Learning In this example we will run the genie learn command to learn all about routing and ospf for both devices in our testbed file. We will also save the output into directory called pre-change . Genie will automagically create directories for us if they don't already exist. For reference if you run the genie learn all command then for IOS-XE devices the list of features learned is: acl, arp, bgp, device, dot1x, eigrp, fdb, hsrp, igmp, interface, isis, lag, lisp, lldp, mcast, mld, msdp, nd, ntp, ospf, pim, platform, prefix_list, rip, route_policy, routing, static_routing, stp, terminal, utils, vlan, vrf, vxlan, config genie learn routing ospf --testbed-file testbed.yaml --output pre-change Learning '['routing', 'ospf']' on devices '['CSR1', 'CSR2']' 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:11<00:00, 5.85s/it] +==============================================================================+ | Genie Learn Summary for device CSR1 | +==============================================================================+ | Connected to CSR1 | | - Log: pre-change/connection_CSR1.txt | |------------------------------------------------------------------------------| | Learnt feature 'routing' | | - Ops structure: pre-change/routing_iosxe_CSR1_ops.txt | | - Device Console: pre-change/routing_iosxe_CSR1_console.txt | |------------------------------------------------------------------------------| | Learnt feature 'ospf' | | - Ops structure: pre-change/ospf_iosxe_CSR1_ops.txt | | - Device Console: pre-change/ospf_iosxe_CSR1_console.txt | |==============================================================================| +==============================================================================+ | Genie Learn Summary for device CSR2 | +==============================================================================+ | Connected to CSR2 | | - Log: pre-change/connection_CSR2.txt | |------------------------------------------------------------------------------| | Learnt feature 'routing' | | - Ops structure: pre-change/routing_iosxe_CSR2_ops.txt | | - Device Console: pre-change/routing_iosxe_CSR2_console.txt | |------------------------------------------------------------------------------| | Learnt feature 'ospf' | | - Ops structure: pre-change/ospf_iosxe_CSR2_ops.txt | | - Device Console: pre-change/ospf_iosxe_CSR2_console.txt | |==============================================================================| Making a Change to The Network Let's make a small change to the CSR2 router in our test network, and remove the network 2.2.2.2 0.0.0.0 area 0 statement from the OSPF configuration: CSR2#conf t Enter configuration commands, one per line. End with CNTL/Z. CSR2(config)#router ospf 1 CSR2(config-router)#no network 2.2.2.2 0.0.0.0 area 0 Next lets re-learn routing and ospf for both devices in our testbed file. We will also save the output into directory called post-change : genie learn routing ospf --testbed-file testbed.yaml --output post-change Learning '['routing', 'ospf']' on devices '['CSR1', 'CSR2']' 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:11<00:00, 5.84s/it] +==============================================================================+ | Genie Learn Summary for device CSR1 | +==============================================================================+ | Connected to CSR1 | | - Log: post-change/connection_CSR1.txt | |------------------------------------------------------------------------------| | Learnt feature 'routing' | | - Ops structure: post-change/routing_iosxe_CSR1_ops.txt | | - Device Console: post-change/routing_iosxe_CSR1_console.txt | |------------------------------------------------------------------------------| | Learnt feature 'ospf' | | - Ops structure: post-change/ospf_iosxe_CSR1_ops.txt | | - Device Console: post-change/ospf_iosxe_CSR1_console.txt | |==============================================================================| +==============================================================================+ | Genie Learn Summary for device CSR2 | +==============================================================================+ | Connected to CSR2 | | - Log: post-change/connection_CSR2.txt | |------------------------------------------------------------------------------| | Learnt feature 'routing' | | - Ops structure: post-change/routing_iosxe_CSR2_ops.txt | | - Device Console: post-change/routing_iosxe_CSR2_console.txt | |------------------------------------------------------------------------------| | Learnt feature 'ospf' | | - Ops structure: post-change/ospf_iosxe_CSR2_ops.txt | | - Device Console: post-change/ospf_iosxe_CSR2_console.txt | |==============================================================================| Genie Diff Now let's use the genie diff command to tell us what changed in our network, and we will store the output in a directory called routing-diff : genie diff pre-change post-change --output diff 1it [00:00, 333.44it/s] +==============================================================================+ | Genie Diff Summary between directories pre-change/ and post-change/ | +==============================================================================+ | File: routing_iosxe_CSR2_ops.txt | | - Identical | |------------------------------------------------------------------------------| | File: ospf_iosxe_CSR1_ops.txt | | - Identical | |------------------------------------------------------------------------------| | File: routing_iosxe_CSR1_ops.txt | | - Diff can be found at diff/diff_routing_iosxe_CSR1_ops.txt | |------------------------------------------------------------------------------| | File: ospf_iosxe_CSR2_ops.txt | | - Diff can be found at diff/diff_ospf_iosxe_CSR2_ops.txt | |------------------------------------------------------------------------------| There are differences in the outputs of both the routing_iosxe_CSR1_ops.txt and ospf_iosxe_CSR2_ops.txt files and we can view the contents of those files to see what has changed: cat diff/diff_routing_iosxe_CSR1_ops.txt --- pre-change/routing_iosxe_CSR1_ops.txt +++ post-change/routing_iosxe_CSR1_ops.txt info: vrf: default: address_family: ipv4: routes: - 2.2.2.2/32: - active: True - metric: 2 - next_hop: - next_hop_list: - 1: - index: 1 - next_hop: 192.168.1.2 - outgoing_interface: GigabitEthernet2 - updated: 03:32:43 - route: 2.2.2.2/32 - route_preference: 110 - source_protocol: ospf - source_protocol_codes: O% cat diff/diff_ospf_iosxe_CSR2_ops.txt --- pre-change/ospf_iosxe_CSR2_ops.txt +++ post-change/ospf_iosxe_CSR2_ops.txt info: vrf: default: address_family: ipv4: instance: 1: areas: 0.0.0.0: interfaces: - Loopback0: - bfd: - enable: False - cost: 1 - demand_circuit: False - enable: True - interface_type: loopback - name: Loopback0% As we can see, CSR1 has lost the the route to the 2.2.2.2/32 prefix and on CSR2 the interface lo0 has been removed from OSPF area 0 . pyATS and Python As you would expect, it is also very easy to work with pyATS and python. Type python in your terminal, and then start by importing the load module from the genie.testbed library and load the testbed file: from genie.testbed import load testbed = load('testbed.yaml') Then connect to the CSR1 device: device = testbed.devices['CSR1'] device.connect() Then parse the command show ip interface brief and print the output nicely using the pprint library: parsed_data = device.parse('show ip interface brief') from pprint import pprint pprint(parsed_data) {'interface': {'GigabitEthernet1': {'interface_is_ok': 'YES', 'ip_address': '10.0.0.15', 'method': 'manual', 'protocol': 'up', 'status': 'up'}, 'GigabitEthernet2': {'interface_is_ok': 'YES', 'ip_address': '192.168.1.1', 'method': 'manual', 'protocol': 'up', 'status': 'up'}, 'Loopback0': {'interface_is_ok': 'YES', 'ip_address': '1.1.1.1', 'method': 'manual', 'protocol': 'up', 'status': 'up'}}} Lastly, close the connection to the device: device.disconnect() As you can imagine, the possibilities are endless and you can see an example of a script that gets and prints OSPF Neighbor table for a given device in the file ospf_neighbor_table.py . Run the script and you will get a nicely formatted table of the OSPF neighbors for CRS1: python ospf_neighbor_table.py OSPF Neighbor Table for CSR1 +------------------+----------+-------------+---------+ | Interface | Neighbor | Address | State | +------------------+----------+-------------+---------+ | GigabitEthernet2 | 2.2.2.2 | 192.168.1.2 | FULL/DR | +------------------+----------+-------------+---------+ pyATS Test Scripts and Jobs So far we have only scratched the surface of what you can do with pyATS, and test scripts will take your automated testing to the next level. Test scripts are written and executed with the AEtest Python package I have included an example test script called connectivity_check.py , which is adapted from the example script in the official documentation . This script tests that both CSR1 and CSR2 can ping each other's loopback addresses. Test scripts are structured Python files that contain/describe the testing you want to do. A clean, elegant test script is scalable, and generates easy-to-read test results and logs. To run the example test script, you must also specify the testbed file that is to be used, for example: python connectivity_check.py --testbed testbed.yaml Once the test script has been run then the results are displayed in the output: 2024-04-23T11:50:16: %AETEST-INFO: +------------------------------------------------------------------------------+ 2024-04-23T11:50:16: %AETEST-INFO: | Detailed Results | 2024-04-23T11:50:16: %AETEST-INFO: +------------------------------------------------------------------------------+ 2024-04-23T11:50:16: %AETEST-INFO: SECTIONS/TESTCASES RESULT 2024-04-23T11:50:16: %AETEST-INFO: -------------------------------------------------------------------------------- 2024-04-23T11:50:16: %AETEST-INFO: . 2024-04-23T11:50:16: %AETEST-INFO: |-- common_setup PASSED 2024-04-23T11:50:16: %AETEST-INFO: | |-- check_topology PASSED 2024-04-23T11:50:16: %AETEST-INFO: | `-- establish_connections PASSED 2024-04-23T11:50:16: %AETEST-INFO: | |-- Step 1: Connecting to CSR1 PASSED 2024-04-23T11:50:16: %AETEST-INFO: | `-- Step 2: Connecting to CSR2 PASSED 2024-04-23T11:50:16: %AETEST-INFO: |-- PingTestcase[device=device1] PASSED 2024-04-23T11:50:16: %AETEST-INFO: | |-- ping[destination=192.168.1.1] PASSED 2024-04-23T11:50:16: %AETEST-INFO: | `-- ping[destination=192.168.1.2] PASSED 2024-04-23T11:50:16: %AETEST-INFO: |-- PingTestcase[device=device2] PASSED 2024-04-23T11:50:16: %AETEST-INFO: | |-- ping[destination=192.168.1.1] PASSED 2024-04-23T11:50:16: %AETEST-INFO: | `-- ping[destination=192.168.1.2] PASSED 2024-04-23T11:50:16: %AETEST-INFO: `-- common_cleanup PASSED 2024-04-23T11:50:16: %AETEST-INFO: `-- disconnect PASSED 2024-04-23T11:50:16: %AETEST-INFO: |-- Step 1: Disconnecting from CSR1 PASSED 2024-04-23T11:50:16: %AETEST-INFO: `-- Step 2: Disconnecting from CSR2 PASSED 2024-04-23T11:50:16: %AETEST-INFO: +------------------------------------------------------------------------------+ 2024-04-23T11:50:16: %AETEST-INFO: | Summary | 2024-04-23T11:50:16: %AETEST-INFO: +------------------------------------------------------------------------------+ 2024-04-23T11:50:16: %AETEST-INFO: Number of ABORTED 0 2024-04-23T11:50:16: %AETEST-INFO: Number of BLOCKED 0 2024-04-23T11:50:16: %AETEST-INFO: Number of ERRORED 0 2024-04-23T11:50:16: %AETEST-INFO: Number of FAILED 0 2024-04-23T11:50:16: %AETEST-INFO: Number of PASSED 4 2024-04-23T11:50:16: %AETEST-INFO: Number of PASSX 0 2024-04-23T11:50:16: %AETEST-INFO: Number of SKIPPED 0 2024-04-23T11:50:16: %AETEST-INFO: Total Number 4 2024-04-23T11:50:16: %AETEST-INFO: Success Rate 100.0% 2024-04-23T11:50:16: %AETEST-INFO: -------------------------------------------------------------------------------- pyATS Jobs take test scripts to another level and allow the execution of test scripts as tasks. This is beyond the scope of this document but you can read all about pyATS jobs in the official docs","title":"pyATS"},{"location":"netbox-integrations/pyats/#getting-started-with-netbox-pyats-and-genie","text":"Learn More You can view an on-demand Webinar Getting Started with Network Test Automation: NetBox + pyATS hosted by NetBox Labs.","title":"Getting Started With NetBox, PyATS and Genie"},{"location":"netbox-integrations/pyats/#code-examples","text":"All code used in the examples below can be found in the NetBox Learning git repository , in the directory netbox-pyats-webinar .","title":"Code Examples"},{"location":"netbox-integrations/pyats/#set-up-and-installation","text":"Clone the Git repo and change into the netbox-pyats-webinar directory: git clone https://github.com/netboxlabs/netbox-learning.git cd netbox-learning/netbox-pyats-webinar Create and activate Python 3 virtual environment: python3 -m venv ./venv source venv/bin/activate Upgrade pip: python3 -m pip install --upgrade pip Install PyATS: As per the official documentation , there are a options to perform a minimal installation (option 1) or a full installation (opton 2). Option 1 Minimal install that includes the Genie library and that allows you to use the interactive testbed creation command to create your testbed files from NetBox: pip install pyats[library] pip install pyats.contrib Option 2 Full installation that includes all packages and libraries: pip install pyats[full] Tip If you are using Zsh on a Mac then you need to quote the install string. pip install \"pyats[full]\" Note If you plan to run the example script ospf_neighbor_table.py then you will also need to install the prettytable library with pip install prettytable or you can simply run the command pip install -r requirements.txt to install this along with pyATS, Genie and the contrib library. There is also a PyATS Docker Image . This command will pull down the container if you don't have it locally and drop you into a Bash shell: docker run -it ciscotestautomation/pyats:latest /bin/bash","title":"Set Up and Installation"},{"location":"netbox-integrations/pyats/#lab-network","text":"Our lab network consists of 2 x Cisco CSR100V routers and they are documented in NetBox under the Site PyATS Webinar and are directly connected to each other over port GigabitEthernet2 on the 192.168.1.0/30 subnet. They are both running OSPF, and you can find the the configuration for this in the initial_device_configs.md file:","title":"Lab Network"},{"location":"netbox-integrations/pyats/#generating-the-testbed-file-dynamically-from-netbox-inventory","text":"Option 1 Use the pyats create testbed netbox command to build your testbed file. Note that where a value is prefixed with os.getenv or %ENV then these values are being pulled in from the local environment variables that you need to set with the export command eg. export NETBOX_URL=https://example.cloud.netboxapp.com/ , export DEF_PYATS_USER=admin : pyats create testbed netbox \\ --output testbed.yaml \\ --netbox-url=${NETBOX_URL} \\ --user-token=${NETBOX_USER_TOKEN} \\ --def_user='%ENV{DEF_PYATS_USER}' \\ --def_pass='%ENV{DEF_PYATS_PASS}' \\ --url_filter='site=pyats-webinar' \\ --topology In this example we are generating a testbed file called testbed.yaml and filtering NetBox by the site name pyats-webinar . When you hit enter the output will look like this: Begin retrieving data from netbox... Configuring testbed default credentials. Retrieving associated data for CSR1... Retrieving associated data for CSR2... Testbed file generated: testbed.yaml Option 2 Run the generate_testbed_file.py Python script. Note that where a value is prefixed with os.getenv or %ENV then these values are being pulled in from the local environment variables that you need to set with the export command eg. export NETBOX_URL=https://example.cloud.netboxapp.com/ , export DEF_PYATS_USER=admin . In this script we are generating a testbed file called testbed.yaml and filtering NetBox by the site name pyats-webinar , but you could just as easily filter on other fields as in the examples commented out: # Description: This script generates a testbed file based on the Netbox data # using the pyATS framework. It uses the Netbox class from the # pyats.contrib.creators.netbox module to create the testbed file. # Import the necessary libraries from pyats.contrib.creators.netbox import Netbox import yaml import os # Define Netbox URL, user token, and default credentials netbox_url = os.getenv('NETBOX_URL') user_token = os.getenv('NETBOX_USER_TOKEN') def_user = '%ENV{DEF_PYATS_USER}' def_pass = '%ENV{DEF_PYATS_PASS}' url_filter = 'site=pyats-webinar' # url_filter = 'site_id=68' # url_filter = 'site=pyats-webinar&os=ios-xe' # url_filter = 'platform=ios-xe' # Create testbed object and build data structure nb_testbed = Netbox( netbox_url=netbox_url, user_token=user_token, def_user=def_user, def_pass=def_pass, url_filter=url_filter, ssl_verify=False, topology=True ) # Generate testbed file tb = nb_testbed._generate() tb_yaml = yaml.dump(tb) with open(\"testbed.yaml\", \"w\") as f: f.write(tb_yaml) The resulting testbed file produced by either option will look something like this, depending on your network. Note that as we included the --topology switch the testbed file output includes the interfaces and connections from NetBox also: devices: CSR1: alias: CSR1 connections: cli: ip: 10.90.0.35 protocol: ssh credentials: default: password: '%ENV{DEF_PYATS_PASS}' username: '%ENV{DEF_PYATS_USER}' os: iosxe platform: iosxe type: CSR1000V CSR2: alias: CSR2 connections: cli: ip: 10.90.0.36 protocol: ssh credentials: default: password: '%ENV{DEF_PYATS_PASS}' username: '%ENV{DEF_PYATS_USER}' os: iosxe platform: iosxe type: CSR1000V testbed: credentials: default: password: '%ENV{DEF_PYATS_PASS}' username: '%ENV{DEF_PYATS_USER}' topology: CSR1: interfaces: GigabitEthernet1: alias: CSR1_GigabitEthernet1 ipv4: 10.90.0.35/27 type: ethernet GigabitEthernet2: alias: CSR1_GigabitEthernet2 ipv4: 192.168.1.1/30 link: cable_num_34 type: ethernet GigabitEthernet3: alias: CSR1_GigabitEthernet3 type: ethernet GigabitEthernet4: alias: CSR1_GigabitEthernet4 type: ethernet GigabitEthernet5: alias: CSR1_GigabitEthernet5 type: ethernet CSR2: interfaces: GigabitEthernet1: alias: CSR2_GigabitEthernet1 ipv4: 10.90.0.36/27 type: ethernet GigabitEthernet2: alias: CSR2_GigabitEthernet2 ipv4: 192.168.1.2/30 link: cable_num_34 type: ethernet GigabitEthernet3: alias: CSR2_GigabitEthernet3 type: ethernet GigabitEthernet4: alias: CSR2_GigabitEthernet4 type: ethernet GigabitEthernet5: alias: CSR2_GigabitEthernet5 type: ethernet","title":"Generating The testbed file Dynamically from NetBox Inventory"},{"location":"netbox-integrations/pyats/#structured-data-vs-unstructured-data","text":"When you run a command at the CLI of a network device, you get unstructured data back as the response, which is just a blob of text: CSR1#sh ip interface brief Interface IP-Address OK? Method Status Protocol GigabitEthernet1 10.0.0.15 YES manual up up GigabitEthernet2 192.168.1.1 YES manual up up Loopback0 1.1.1.1 YES manual up up This is great for humans, as we can read this, but a computer cannot understand this data. Also if the next version of the OS you are using makes a change to the way that the output is formatted then you will have a problem and have to re-write your scripts to handle this. This is where the Genie parser comes into play as it will parse the output into structured data. The data is then represented using key/value pairs in JSON format that can be used by a computer: { \"interface\": { \"GigabitEthernet1\": { \"interface_is_ok\": \"YES\", \"ip_address\": \"10.0.0.15\", \"method\": \"manual\", \"protocol\": \"up\", \"status\": \"up\" }, \"GigabitEthernet2\": { \"interface_is_ok\": \"YES\", \"ip_address\": \"192.168.1.1\", \"method\": \"manual\", \"protocol\": \"up\", \"status\": \"up\" }, \"Loopback0\": { \"interface_is_ok\": \"YES\", \"ip_address\": \"1.1.1.1\", \"method\": \"manual\", \"protocol\": \"up\", \"status\": \"up\" } } }","title":"Structured Data Vs Unstructured Data"},{"location":"netbox-integrations/pyats/#running-your-first-tests-with-the-genie-cli","text":"","title":"Running Your First Tests With The Genie CLI"},{"location":"netbox-integrations/pyats/#genie-parsing","text":"There are parsers available for a large number of network OS's (not just Cisco), and you can view the complete list here In this example we will run the genie parse command to parse the output of the show ip ospf neighbor command and limit it to just device CSR1 : genie parse 'show ip ospf neighbor' --testbed-file testbed.yaml --device CSR1 0%| | 0/1 [00:00<?, ?it/s]{ \"interfaces\": { \"GigabitEthernet2\": { \"neighbors\": { \"2.2.2.2\": { \"address\": \"192.168.1.2\", \"dead_time\": \"00:00:34\", \"priority\": 1, \"state\": \"FULL/DR\" } } } } } This will output the parsed data to your terminal, but if you want to save the output just append the directory you wish to save it to with the --output switch. This will save both the _console file (the unstructured data) and the _parsed file (the structured data), along with the connection_ log (the raw output of the full connection process) into the chosen directory: genie parse 'show ip ospf neighbor' --testbed-file testbed.yaml --device CSR1 --output csr1 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:01<00:00, 1.01s/it] +==============================================================================+ | Genie Parse Summary for CSR1 | +==============================================================================+ | Connected to CSR1 | | - Log: csr1/connection_CSR1.txt | |------------------------------------------------------------------------------| | Parsed command 'show ip ospf neighbor' | | - Parsed structure: csr1/CSR1_show-ip-ospf-neighbor_parsed.txt | | - Device Console: csr1/CSR1_show-ip-ospf-neighbor_console.txt | |------------------------------------------------------------------------------|","title":"Genie Parsing"},{"location":"netbox-integrations/pyats/#genie-learning","text":"In this example we will run the genie learn command to learn all about routing and ospf for both devices in our testbed file. We will also save the output into directory called pre-change . Genie will automagically create directories for us if they don't already exist. For reference if you run the genie learn all command then for IOS-XE devices the list of features learned is: acl, arp, bgp, device, dot1x, eigrp, fdb, hsrp, igmp, interface, isis, lag, lisp, lldp, mcast, mld, msdp, nd, ntp, ospf, pim, platform, prefix_list, rip, route_policy, routing, static_routing, stp, terminal, utils, vlan, vrf, vxlan, config genie learn routing ospf --testbed-file testbed.yaml --output pre-change Learning '['routing', 'ospf']' on devices '['CSR1', 'CSR2']' 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:11<00:00, 5.85s/it] +==============================================================================+ | Genie Learn Summary for device CSR1 | +==============================================================================+ | Connected to CSR1 | | - Log: pre-change/connection_CSR1.txt | |------------------------------------------------------------------------------| | Learnt feature 'routing' | | - Ops structure: pre-change/routing_iosxe_CSR1_ops.txt | | - Device Console: pre-change/routing_iosxe_CSR1_console.txt | |------------------------------------------------------------------------------| | Learnt feature 'ospf' | | - Ops structure: pre-change/ospf_iosxe_CSR1_ops.txt | | - Device Console: pre-change/ospf_iosxe_CSR1_console.txt | |==============================================================================| +==============================================================================+ | Genie Learn Summary for device CSR2 | +==============================================================================+ | Connected to CSR2 | | - Log: pre-change/connection_CSR2.txt | |------------------------------------------------------------------------------| | Learnt feature 'routing' | | - Ops structure: pre-change/routing_iosxe_CSR2_ops.txt | | - Device Console: pre-change/routing_iosxe_CSR2_console.txt | |------------------------------------------------------------------------------| | Learnt feature 'ospf' | | - Ops structure: pre-change/ospf_iosxe_CSR2_ops.txt | | - Device Console: pre-change/ospf_iosxe_CSR2_console.txt | |==============================================================================|","title":"Genie Learning"},{"location":"netbox-integrations/pyats/#making-a-change-to-the-network","text":"Let's make a small change to the CSR2 router in our test network, and remove the network 2.2.2.2 0.0.0.0 area 0 statement from the OSPF configuration: CSR2#conf t Enter configuration commands, one per line. End with CNTL/Z. CSR2(config)#router ospf 1 CSR2(config-router)#no network 2.2.2.2 0.0.0.0 area 0 Next lets re-learn routing and ospf for both devices in our testbed file. We will also save the output into directory called post-change : genie learn routing ospf --testbed-file testbed.yaml --output post-change Learning '['routing', 'ospf']' on devices '['CSR1', 'CSR2']' 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:11<00:00, 5.84s/it] +==============================================================================+ | Genie Learn Summary for device CSR1 | +==============================================================================+ | Connected to CSR1 | | - Log: post-change/connection_CSR1.txt | |------------------------------------------------------------------------------| | Learnt feature 'routing' | | - Ops structure: post-change/routing_iosxe_CSR1_ops.txt | | - Device Console: post-change/routing_iosxe_CSR1_console.txt | |------------------------------------------------------------------------------| | Learnt feature 'ospf' | | - Ops structure: post-change/ospf_iosxe_CSR1_ops.txt | | - Device Console: post-change/ospf_iosxe_CSR1_console.txt | |==============================================================================| +==============================================================================+ | Genie Learn Summary for device CSR2 | +==============================================================================+ | Connected to CSR2 | | - Log: post-change/connection_CSR2.txt | |------------------------------------------------------------------------------| | Learnt feature 'routing' | | - Ops structure: post-change/routing_iosxe_CSR2_ops.txt | | - Device Console: post-change/routing_iosxe_CSR2_console.txt | |------------------------------------------------------------------------------| | Learnt feature 'ospf' | | - Ops structure: post-change/ospf_iosxe_CSR2_ops.txt | | - Device Console: post-change/ospf_iosxe_CSR2_console.txt | |==============================================================================|","title":"Making a Change to The Network"},{"location":"netbox-integrations/pyats/#genie-diff","text":"Now let's use the genie diff command to tell us what changed in our network, and we will store the output in a directory called routing-diff : genie diff pre-change post-change --output diff 1it [00:00, 333.44it/s] +==============================================================================+ | Genie Diff Summary between directories pre-change/ and post-change/ | +==============================================================================+ | File: routing_iosxe_CSR2_ops.txt | | - Identical | |------------------------------------------------------------------------------| | File: ospf_iosxe_CSR1_ops.txt | | - Identical | |------------------------------------------------------------------------------| | File: routing_iosxe_CSR1_ops.txt | | - Diff can be found at diff/diff_routing_iosxe_CSR1_ops.txt | |------------------------------------------------------------------------------| | File: ospf_iosxe_CSR2_ops.txt | | - Diff can be found at diff/diff_ospf_iosxe_CSR2_ops.txt | |------------------------------------------------------------------------------| There are differences in the outputs of both the routing_iosxe_CSR1_ops.txt and ospf_iosxe_CSR2_ops.txt files and we can view the contents of those files to see what has changed: cat diff/diff_routing_iosxe_CSR1_ops.txt --- pre-change/routing_iosxe_CSR1_ops.txt +++ post-change/routing_iosxe_CSR1_ops.txt info: vrf: default: address_family: ipv4: routes: - 2.2.2.2/32: - active: True - metric: 2 - next_hop: - next_hop_list: - 1: - index: 1 - next_hop: 192.168.1.2 - outgoing_interface: GigabitEthernet2 - updated: 03:32:43 - route: 2.2.2.2/32 - route_preference: 110 - source_protocol: ospf - source_protocol_codes: O% cat diff/diff_ospf_iosxe_CSR2_ops.txt --- pre-change/ospf_iosxe_CSR2_ops.txt +++ post-change/ospf_iosxe_CSR2_ops.txt info: vrf: default: address_family: ipv4: instance: 1: areas: 0.0.0.0: interfaces: - Loopback0: - bfd: - enable: False - cost: 1 - demand_circuit: False - enable: True - interface_type: loopback - name: Loopback0% As we can see, CSR1 has lost the the route to the 2.2.2.2/32 prefix and on CSR2 the interface lo0 has been removed from OSPF area 0 .","title":"Genie Diff"},{"location":"netbox-integrations/pyats/#pyats-and-python","text":"As you would expect, it is also very easy to work with pyATS and python. Type python in your terminal, and then start by importing the load module from the genie.testbed library and load the testbed file: from genie.testbed import load testbed = load('testbed.yaml') Then connect to the CSR1 device: device = testbed.devices['CSR1'] device.connect() Then parse the command show ip interface brief and print the output nicely using the pprint library: parsed_data = device.parse('show ip interface brief') from pprint import pprint pprint(parsed_data) {'interface': {'GigabitEthernet1': {'interface_is_ok': 'YES', 'ip_address': '10.0.0.15', 'method': 'manual', 'protocol': 'up', 'status': 'up'}, 'GigabitEthernet2': {'interface_is_ok': 'YES', 'ip_address': '192.168.1.1', 'method': 'manual', 'protocol': 'up', 'status': 'up'}, 'Loopback0': {'interface_is_ok': 'YES', 'ip_address': '1.1.1.1', 'method': 'manual', 'protocol': 'up', 'status': 'up'}}} Lastly, close the connection to the device: device.disconnect() As you can imagine, the possibilities are endless and you can see an example of a script that gets and prints OSPF Neighbor table for a given device in the file ospf_neighbor_table.py . Run the script and you will get a nicely formatted table of the OSPF neighbors for CRS1: python ospf_neighbor_table.py OSPF Neighbor Table for CSR1 +------------------+----------+-------------+---------+ | Interface | Neighbor | Address | State | +------------------+----------+-------------+---------+ | GigabitEthernet2 | 2.2.2.2 | 192.168.1.2 | FULL/DR | +------------------+----------+-------------+---------+","title":"pyATS and Python"},{"location":"netbox-integrations/pyats/#pyats-test-scripts-and-jobs","text":"So far we have only scratched the surface of what you can do with pyATS, and test scripts will take your automated testing to the next level. Test scripts are written and executed with the AEtest Python package I have included an example test script called connectivity_check.py , which is adapted from the example script in the official documentation . This script tests that both CSR1 and CSR2 can ping each other's loopback addresses. Test scripts are structured Python files that contain/describe the testing you want to do. A clean, elegant test script is scalable, and generates easy-to-read test results and logs. To run the example test script, you must also specify the testbed file that is to be used, for example: python connectivity_check.py --testbed testbed.yaml Once the test script has been run then the results are displayed in the output: 2024-04-23T11:50:16: %AETEST-INFO: +------------------------------------------------------------------------------+ 2024-04-23T11:50:16: %AETEST-INFO: | Detailed Results | 2024-04-23T11:50:16: %AETEST-INFO: +------------------------------------------------------------------------------+ 2024-04-23T11:50:16: %AETEST-INFO: SECTIONS/TESTCASES RESULT 2024-04-23T11:50:16: %AETEST-INFO: -------------------------------------------------------------------------------- 2024-04-23T11:50:16: %AETEST-INFO: . 2024-04-23T11:50:16: %AETEST-INFO: |-- common_setup PASSED 2024-04-23T11:50:16: %AETEST-INFO: | |-- check_topology PASSED 2024-04-23T11:50:16: %AETEST-INFO: | `-- establish_connections PASSED 2024-04-23T11:50:16: %AETEST-INFO: | |-- Step 1: Connecting to CSR1 PASSED 2024-04-23T11:50:16: %AETEST-INFO: | `-- Step 2: Connecting to CSR2 PASSED 2024-04-23T11:50:16: %AETEST-INFO: |-- PingTestcase[device=device1] PASSED 2024-04-23T11:50:16: %AETEST-INFO: | |-- ping[destination=192.168.1.1] PASSED 2024-04-23T11:50:16: %AETEST-INFO: | `-- ping[destination=192.168.1.2] PASSED 2024-04-23T11:50:16: %AETEST-INFO: |-- PingTestcase[device=device2] PASSED 2024-04-23T11:50:16: %AETEST-INFO: | |-- ping[destination=192.168.1.1] PASSED 2024-04-23T11:50:16: %AETEST-INFO: | `-- ping[destination=192.168.1.2] PASSED 2024-04-23T11:50:16: %AETEST-INFO: `-- common_cleanup PASSED 2024-04-23T11:50:16: %AETEST-INFO: `-- disconnect PASSED 2024-04-23T11:50:16: %AETEST-INFO: |-- Step 1: Disconnecting from CSR1 PASSED 2024-04-23T11:50:16: %AETEST-INFO: `-- Step 2: Disconnecting from CSR2 PASSED 2024-04-23T11:50:16: %AETEST-INFO: +------------------------------------------------------------------------------+ 2024-04-23T11:50:16: %AETEST-INFO: | Summary | 2024-04-23T11:50:16: %AETEST-INFO: +------------------------------------------------------------------------------+ 2024-04-23T11:50:16: %AETEST-INFO: Number of ABORTED 0 2024-04-23T11:50:16: %AETEST-INFO: Number of BLOCKED 0 2024-04-23T11:50:16: %AETEST-INFO: Number of ERRORED 0 2024-04-23T11:50:16: %AETEST-INFO: Number of FAILED 0 2024-04-23T11:50:16: %AETEST-INFO: Number of PASSED 4 2024-04-23T11:50:16: %AETEST-INFO: Number of PASSX 0 2024-04-23T11:50:16: %AETEST-INFO: Number of SKIPPED 0 2024-04-23T11:50:16: %AETEST-INFO: Total Number 4 2024-04-23T11:50:16: %AETEST-INFO: Success Rate 100.0% 2024-04-23T11:50:16: %AETEST-INFO: -------------------------------------------------------------------------------- pyATS Jobs take test scripts to another level and allow the execution of test scripts as tasks. This is beyond the scope of this document but you can read all about pyATS jobs in the official docs","title":"pyATS Test Scripts and Jobs"},{"location":"sdks/pynetbox/","text":"NetBox SDKs Pynetbox Python API client library for NetBox . Note: Version 6.7 and later of the library only supports NetBox 3.3 and above. This guide will help you get started, but for more information, see the Pynetbox Git Repository Installation To install run pip install pynetbox . Alternatively, you can clone the repo and run python setup.py install . Quick Start The full pynetbox API is documented on Read the Docs , but the following should be enough to get started using it. To begin, import pynetbox and instantiate the API. import pynetbox nb = pynetbox.api( 'http://localhost:8000', token='d6f4e314a5b5fefd164995169f28ae32d987704f' ) The first argument the .api() method takes is the NetBox URL. There are a handful of named arguments you can provide, but in most cases none are required to simply pull data. In order to write, the token argument should to be provided. Queries The pynetbox API is setup so that NetBox's apps are attributes of the .api() object, and in turn those apps have attribute representing each endpoint. Each endpoint has a handful of methods available to carry out actions on the endpoint. For example, in order to query all the objects in the devices endpoint you would do the following: >>> devices = nb.dcim.devices.all() >>> for device in devices: ... print(device.name) ... test1-leaf1 test1-leaf2 test1-leaf3 >>> Note that the all() and filter() methods are generators and return an object that can be iterated over only once. If you are going to be iterating over it repeatedly you need to either call the all() method again, or encapsulate the results in a list object like this: >>> devices = list(nb.dcim.devices.all()) Threading pynetbox supports multithreaded calls for .filter() and .all() queries. It is highly recommended you have MAX_PAGE_SIZE in your Netbox install set to anything except 0 or None . The default value of 1000 is usually a good value to use. To enable threading, add threading=True parameter to the .api : nb = pynetbox . api ( 'http://localhost:8000' , threading = True , ) Alternative Library For those interested in a different approach, there is an alternative Python API client library available for NetBox called netbox-python . This library provides a thin Python wrapper over the NetBox API. netbox-python offers a minimalistic interface to interact with NetBox's API. While it may not provide all the features available in pynetbox, it offers a lightweight and straightforward option for interfacing with NetBox. To explore further details and access the documentation, please visit the netbox-python .","title":"Pynetbox"},{"location":"sdks/pynetbox/#netbox-sdks","text":"","title":"NetBox SDKs"},{"location":"sdks/pynetbox/#pynetbox","text":"Python API client library for NetBox . Note: Version 6.7 and later of the library only supports NetBox 3.3 and above. This guide will help you get started, but for more information, see the Pynetbox Git Repository","title":"Pynetbox"},{"location":"sdks/pynetbox/#installation","text":"To install run pip install pynetbox . Alternatively, you can clone the repo and run python setup.py install .","title":"Installation"},{"location":"sdks/pynetbox/#quick-start","text":"The full pynetbox API is documented on Read the Docs , but the following should be enough to get started using it. To begin, import pynetbox and instantiate the API. import pynetbox nb = pynetbox.api( 'http://localhost:8000', token='d6f4e314a5b5fefd164995169f28ae32d987704f' ) The first argument the .api() method takes is the NetBox URL. There are a handful of named arguments you can provide, but in most cases none are required to simply pull data. In order to write, the token argument should to be provided.","title":"Quick Start"},{"location":"sdks/pynetbox/#queries","text":"The pynetbox API is setup so that NetBox's apps are attributes of the .api() object, and in turn those apps have attribute representing each endpoint. Each endpoint has a handful of methods available to carry out actions on the endpoint. For example, in order to query all the objects in the devices endpoint you would do the following: >>> devices = nb.dcim.devices.all() >>> for device in devices: ... print(device.name) ... test1-leaf1 test1-leaf2 test1-leaf3 >>> Note that the all() and filter() methods are generators and return an object that can be iterated over only once. If you are going to be iterating over it repeatedly you need to either call the all() method again, or encapsulate the results in a list object like this: >>> devices = list(nb.dcim.devices.all())","title":"Queries"},{"location":"sdks/pynetbox/#threading","text":"pynetbox supports multithreaded calls for .filter() and .all() queries. It is highly recommended you have MAX_PAGE_SIZE in your Netbox install set to anything except 0 or None . The default value of 1000 is usually a good value to use. To enable threading, add threading=True parameter to the .api : nb = pynetbox . api ( 'http://localhost:8000' , threading = True , ) Alternative Library For those interested in a different approach, there is an alternative Python API client library available for NetBox called netbox-python . This library provides a thin Python wrapper over the NetBox API. netbox-python offers a minimalistic interface to interact with NetBox's API. While it may not provide all the features available in pynetbox, it offers a lightweight and straightforward option for interfacing with NetBox. To explore further details and access the documentation, please visit the netbox-python .","title":"Threading"}]}